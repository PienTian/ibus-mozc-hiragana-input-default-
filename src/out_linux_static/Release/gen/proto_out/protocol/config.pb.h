// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol/config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocol_2fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protocol_2fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protocol_2fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protocol_2fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_2fconfig_2eproto;
namespace mozc {
namespace config {
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Config_CharacterFormRule;
class Config_CharacterFormRuleDefaultTypeInternal;
extern Config_CharacterFormRuleDefaultTypeInternal _Config_CharacterFormRule_default_instance_;
class Config_InformationListConfig;
class Config_InformationListConfigDefaultTypeInternal;
extern Config_InformationListConfigDefaultTypeInternal _Config_InformationListConfig_default_instance_;
class GeneralConfig;
class GeneralConfigDefaultTypeInternal;
extern GeneralConfigDefaultTypeInternal _GeneralConfig_default_instance_;
}  // namespace config
}  // namespace mozc
PROTOBUF_NAMESPACE_OPEN
template<> ::mozc::config::Config* Arena::CreateMaybeMessage<::mozc::config::Config>(Arena*);
template<> ::mozc::config::Config_CharacterFormRule* Arena::CreateMaybeMessage<::mozc::config::Config_CharacterFormRule>(Arena*);
template<> ::mozc::config::Config_InformationListConfig* Arena::CreateMaybeMessage<::mozc::config::Config_InformationListConfig>(Arena*);
template<> ::mozc::config::GeneralConfig* Arena::CreateMaybeMessage<::mozc::config::GeneralConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mozc {
namespace config {

enum Config_PreeditMethod : int {
  Config_PreeditMethod_ROMAN = 0,
  Config_PreeditMethod_KANA = 1
};
bool Config_PreeditMethod_IsValid(int value);
constexpr Config_PreeditMethod Config_PreeditMethod_PreeditMethod_MIN = Config_PreeditMethod_ROMAN;
constexpr Config_PreeditMethod Config_PreeditMethod_PreeditMethod_MAX = Config_PreeditMethod_KANA;
constexpr int Config_PreeditMethod_PreeditMethod_ARRAYSIZE = Config_PreeditMethod_PreeditMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_PreeditMethod_descriptor();
template<typename T>
inline const std::string& Config_PreeditMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_PreeditMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_PreeditMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_PreeditMethod_descriptor(), enum_t_value);
}
inline bool Config_PreeditMethod_Parse(
    const std::string& name, Config_PreeditMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_PreeditMethod>(
    Config_PreeditMethod_descriptor(), name, value);
}
enum Config_SessionKeymap : int {
  Config_SessionKeymap_NONE = -1,
  Config_SessionKeymap_CUSTOM = 0,
  Config_SessionKeymap_ATOK = 1,
  Config_SessionKeymap_MSIME = 2,
  Config_SessionKeymap_KOTOERI = 3,
  Config_SessionKeymap_MOBILE = 4,
  Config_SessionKeymap_CHROMEOS = 5
};
bool Config_SessionKeymap_IsValid(int value);
constexpr Config_SessionKeymap Config_SessionKeymap_SessionKeymap_MIN = Config_SessionKeymap_NONE;
constexpr Config_SessionKeymap Config_SessionKeymap_SessionKeymap_MAX = Config_SessionKeymap_CHROMEOS;
constexpr int Config_SessionKeymap_SessionKeymap_ARRAYSIZE = Config_SessionKeymap_SessionKeymap_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_SessionKeymap_descriptor();
template<typename T>
inline const std::string& Config_SessionKeymap_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_SessionKeymap>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_SessionKeymap_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_SessionKeymap_descriptor(), enum_t_value);
}
inline bool Config_SessionKeymap_Parse(
    const std::string& name, Config_SessionKeymap* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_SessionKeymap>(
    Config_SessionKeymap_descriptor(), name, value);
}
enum Config_PunctuationMethod : int {
  Config_PunctuationMethod_KUTEN_TOUTEN = 0,
  Config_PunctuationMethod_COMMA_PERIOD = 1,
  Config_PunctuationMethod_KUTEN_PERIOD = 2,
  Config_PunctuationMethod_COMMA_TOUTEN = 3
};
bool Config_PunctuationMethod_IsValid(int value);
constexpr Config_PunctuationMethod Config_PunctuationMethod_PunctuationMethod_MIN = Config_PunctuationMethod_KUTEN_TOUTEN;
constexpr Config_PunctuationMethod Config_PunctuationMethod_PunctuationMethod_MAX = Config_PunctuationMethod_COMMA_TOUTEN;
constexpr int Config_PunctuationMethod_PunctuationMethod_ARRAYSIZE = Config_PunctuationMethod_PunctuationMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_PunctuationMethod_descriptor();
template<typename T>
inline const std::string& Config_PunctuationMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_PunctuationMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_PunctuationMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_PunctuationMethod_descriptor(), enum_t_value);
}
inline bool Config_PunctuationMethod_Parse(
    const std::string& name, Config_PunctuationMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_PunctuationMethod>(
    Config_PunctuationMethod_descriptor(), name, value);
}
enum Config_SymbolMethod : int {
  Config_SymbolMethod_CORNER_BRACKET_MIDDLE_DOT = 0,
  Config_SymbolMethod_SQUARE_BRACKET_SLASH = 1,
  Config_SymbolMethod_CORNER_BRACKET_SLASH = 2,
  Config_SymbolMethod_SQUARE_BRACKET_MIDDLE_DOT = 3
};
bool Config_SymbolMethod_IsValid(int value);
constexpr Config_SymbolMethod Config_SymbolMethod_SymbolMethod_MIN = Config_SymbolMethod_CORNER_BRACKET_MIDDLE_DOT;
constexpr Config_SymbolMethod Config_SymbolMethod_SymbolMethod_MAX = Config_SymbolMethod_SQUARE_BRACKET_MIDDLE_DOT;
constexpr int Config_SymbolMethod_SymbolMethod_ARRAYSIZE = Config_SymbolMethod_SymbolMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_SymbolMethod_descriptor();
template<typename T>
inline const std::string& Config_SymbolMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_SymbolMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_SymbolMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_SymbolMethod_descriptor(), enum_t_value);
}
inline bool Config_SymbolMethod_Parse(
    const std::string& name, Config_SymbolMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_SymbolMethod>(
    Config_SymbolMethod_descriptor(), name, value);
}
enum Config_FundamentalCharacterForm : int {
  Config_FundamentalCharacterForm_FUNDAMENTAL_INPUT_MODE = 0,
  Config_FundamentalCharacterForm_FUNDAMENTAL_FULL_WIDTH = 1,
  Config_FundamentalCharacterForm_FUNDAMENTAL_HALF_WIDTH = 2
};
bool Config_FundamentalCharacterForm_IsValid(int value);
constexpr Config_FundamentalCharacterForm Config_FundamentalCharacterForm_FundamentalCharacterForm_MIN = Config_FundamentalCharacterForm_FUNDAMENTAL_INPUT_MODE;
constexpr Config_FundamentalCharacterForm Config_FundamentalCharacterForm_FundamentalCharacterForm_MAX = Config_FundamentalCharacterForm_FUNDAMENTAL_HALF_WIDTH;
constexpr int Config_FundamentalCharacterForm_FundamentalCharacterForm_ARRAYSIZE = Config_FundamentalCharacterForm_FundamentalCharacterForm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_FundamentalCharacterForm_descriptor();
template<typename T>
inline const std::string& Config_FundamentalCharacterForm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_FundamentalCharacterForm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_FundamentalCharacterForm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_FundamentalCharacterForm_descriptor(), enum_t_value);
}
inline bool Config_FundamentalCharacterForm_Parse(
    const std::string& name, Config_FundamentalCharacterForm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_FundamentalCharacterForm>(
    Config_FundamentalCharacterForm_descriptor(), name, value);
}
enum Config_HistoryLearningLevel : int {
  Config_HistoryLearningLevel_DEFAULT_HISTORY = 0,
  Config_HistoryLearningLevel_READ_ONLY = 1,
  Config_HistoryLearningLevel_NO_HISTORY = 2
};
bool Config_HistoryLearningLevel_IsValid(int value);
constexpr Config_HistoryLearningLevel Config_HistoryLearningLevel_HistoryLearningLevel_MIN = Config_HistoryLearningLevel_DEFAULT_HISTORY;
constexpr Config_HistoryLearningLevel Config_HistoryLearningLevel_HistoryLearningLevel_MAX = Config_HistoryLearningLevel_NO_HISTORY;
constexpr int Config_HistoryLearningLevel_HistoryLearningLevel_ARRAYSIZE = Config_HistoryLearningLevel_HistoryLearningLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_HistoryLearningLevel_descriptor();
template<typename T>
inline const std::string& Config_HistoryLearningLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_HistoryLearningLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_HistoryLearningLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_HistoryLearningLevel_descriptor(), enum_t_value);
}
inline bool Config_HistoryLearningLevel_Parse(
    const std::string& name, Config_HistoryLearningLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_HistoryLearningLevel>(
    Config_HistoryLearningLevel_descriptor(), name, value);
}
enum Config_SelectionShortcut : int {
  Config_SelectionShortcut_NO_SHORTCUT = 0,
  Config_SelectionShortcut_SHORTCUT_123456789 = 1,
  Config_SelectionShortcut_SHORTCUT_ASDFGHJKL = 2
};
bool Config_SelectionShortcut_IsValid(int value);
constexpr Config_SelectionShortcut Config_SelectionShortcut_SelectionShortcut_MIN = Config_SelectionShortcut_NO_SHORTCUT;
constexpr Config_SelectionShortcut Config_SelectionShortcut_SelectionShortcut_MAX = Config_SelectionShortcut_SHORTCUT_ASDFGHJKL;
constexpr int Config_SelectionShortcut_SelectionShortcut_ARRAYSIZE = Config_SelectionShortcut_SelectionShortcut_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_SelectionShortcut_descriptor();
template<typename T>
inline const std::string& Config_SelectionShortcut_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_SelectionShortcut>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_SelectionShortcut_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_SelectionShortcut_descriptor(), enum_t_value);
}
inline bool Config_SelectionShortcut_Parse(
    const std::string& name, Config_SelectionShortcut* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_SelectionShortcut>(
    Config_SelectionShortcut_descriptor(), name, value);
}
enum Config_CharacterForm : int {
  Config_CharacterForm_HALF_WIDTH = 0,
  Config_CharacterForm_FULL_WIDTH = 1,
  Config_CharacterForm_LAST_FORM = 2,
  Config_CharacterForm_NO_CONVERSION = 3
};
bool Config_CharacterForm_IsValid(int value);
constexpr Config_CharacterForm Config_CharacterForm_CharacterForm_MIN = Config_CharacterForm_HALF_WIDTH;
constexpr Config_CharacterForm Config_CharacterForm_CharacterForm_MAX = Config_CharacterForm_NO_CONVERSION;
constexpr int Config_CharacterForm_CharacterForm_ARRAYSIZE = Config_CharacterForm_CharacterForm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_CharacterForm_descriptor();
template<typename T>
inline const std::string& Config_CharacterForm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_CharacterForm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_CharacterForm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_CharacterForm_descriptor(), enum_t_value);
}
inline bool Config_CharacterForm_Parse(
    const std::string& name, Config_CharacterForm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_CharacterForm>(
    Config_CharacterForm_descriptor(), name, value);
}
enum Config_ShiftKeyModeSwitch : int {
  Config_ShiftKeyModeSwitch_OFF = 0,
  Config_ShiftKeyModeSwitch_ASCII_INPUT_MODE = 1,
  Config_ShiftKeyModeSwitch_KATAKANA_INPUT_MODE = 2
};
bool Config_ShiftKeyModeSwitch_IsValid(int value);
constexpr Config_ShiftKeyModeSwitch Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MIN = Config_ShiftKeyModeSwitch_OFF;
constexpr Config_ShiftKeyModeSwitch Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MAX = Config_ShiftKeyModeSwitch_KATAKANA_INPUT_MODE;
constexpr int Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_ARRAYSIZE = Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_ShiftKeyModeSwitch_descriptor();
template<typename T>
inline const std::string& Config_ShiftKeyModeSwitch_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_ShiftKeyModeSwitch>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_ShiftKeyModeSwitch_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_ShiftKeyModeSwitch_descriptor(), enum_t_value);
}
inline bool Config_ShiftKeyModeSwitch_Parse(
    const std::string& name, Config_ShiftKeyModeSwitch* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_ShiftKeyModeSwitch>(
    Config_ShiftKeyModeSwitch_descriptor(), name, value);
}
enum Config_NumpadCharacterForm : int {
  Config_NumpadCharacterForm_NUMPAD_INPUT_MODE = 0,
  Config_NumpadCharacterForm_NUMPAD_FULL_WIDTH = 1,
  Config_NumpadCharacterForm_NUMPAD_HALF_WIDTH = 2,
  Config_NumpadCharacterForm_NUMPAD_DIRECT_INPUT = 3
};
bool Config_NumpadCharacterForm_IsValid(int value);
constexpr Config_NumpadCharacterForm Config_NumpadCharacterForm_NumpadCharacterForm_MIN = Config_NumpadCharacterForm_NUMPAD_INPUT_MODE;
constexpr Config_NumpadCharacterForm Config_NumpadCharacterForm_NumpadCharacterForm_MAX = Config_NumpadCharacterForm_NUMPAD_DIRECT_INPUT;
constexpr int Config_NumpadCharacterForm_NumpadCharacterForm_ARRAYSIZE = Config_NumpadCharacterForm_NumpadCharacterForm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_NumpadCharacterForm_descriptor();
template<typename T>
inline const std::string& Config_NumpadCharacterForm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_NumpadCharacterForm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_NumpadCharacterForm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_NumpadCharacterForm_descriptor(), enum_t_value);
}
inline bool Config_NumpadCharacterForm_Parse(
    const std::string& name, Config_NumpadCharacterForm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_NumpadCharacterForm>(
    Config_NumpadCharacterForm_descriptor(), name, value);
}
enum Config_AutoConversionKey : int {
  Config_AutoConversionKey_AUTO_CONVERSION_OFF = 0,
  Config_AutoConversionKey_AUTO_CONVERSION_KUTEN = 1,
  Config_AutoConversionKey_AUTO_CONVERSION_TOUTEN = 2,
  Config_AutoConversionKey_AUTO_CONVERSION_QUESTION_MARK = 4,
  Config_AutoConversionKey_AUTO_CONVERSION_EXCLAMATION_MARK = 8
};
bool Config_AutoConversionKey_IsValid(int value);
constexpr Config_AutoConversionKey Config_AutoConversionKey_AutoConversionKey_MIN = Config_AutoConversionKey_AUTO_CONVERSION_OFF;
constexpr Config_AutoConversionKey Config_AutoConversionKey_AutoConversionKey_MAX = Config_AutoConversionKey_AUTO_CONVERSION_EXCLAMATION_MARK;
constexpr int Config_AutoConversionKey_AutoConversionKey_ARRAYSIZE = Config_AutoConversionKey_AutoConversionKey_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_AutoConversionKey_descriptor();
template<typename T>
inline const std::string& Config_AutoConversionKey_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_AutoConversionKey>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_AutoConversionKey_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_AutoConversionKey_descriptor(), enum_t_value);
}
inline bool Config_AutoConversionKey_Parse(
    const std::string& name, Config_AutoConversionKey* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_AutoConversionKey>(
    Config_AutoConversionKey_descriptor(), name, value);
}
enum Config_YenSignCharacter : int {
  Config_YenSignCharacter_YEN_SIGN = 0,
  Config_YenSignCharacter_BACKSLASH = 1
};
bool Config_YenSignCharacter_IsValid(int value);
constexpr Config_YenSignCharacter Config_YenSignCharacter_YenSignCharacter_MIN = Config_YenSignCharacter_YEN_SIGN;
constexpr Config_YenSignCharacter Config_YenSignCharacter_YenSignCharacter_MAX = Config_YenSignCharacter_BACKSLASH;
constexpr int Config_YenSignCharacter_YenSignCharacter_ARRAYSIZE = Config_YenSignCharacter_YenSignCharacter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_YenSignCharacter_descriptor();
template<typename T>
inline const std::string& Config_YenSignCharacter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_YenSignCharacter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_YenSignCharacter_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_YenSignCharacter_descriptor(), enum_t_value);
}
inline bool Config_YenSignCharacter_Parse(
    const std::string& name, Config_YenSignCharacter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_YenSignCharacter>(
    Config_YenSignCharacter_descriptor(), name, value);
}
// ===================================================================

class GeneralConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.config.GeneralConfig) */ {
 public:
  inline GeneralConfig() : GeneralConfig(nullptr) {};
  virtual ~GeneralConfig();

  GeneralConfig(const GeneralConfig& from);
  GeneralConfig(GeneralConfig&& from) noexcept
    : GeneralConfig() {
    *this = ::std::move(from);
  }

  inline GeneralConfig& operator=(const GeneralConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeneralConfig& operator=(GeneralConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeneralConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeneralConfig* internal_default_instance() {
    return reinterpret_cast<const GeneralConfig*>(
               &_GeneralConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GeneralConfig& a, GeneralConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GeneralConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeneralConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeneralConfig* New() const final {
    return CreateMaybeMessage<GeneralConfig>(nullptr);
  }

  GeneralConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeneralConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeneralConfig& from);
  void MergeFrom(const GeneralConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeneralConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.config.GeneralConfig";
  }
  protected:
  explicit GeneralConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fconfig_2eproto);
    return ::descriptor_table_protocol_2fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastModifiedProductVersionFieldNumber = 2,
    kPlatformFieldNumber = 4,
    kUiLocaleFieldNumber = 5,
    kLastModifiedTimeFieldNumber = 3,
    kConfigVersionFieldNumber = 1,
    kUploadUsageStatsFieldNumber = 6,
  };
  // optional string last_modified_product_version = 2 [default = "0.0.0.0"];
  bool has_last_modified_product_version() const;
  private:
  bool _internal_has_last_modified_product_version() const;
  public:
  void clear_last_modified_product_version();
  const std::string& last_modified_product_version() const;
  void set_last_modified_product_version(const std::string& value);
  void set_last_modified_product_version(std::string&& value);
  void set_last_modified_product_version(const char* value);
  void set_last_modified_product_version(const char* value, size_t size);
  std::string* mutable_last_modified_product_version();
  std::string* release_last_modified_product_version();
  void set_allocated_last_modified_product_version(std::string* last_modified_product_version);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_last_modified_product_version();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_last_modified_product_version(
      std::string* last_modified_product_version);
  private:
  const std::string& _internal_last_modified_product_version() const;
  void _internal_set_last_modified_product_version(const std::string& value);
  std::string* _internal_mutable_last_modified_product_version();
  public:

  // optional string platform = 4 [default = ""];
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  void set_platform(const std::string& value);
  void set_platform(std::string&& value);
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  std::string* mutable_platform();
  std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_platform();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_platform(
      std::string* platform);
  private:
  const std::string& _internal_platform() const;
  void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // optional string ui_locale = 5 [default = ""];
  bool has_ui_locale() const;
  private:
  bool _internal_has_ui_locale() const;
  public:
  void clear_ui_locale();
  const std::string& ui_locale() const;
  void set_ui_locale(const std::string& value);
  void set_ui_locale(std::string&& value);
  void set_ui_locale(const char* value);
  void set_ui_locale(const char* value, size_t size);
  std::string* mutable_ui_locale();
  std::string* release_ui_locale();
  void set_allocated_ui_locale(std::string* ui_locale);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ui_locale();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ui_locale(
      std::string* ui_locale);
  private:
  const std::string& _internal_ui_locale() const;
  void _internal_set_ui_locale(const std::string& value);
  std::string* _internal_mutable_ui_locale();
  public:

  // optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];
  bool has_last_modified_time() const;
  private:
  bool _internal_has_last_modified_time() const;
  public:
  void clear_last_modified_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_modified_time() const;
  void set_last_modified_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_modified_time() const;
  void _internal_set_last_modified_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 config_version = 1 [default = 0];
  bool has_config_version() const;
  private:
  bool _internal_has_config_version() const;
  public:
  void clear_config_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 config_version() const;
  void set_config_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_config_version() const;
  void _internal_set_config_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool upload_usage_stats = 6 [default = false];
  bool has_upload_usage_stats() const;
  private:
  bool _internal_has_upload_usage_stats() const;
  public:
  void clear_upload_usage_stats();
  bool upload_usage_stats() const;
  void set_upload_usage_stats(bool value);
  private:
  bool _internal_upload_usage_stats() const;
  void _internal_set_upload_usage_stats(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.config.GeneralConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_last_modified_product_version_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_modified_product_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ui_locale_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_modified_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 config_version_;
  bool upload_usage_stats_;
  friend struct ::TableStruct_protocol_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config_CharacterFormRule PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.config.Config.CharacterFormRule) */ {
 public:
  inline Config_CharacterFormRule() : Config_CharacterFormRule(nullptr) {};
  virtual ~Config_CharacterFormRule();

  Config_CharacterFormRule(const Config_CharacterFormRule& from);
  Config_CharacterFormRule(Config_CharacterFormRule&& from) noexcept
    : Config_CharacterFormRule() {
    *this = ::std::move(from);
  }

  inline Config_CharacterFormRule& operator=(const Config_CharacterFormRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_CharacterFormRule& operator=(Config_CharacterFormRule&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Config_CharacterFormRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config_CharacterFormRule* internal_default_instance() {
    return reinterpret_cast<const Config_CharacterFormRule*>(
               &_Config_CharacterFormRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Config_CharacterFormRule& a, Config_CharacterFormRule& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_CharacterFormRule* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_CharacterFormRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Config_CharacterFormRule* New() const final {
    return CreateMaybeMessage<Config_CharacterFormRule>(nullptr);
  }

  Config_CharacterFormRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Config_CharacterFormRule>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Config_CharacterFormRule& from);
  void MergeFrom(const Config_CharacterFormRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_CharacterFormRule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.config.Config.CharacterFormRule";
  }
  protected:
  explicit Config_CharacterFormRule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fconfig_2eproto);
    return ::descriptor_table_protocol_2fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kPreeditCharacterFormFieldNumber = 2,
    kConversionCharacterFormFieldNumber = 3,
  };
  // optional string group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  void set_group(const std::string& value);
  void set_group(std::string&& value);
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  std::string* mutable_group();
  std::string* release_group();
  void set_allocated_group(std::string* group);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_group();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_group(
      std::string* group);
  private:
  const std::string& _internal_group() const;
  void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];
  bool has_preedit_character_form() const;
  private:
  bool _internal_has_preedit_character_form() const;
  public:
  void clear_preedit_character_form();
  ::mozc::config::Config_CharacterForm preedit_character_form() const;
  void set_preedit_character_form(::mozc::config::Config_CharacterForm value);
  private:
  ::mozc::config::Config_CharacterForm _internal_preedit_character_form() const;
  void _internal_set_preedit_character_form(::mozc::config::Config_CharacterForm value);
  public:

  // optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];
  bool has_conversion_character_form() const;
  private:
  bool _internal_has_conversion_character_form() const;
  public:
  void clear_conversion_character_form();
  ::mozc::config::Config_CharacterForm conversion_character_form() const;
  void set_conversion_character_form(::mozc::config::Config_CharacterForm value);
  private:
  ::mozc::config::Config_CharacterForm _internal_conversion_character_form() const;
  void _internal_set_conversion_character_form(::mozc::config::Config_CharacterForm value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.config.Config.CharacterFormRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  int preedit_character_form_;
  int conversion_character_form_;
  friend struct ::TableStruct_protocol_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config_InformationListConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.config.Config.InformationListConfig) */ {
 public:
  inline Config_InformationListConfig() : Config_InformationListConfig(nullptr) {};
  virtual ~Config_InformationListConfig();

  Config_InformationListConfig(const Config_InformationListConfig& from);
  Config_InformationListConfig(Config_InformationListConfig&& from) noexcept
    : Config_InformationListConfig() {
    *this = ::std::move(from);
  }

  inline Config_InformationListConfig& operator=(const Config_InformationListConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_InformationListConfig& operator=(Config_InformationListConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Config_InformationListConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config_InformationListConfig* internal_default_instance() {
    return reinterpret_cast<const Config_InformationListConfig*>(
               &_Config_InformationListConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Config_InformationListConfig& a, Config_InformationListConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_InformationListConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_InformationListConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Config_InformationListConfig* New() const final {
    return CreateMaybeMessage<Config_InformationListConfig>(nullptr);
  }

  Config_InformationListConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Config_InformationListConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Config_InformationListConfig& from);
  void MergeFrom(const Config_InformationListConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_InformationListConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.config.Config.InformationListConfig";
  }
  protected:
  explicit Config_InformationListConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fconfig_2eproto);
    return ::descriptor_table_protocol_2fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseLocalUsageDictionaryFieldNumber = 1,
  };
  // optional bool use_local_usage_dictionary = 1 [default = true];
  bool has_use_local_usage_dictionary() const;
  private:
  bool _internal_has_use_local_usage_dictionary() const;
  public:
  void clear_use_local_usage_dictionary();
  bool use_local_usage_dictionary() const;
  void set_use_local_usage_dictionary(bool value);
  private:
  bool _internal_use_local_usage_dictionary() const;
  void _internal_set_use_local_usage_dictionary(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.config.Config.InformationListConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_local_usage_dictionary_;
  friend struct ::TableStruct_protocol_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.config.Config) */ {
 public:
  inline Config() : Config(nullptr) {};
  virtual ~Config();

  Config(const Config& from);
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(nullptr);
  }

  Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.config.Config";
  }
  protected:
  explicit Config(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fconfig_2eproto);
    return ::descriptor_table_protocol_2fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Config_CharacterFormRule CharacterFormRule;
  typedef Config_InformationListConfig InformationListConfig;

  typedef Config_PreeditMethod PreeditMethod;
  static constexpr PreeditMethod ROMAN =
    Config_PreeditMethod_ROMAN;
  static constexpr PreeditMethod KANA =
    Config_PreeditMethod_KANA;
  static inline bool PreeditMethod_IsValid(int value) {
    return Config_PreeditMethod_IsValid(value);
  }
  static constexpr PreeditMethod PreeditMethod_MIN =
    Config_PreeditMethod_PreeditMethod_MIN;
  static constexpr PreeditMethod PreeditMethod_MAX =
    Config_PreeditMethod_PreeditMethod_MAX;
  static constexpr int PreeditMethod_ARRAYSIZE =
    Config_PreeditMethod_PreeditMethod_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PreeditMethod_descriptor() {
    return Config_PreeditMethod_descriptor();
  }
  template<typename T>
  static inline const std::string& PreeditMethod_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PreeditMethod>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PreeditMethod_Name.");
    return Config_PreeditMethod_Name(enum_t_value);
  }
  static inline bool PreeditMethod_Parse(const std::string& name,
      PreeditMethod* value) {
    return Config_PreeditMethod_Parse(name, value);
  }

  typedef Config_SessionKeymap SessionKeymap;
  static constexpr SessionKeymap NONE =
    Config_SessionKeymap_NONE;
  static constexpr SessionKeymap CUSTOM =
    Config_SessionKeymap_CUSTOM;
  static constexpr SessionKeymap ATOK =
    Config_SessionKeymap_ATOK;
  static constexpr SessionKeymap MSIME =
    Config_SessionKeymap_MSIME;
  static constexpr SessionKeymap KOTOERI =
    Config_SessionKeymap_KOTOERI;
  static constexpr SessionKeymap MOBILE =
    Config_SessionKeymap_MOBILE;
  static constexpr SessionKeymap CHROMEOS =
    Config_SessionKeymap_CHROMEOS;
  static inline bool SessionKeymap_IsValid(int value) {
    return Config_SessionKeymap_IsValid(value);
  }
  static constexpr SessionKeymap SessionKeymap_MIN =
    Config_SessionKeymap_SessionKeymap_MIN;
  static constexpr SessionKeymap SessionKeymap_MAX =
    Config_SessionKeymap_SessionKeymap_MAX;
  static constexpr int SessionKeymap_ARRAYSIZE =
    Config_SessionKeymap_SessionKeymap_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SessionKeymap_descriptor() {
    return Config_SessionKeymap_descriptor();
  }
  template<typename T>
  static inline const std::string& SessionKeymap_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SessionKeymap>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SessionKeymap_Name.");
    return Config_SessionKeymap_Name(enum_t_value);
  }
  static inline bool SessionKeymap_Parse(const std::string& name,
      SessionKeymap* value) {
    return Config_SessionKeymap_Parse(name, value);
  }

  typedef Config_PunctuationMethod PunctuationMethod;
  static constexpr PunctuationMethod KUTEN_TOUTEN =
    Config_PunctuationMethod_KUTEN_TOUTEN;
  static constexpr PunctuationMethod COMMA_PERIOD =
    Config_PunctuationMethod_COMMA_PERIOD;
  static constexpr PunctuationMethod KUTEN_PERIOD =
    Config_PunctuationMethod_KUTEN_PERIOD;
  static constexpr PunctuationMethod COMMA_TOUTEN =
    Config_PunctuationMethod_COMMA_TOUTEN;
  static inline bool PunctuationMethod_IsValid(int value) {
    return Config_PunctuationMethod_IsValid(value);
  }
  static constexpr PunctuationMethod PunctuationMethod_MIN =
    Config_PunctuationMethod_PunctuationMethod_MIN;
  static constexpr PunctuationMethod PunctuationMethod_MAX =
    Config_PunctuationMethod_PunctuationMethod_MAX;
  static constexpr int PunctuationMethod_ARRAYSIZE =
    Config_PunctuationMethod_PunctuationMethod_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PunctuationMethod_descriptor() {
    return Config_PunctuationMethod_descriptor();
  }
  template<typename T>
  static inline const std::string& PunctuationMethod_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PunctuationMethod>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PunctuationMethod_Name.");
    return Config_PunctuationMethod_Name(enum_t_value);
  }
  static inline bool PunctuationMethod_Parse(const std::string& name,
      PunctuationMethod* value) {
    return Config_PunctuationMethod_Parse(name, value);
  }

  typedef Config_SymbolMethod SymbolMethod;
  static constexpr SymbolMethod CORNER_BRACKET_MIDDLE_DOT =
    Config_SymbolMethod_CORNER_BRACKET_MIDDLE_DOT;
  static constexpr SymbolMethod SQUARE_BRACKET_SLASH =
    Config_SymbolMethod_SQUARE_BRACKET_SLASH;
  static constexpr SymbolMethod CORNER_BRACKET_SLASH =
    Config_SymbolMethod_CORNER_BRACKET_SLASH;
  static constexpr SymbolMethod SQUARE_BRACKET_MIDDLE_DOT =
    Config_SymbolMethod_SQUARE_BRACKET_MIDDLE_DOT;
  static inline bool SymbolMethod_IsValid(int value) {
    return Config_SymbolMethod_IsValid(value);
  }
  static constexpr SymbolMethod SymbolMethod_MIN =
    Config_SymbolMethod_SymbolMethod_MIN;
  static constexpr SymbolMethod SymbolMethod_MAX =
    Config_SymbolMethod_SymbolMethod_MAX;
  static constexpr int SymbolMethod_ARRAYSIZE =
    Config_SymbolMethod_SymbolMethod_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SymbolMethod_descriptor() {
    return Config_SymbolMethod_descriptor();
  }
  template<typename T>
  static inline const std::string& SymbolMethod_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SymbolMethod>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SymbolMethod_Name.");
    return Config_SymbolMethod_Name(enum_t_value);
  }
  static inline bool SymbolMethod_Parse(const std::string& name,
      SymbolMethod* value) {
    return Config_SymbolMethod_Parse(name, value);
  }

  typedef Config_FundamentalCharacterForm FundamentalCharacterForm;
  static constexpr FundamentalCharacterForm FUNDAMENTAL_INPUT_MODE =
    Config_FundamentalCharacterForm_FUNDAMENTAL_INPUT_MODE;
  static constexpr FundamentalCharacterForm FUNDAMENTAL_FULL_WIDTH =
    Config_FundamentalCharacterForm_FUNDAMENTAL_FULL_WIDTH;
  static constexpr FundamentalCharacterForm FUNDAMENTAL_HALF_WIDTH =
    Config_FundamentalCharacterForm_FUNDAMENTAL_HALF_WIDTH;
  static inline bool FundamentalCharacterForm_IsValid(int value) {
    return Config_FundamentalCharacterForm_IsValid(value);
  }
  static constexpr FundamentalCharacterForm FundamentalCharacterForm_MIN =
    Config_FundamentalCharacterForm_FundamentalCharacterForm_MIN;
  static constexpr FundamentalCharacterForm FundamentalCharacterForm_MAX =
    Config_FundamentalCharacterForm_FundamentalCharacterForm_MAX;
  static constexpr int FundamentalCharacterForm_ARRAYSIZE =
    Config_FundamentalCharacterForm_FundamentalCharacterForm_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FundamentalCharacterForm_descriptor() {
    return Config_FundamentalCharacterForm_descriptor();
  }
  template<typename T>
  static inline const std::string& FundamentalCharacterForm_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FundamentalCharacterForm>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FundamentalCharacterForm_Name.");
    return Config_FundamentalCharacterForm_Name(enum_t_value);
  }
  static inline bool FundamentalCharacterForm_Parse(const std::string& name,
      FundamentalCharacterForm* value) {
    return Config_FundamentalCharacterForm_Parse(name, value);
  }

  typedef Config_HistoryLearningLevel HistoryLearningLevel;
  static constexpr HistoryLearningLevel DEFAULT_HISTORY =
    Config_HistoryLearningLevel_DEFAULT_HISTORY;
  static constexpr HistoryLearningLevel READ_ONLY =
    Config_HistoryLearningLevel_READ_ONLY;
  static constexpr HistoryLearningLevel NO_HISTORY =
    Config_HistoryLearningLevel_NO_HISTORY;
  static inline bool HistoryLearningLevel_IsValid(int value) {
    return Config_HistoryLearningLevel_IsValid(value);
  }
  static constexpr HistoryLearningLevel HistoryLearningLevel_MIN =
    Config_HistoryLearningLevel_HistoryLearningLevel_MIN;
  static constexpr HistoryLearningLevel HistoryLearningLevel_MAX =
    Config_HistoryLearningLevel_HistoryLearningLevel_MAX;
  static constexpr int HistoryLearningLevel_ARRAYSIZE =
    Config_HistoryLearningLevel_HistoryLearningLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HistoryLearningLevel_descriptor() {
    return Config_HistoryLearningLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& HistoryLearningLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HistoryLearningLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HistoryLearningLevel_Name.");
    return Config_HistoryLearningLevel_Name(enum_t_value);
  }
  static inline bool HistoryLearningLevel_Parse(const std::string& name,
      HistoryLearningLevel* value) {
    return Config_HistoryLearningLevel_Parse(name, value);
  }

  typedef Config_SelectionShortcut SelectionShortcut;
  static constexpr SelectionShortcut NO_SHORTCUT =
    Config_SelectionShortcut_NO_SHORTCUT;
  static constexpr SelectionShortcut SHORTCUT_123456789 =
    Config_SelectionShortcut_SHORTCUT_123456789;
  static constexpr SelectionShortcut SHORTCUT_ASDFGHJKL =
    Config_SelectionShortcut_SHORTCUT_ASDFGHJKL;
  static inline bool SelectionShortcut_IsValid(int value) {
    return Config_SelectionShortcut_IsValid(value);
  }
  static constexpr SelectionShortcut SelectionShortcut_MIN =
    Config_SelectionShortcut_SelectionShortcut_MIN;
  static constexpr SelectionShortcut SelectionShortcut_MAX =
    Config_SelectionShortcut_SelectionShortcut_MAX;
  static constexpr int SelectionShortcut_ARRAYSIZE =
    Config_SelectionShortcut_SelectionShortcut_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SelectionShortcut_descriptor() {
    return Config_SelectionShortcut_descriptor();
  }
  template<typename T>
  static inline const std::string& SelectionShortcut_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SelectionShortcut>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SelectionShortcut_Name.");
    return Config_SelectionShortcut_Name(enum_t_value);
  }
  static inline bool SelectionShortcut_Parse(const std::string& name,
      SelectionShortcut* value) {
    return Config_SelectionShortcut_Parse(name, value);
  }

  typedef Config_CharacterForm CharacterForm;
  static constexpr CharacterForm HALF_WIDTH =
    Config_CharacterForm_HALF_WIDTH;
  static constexpr CharacterForm FULL_WIDTH =
    Config_CharacterForm_FULL_WIDTH;
  static constexpr CharacterForm LAST_FORM =
    Config_CharacterForm_LAST_FORM;
  static constexpr CharacterForm NO_CONVERSION =
    Config_CharacterForm_NO_CONVERSION;
  static inline bool CharacterForm_IsValid(int value) {
    return Config_CharacterForm_IsValid(value);
  }
  static constexpr CharacterForm CharacterForm_MIN =
    Config_CharacterForm_CharacterForm_MIN;
  static constexpr CharacterForm CharacterForm_MAX =
    Config_CharacterForm_CharacterForm_MAX;
  static constexpr int CharacterForm_ARRAYSIZE =
    Config_CharacterForm_CharacterForm_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CharacterForm_descriptor() {
    return Config_CharacterForm_descriptor();
  }
  template<typename T>
  static inline const std::string& CharacterForm_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CharacterForm>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CharacterForm_Name.");
    return Config_CharacterForm_Name(enum_t_value);
  }
  static inline bool CharacterForm_Parse(const std::string& name,
      CharacterForm* value) {
    return Config_CharacterForm_Parse(name, value);
  }

  typedef Config_ShiftKeyModeSwitch ShiftKeyModeSwitch;
  static constexpr ShiftKeyModeSwitch OFF =
    Config_ShiftKeyModeSwitch_OFF;
  static constexpr ShiftKeyModeSwitch ASCII_INPUT_MODE =
    Config_ShiftKeyModeSwitch_ASCII_INPUT_MODE;
  static constexpr ShiftKeyModeSwitch KATAKANA_INPUT_MODE =
    Config_ShiftKeyModeSwitch_KATAKANA_INPUT_MODE;
  static inline bool ShiftKeyModeSwitch_IsValid(int value) {
    return Config_ShiftKeyModeSwitch_IsValid(value);
  }
  static constexpr ShiftKeyModeSwitch ShiftKeyModeSwitch_MIN =
    Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MIN;
  static constexpr ShiftKeyModeSwitch ShiftKeyModeSwitch_MAX =
    Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MAX;
  static constexpr int ShiftKeyModeSwitch_ARRAYSIZE =
    Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ShiftKeyModeSwitch_descriptor() {
    return Config_ShiftKeyModeSwitch_descriptor();
  }
  template<typename T>
  static inline const std::string& ShiftKeyModeSwitch_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ShiftKeyModeSwitch>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ShiftKeyModeSwitch_Name.");
    return Config_ShiftKeyModeSwitch_Name(enum_t_value);
  }
  static inline bool ShiftKeyModeSwitch_Parse(const std::string& name,
      ShiftKeyModeSwitch* value) {
    return Config_ShiftKeyModeSwitch_Parse(name, value);
  }

  typedef Config_NumpadCharacterForm NumpadCharacterForm;
  static constexpr NumpadCharacterForm NUMPAD_INPUT_MODE =
    Config_NumpadCharacterForm_NUMPAD_INPUT_MODE;
  static constexpr NumpadCharacterForm NUMPAD_FULL_WIDTH =
    Config_NumpadCharacterForm_NUMPAD_FULL_WIDTH;
  static constexpr NumpadCharacterForm NUMPAD_HALF_WIDTH =
    Config_NumpadCharacterForm_NUMPAD_HALF_WIDTH;
  static constexpr NumpadCharacterForm NUMPAD_DIRECT_INPUT =
    Config_NumpadCharacterForm_NUMPAD_DIRECT_INPUT;
  static inline bool NumpadCharacterForm_IsValid(int value) {
    return Config_NumpadCharacterForm_IsValid(value);
  }
  static constexpr NumpadCharacterForm NumpadCharacterForm_MIN =
    Config_NumpadCharacterForm_NumpadCharacterForm_MIN;
  static constexpr NumpadCharacterForm NumpadCharacterForm_MAX =
    Config_NumpadCharacterForm_NumpadCharacterForm_MAX;
  static constexpr int NumpadCharacterForm_ARRAYSIZE =
    Config_NumpadCharacterForm_NumpadCharacterForm_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NumpadCharacterForm_descriptor() {
    return Config_NumpadCharacterForm_descriptor();
  }
  template<typename T>
  static inline const std::string& NumpadCharacterForm_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NumpadCharacterForm>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NumpadCharacterForm_Name.");
    return Config_NumpadCharacterForm_Name(enum_t_value);
  }
  static inline bool NumpadCharacterForm_Parse(const std::string& name,
      NumpadCharacterForm* value) {
    return Config_NumpadCharacterForm_Parse(name, value);
  }

  typedef Config_AutoConversionKey AutoConversionKey;
  static constexpr AutoConversionKey AUTO_CONVERSION_OFF =
    Config_AutoConversionKey_AUTO_CONVERSION_OFF;
  static constexpr AutoConversionKey AUTO_CONVERSION_KUTEN =
    Config_AutoConversionKey_AUTO_CONVERSION_KUTEN;
  static constexpr AutoConversionKey AUTO_CONVERSION_TOUTEN =
    Config_AutoConversionKey_AUTO_CONVERSION_TOUTEN;
  static constexpr AutoConversionKey AUTO_CONVERSION_QUESTION_MARK =
    Config_AutoConversionKey_AUTO_CONVERSION_QUESTION_MARK;
  static constexpr AutoConversionKey AUTO_CONVERSION_EXCLAMATION_MARK =
    Config_AutoConversionKey_AUTO_CONVERSION_EXCLAMATION_MARK;
  static inline bool AutoConversionKey_IsValid(int value) {
    return Config_AutoConversionKey_IsValid(value);
  }
  static constexpr AutoConversionKey AutoConversionKey_MIN =
    Config_AutoConversionKey_AutoConversionKey_MIN;
  static constexpr AutoConversionKey AutoConversionKey_MAX =
    Config_AutoConversionKey_AutoConversionKey_MAX;
  static constexpr int AutoConversionKey_ARRAYSIZE =
    Config_AutoConversionKey_AutoConversionKey_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AutoConversionKey_descriptor() {
    return Config_AutoConversionKey_descriptor();
  }
  template<typename T>
  static inline const std::string& AutoConversionKey_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AutoConversionKey>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AutoConversionKey_Name.");
    return Config_AutoConversionKey_Name(enum_t_value);
  }
  static inline bool AutoConversionKey_Parse(const std::string& name,
      AutoConversionKey* value) {
    return Config_AutoConversionKey_Parse(name, value);
  }

  typedef Config_YenSignCharacter YenSignCharacter;
  static constexpr YenSignCharacter YEN_SIGN =
    Config_YenSignCharacter_YEN_SIGN;
  static constexpr YenSignCharacter BACKSLASH =
    Config_YenSignCharacter_BACKSLASH;
  static inline bool YenSignCharacter_IsValid(int value) {
    return Config_YenSignCharacter_IsValid(value);
  }
  static constexpr YenSignCharacter YenSignCharacter_MIN =
    Config_YenSignCharacter_YenSignCharacter_MIN;
  static constexpr YenSignCharacter YenSignCharacter_MAX =
    Config_YenSignCharacter_YenSignCharacter_MAX;
  static constexpr int YenSignCharacter_ARRAYSIZE =
    Config_YenSignCharacter_YenSignCharacter_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  YenSignCharacter_descriptor() {
    return Config_YenSignCharacter_descriptor();
  }
  template<typename T>
  static inline const std::string& YenSignCharacter_Name(T enum_t_value) {
    static_assert(::std::is_same<T, YenSignCharacter>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function YenSignCharacter_Name.");
    return Config_YenSignCharacter_Name(enum_t_value);
  }
  static inline bool YenSignCharacter_Parse(const std::string& name,
      YenSignCharacter* value) {
    return Config_YenSignCharacter_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterFormRulesFieldNumber = 54,
    kCustomKeymapTableFieldNumber = 42,
    kCustomRomanTableFieldNumber = 43,
    kGeneralConfigFieldNumber = 1,
    kInformationListConfigFieldNumber = 90,
    kVerboseLevelFieldNumber = 10,
    kIncognitoModeFieldNumber = 20,
    kPresentationModeFieldNumber = 23,
    kUseKeyboardToChangePreeditMethodFieldNumber = 48,
    kUseAutoConversionFieldNumber = 61,
    kPreeditMethodFieldNumber = 40,
    kPunctuationMethodFieldNumber = 45,
    kUseJapaneseLayoutFieldNumber = 64,
    kUseKanaModifierInsensitiveConversionFieldNumber = 65,
    kUseTypingCorrectionFieldNumber = 66,
    kUseEmojiConversionFieldNumber = 89,
    kSymbolMethodFieldNumber = 46,
    kSpaceCharacterFormFieldNumber = 47,
    kHistoryLearningLevelFieldNumber = 50,
    kYenSignCharacterFieldNumber = 63,
    kSessionKeymapFieldNumber = 41,
    kSelectionShortcutFieldNumber = 52,
    kCheckDefaultFieldNumber = 22,
    kUseAutoImeTurnOffFieldNumber = 56,
    kUseCascadingWindowFieldNumber = 58,
    kUseDateConversionFieldNumber = 80,
    kShiftKeyModeSwitchFieldNumber = 59,
    kNumpadCharacterFormFieldNumber = 60,
    kAutoConversionKeyFieldNumber = 62,
    kUseSingleKanjiConversionFieldNumber = 81,
    kUseSymbolConversionFieldNumber = 82,
    kUseNumberConversionFieldNumber = 83,
    kUseEmoticonConversionFieldNumber = 84,
    kUseCalculatorFieldNumber = 85,
    kUseT13NConversionFieldNumber = 86,
    kUseZipCodeConversionFieldNumber = 87,
    kUseSpellingCorrectionFieldNumber = 88,
    kUseHistorySuggestFieldNumber = 100,
    kUseDictionarySuggestFieldNumber = 101,
    kUseRealtimeConversionFieldNumber = 102,
    kUseModeIndicatorFieldNumber = 120,
    kSuggestionsSizeFieldNumber = 110,
  };
  // repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;
  int character_form_rules_size() const;
  private:
  int _internal_character_form_rules_size() const;
  public:
  void clear_character_form_rules();
  ::mozc::config::Config_CharacterFormRule* mutable_character_form_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >*
      mutable_character_form_rules();
  private:
  const ::mozc::config::Config_CharacterFormRule& _internal_character_form_rules(int index) const;
  ::mozc::config::Config_CharacterFormRule* _internal_add_character_form_rules();
  public:
  const ::mozc::config::Config_CharacterFormRule& character_form_rules(int index) const;
  ::mozc::config::Config_CharacterFormRule* add_character_form_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >&
      character_form_rules() const;

  // optional bytes custom_keymap_table = 42;
  bool has_custom_keymap_table() const;
  private:
  bool _internal_has_custom_keymap_table() const;
  public:
  void clear_custom_keymap_table();
  const std::string& custom_keymap_table() const;
  void set_custom_keymap_table(const std::string& value);
  void set_custom_keymap_table(std::string&& value);
  void set_custom_keymap_table(const char* value);
  void set_custom_keymap_table(const void* value, size_t size);
  std::string* mutable_custom_keymap_table();
  std::string* release_custom_keymap_table();
  void set_allocated_custom_keymap_table(std::string* custom_keymap_table);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_custom_keymap_table();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_custom_keymap_table(
      std::string* custom_keymap_table);
  private:
  const std::string& _internal_custom_keymap_table() const;
  void _internal_set_custom_keymap_table(const std::string& value);
  std::string* _internal_mutable_custom_keymap_table();
  public:

  // optional bytes custom_roman_table = 43;
  bool has_custom_roman_table() const;
  private:
  bool _internal_has_custom_roman_table() const;
  public:
  void clear_custom_roman_table();
  const std::string& custom_roman_table() const;
  void set_custom_roman_table(const std::string& value);
  void set_custom_roman_table(std::string&& value);
  void set_custom_roman_table(const char* value);
  void set_custom_roman_table(const void* value, size_t size);
  std::string* mutable_custom_roman_table();
  std::string* release_custom_roman_table();
  void set_allocated_custom_roman_table(std::string* custom_roman_table);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_custom_roman_table();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_custom_roman_table(
      std::string* custom_roman_table);
  private:
  const std::string& _internal_custom_roman_table() const;
  void _internal_set_custom_roman_table(const std::string& value);
  std::string* _internal_mutable_custom_roman_table();
  public:

  // optional .mozc.config.GeneralConfig general_config = 1;
  bool has_general_config() const;
  private:
  bool _internal_has_general_config() const;
  public:
  void clear_general_config();
  const ::mozc::config::GeneralConfig& general_config() const;
  ::mozc::config::GeneralConfig* release_general_config();
  ::mozc::config::GeneralConfig* mutable_general_config();
  void set_allocated_general_config(::mozc::config::GeneralConfig* general_config);
  private:
  const ::mozc::config::GeneralConfig& _internal_general_config() const;
  ::mozc::config::GeneralConfig* _internal_mutable_general_config();
  public:
  void unsafe_arena_set_allocated_general_config(
      ::mozc::config::GeneralConfig* general_config);
  ::mozc::config::GeneralConfig* unsafe_arena_release_general_config();

  // optional .mozc.config.Config.InformationListConfig information_list_config = 90;
  bool has_information_list_config() const;
  private:
  bool _internal_has_information_list_config() const;
  public:
  void clear_information_list_config();
  const ::mozc::config::Config_InformationListConfig& information_list_config() const;
  ::mozc::config::Config_InformationListConfig* release_information_list_config();
  ::mozc::config::Config_InformationListConfig* mutable_information_list_config();
  void set_allocated_information_list_config(::mozc::config::Config_InformationListConfig* information_list_config);
  private:
  const ::mozc::config::Config_InformationListConfig& _internal_information_list_config() const;
  ::mozc::config::Config_InformationListConfig* _internal_mutable_information_list_config();
  public:
  void unsafe_arena_set_allocated_information_list_config(
      ::mozc::config::Config_InformationListConfig* information_list_config);
  ::mozc::config::Config_InformationListConfig* unsafe_arena_release_information_list_config();

  // optional int32 verbose_level = 10 [default = 0];
  bool has_verbose_level() const;
  private:
  bool _internal_has_verbose_level() const;
  public:
  void clear_verbose_level();
  ::PROTOBUF_NAMESPACE_ID::int32 verbose_level() const;
  void set_verbose_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_verbose_level() const;
  void _internal_set_verbose_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool incognito_mode = 20 [default = false];
  bool has_incognito_mode() const;
  private:
  bool _internal_has_incognito_mode() const;
  public:
  void clear_incognito_mode();
  bool incognito_mode() const;
  void set_incognito_mode(bool value);
  private:
  bool _internal_incognito_mode() const;
  void _internal_set_incognito_mode(bool value);
  public:

  // optional bool presentation_mode = 23 [default = false];
  bool has_presentation_mode() const;
  private:
  bool _internal_has_presentation_mode() const;
  public:
  void clear_presentation_mode();
  bool presentation_mode() const;
  void set_presentation_mode(bool value);
  private:
  bool _internal_presentation_mode() const;
  void _internal_set_presentation_mode(bool value);
  public:

  // optional bool use_keyboard_to_change_preedit_method = 48 [default = false];
  bool has_use_keyboard_to_change_preedit_method() const;
  private:
  bool _internal_has_use_keyboard_to_change_preedit_method() const;
  public:
  void clear_use_keyboard_to_change_preedit_method();
  bool use_keyboard_to_change_preedit_method() const;
  void set_use_keyboard_to_change_preedit_method(bool value);
  private:
  bool _internal_use_keyboard_to_change_preedit_method() const;
  void _internal_set_use_keyboard_to_change_preedit_method(bool value);
  public:

  // optional bool use_auto_conversion = 61 [default = false];
  bool has_use_auto_conversion() const;
  private:
  bool _internal_has_use_auto_conversion() const;
  public:
  void clear_use_auto_conversion();
  bool use_auto_conversion() const;
  void set_use_auto_conversion(bool value);
  private:
  bool _internal_use_auto_conversion() const;
  void _internal_set_use_auto_conversion(bool value);
  public:

  // optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];
  bool has_preedit_method() const;
  private:
  bool _internal_has_preedit_method() const;
  public:
  void clear_preedit_method();
  ::mozc::config::Config_PreeditMethod preedit_method() const;
  void set_preedit_method(::mozc::config::Config_PreeditMethod value);
  private:
  ::mozc::config::Config_PreeditMethod _internal_preedit_method() const;
  void _internal_set_preedit_method(::mozc::config::Config_PreeditMethod value);
  public:

  // optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];
  bool has_punctuation_method() const;
  private:
  bool _internal_has_punctuation_method() const;
  public:
  void clear_punctuation_method();
  ::mozc::config::Config_PunctuationMethod punctuation_method() const;
  void set_punctuation_method(::mozc::config::Config_PunctuationMethod value);
  private:
  ::mozc::config::Config_PunctuationMethod _internal_punctuation_method() const;
  void _internal_set_punctuation_method(::mozc::config::Config_PunctuationMethod value);
  public:

  // optional bool use_japanese_layout = 64 [default = false];
  bool has_use_japanese_layout() const;
  private:
  bool _internal_has_use_japanese_layout() const;
  public:
  void clear_use_japanese_layout();
  bool use_japanese_layout() const;
  void set_use_japanese_layout(bool value);
  private:
  bool _internal_use_japanese_layout() const;
  void _internal_set_use_japanese_layout(bool value);
  public:

  // optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];
  bool has_use_kana_modifier_insensitive_conversion() const;
  private:
  bool _internal_has_use_kana_modifier_insensitive_conversion() const;
  public:
  void clear_use_kana_modifier_insensitive_conversion();
  bool use_kana_modifier_insensitive_conversion() const;
  void set_use_kana_modifier_insensitive_conversion(bool value);
  private:
  bool _internal_use_kana_modifier_insensitive_conversion() const;
  void _internal_set_use_kana_modifier_insensitive_conversion(bool value);
  public:

  // optional bool use_typing_correction = 66 [default = false];
  bool has_use_typing_correction() const;
  private:
  bool _internal_has_use_typing_correction() const;
  public:
  void clear_use_typing_correction();
  bool use_typing_correction() const;
  void set_use_typing_correction(bool value);
  private:
  bool _internal_use_typing_correction() const;
  void _internal_set_use_typing_correction(bool value);
  public:

  // optional bool use_emoji_conversion = 89 [default = false];
  bool has_use_emoji_conversion() const;
  private:
  bool _internal_has_use_emoji_conversion() const;
  public:
  void clear_use_emoji_conversion();
  bool use_emoji_conversion() const;
  void set_use_emoji_conversion(bool value);
  private:
  bool _internal_use_emoji_conversion() const;
  void _internal_set_use_emoji_conversion(bool value);
  public:

  // optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];
  bool has_symbol_method() const;
  private:
  bool _internal_has_symbol_method() const;
  public:
  void clear_symbol_method();
  ::mozc::config::Config_SymbolMethod symbol_method() const;
  void set_symbol_method(::mozc::config::Config_SymbolMethod value);
  private:
  ::mozc::config::Config_SymbolMethod _internal_symbol_method() const;
  void _internal_set_symbol_method(::mozc::config::Config_SymbolMethod value);
  public:

  // optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];
  bool has_space_character_form() const;
  private:
  bool _internal_has_space_character_form() const;
  public:
  void clear_space_character_form();
  ::mozc::config::Config_FundamentalCharacterForm space_character_form() const;
  void set_space_character_form(::mozc::config::Config_FundamentalCharacterForm value);
  private:
  ::mozc::config::Config_FundamentalCharacterForm _internal_space_character_form() const;
  void _internal_set_space_character_form(::mozc::config::Config_FundamentalCharacterForm value);
  public:

  // optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];
  bool has_history_learning_level() const;
  private:
  bool _internal_has_history_learning_level() const;
  public:
  void clear_history_learning_level();
  ::mozc::config::Config_HistoryLearningLevel history_learning_level() const;
  void set_history_learning_level(::mozc::config::Config_HistoryLearningLevel value);
  private:
  ::mozc::config::Config_HistoryLearningLevel _internal_history_learning_level() const;
  void _internal_set_history_learning_level(::mozc::config::Config_HistoryLearningLevel value);
  public:

  // optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];
  bool has_yen_sign_character() const;
  private:
  bool _internal_has_yen_sign_character() const;
  public:
  void clear_yen_sign_character();
  ::mozc::config::Config_YenSignCharacter yen_sign_character() const;
  void set_yen_sign_character(::mozc::config::Config_YenSignCharacter value);
  private:
  ::mozc::config::Config_YenSignCharacter _internal_yen_sign_character() const;
  void _internal_set_yen_sign_character(::mozc::config::Config_YenSignCharacter value);
  public:

  // optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];
  bool has_session_keymap() const;
  private:
  bool _internal_has_session_keymap() const;
  public:
  void clear_session_keymap();
  ::mozc::config::Config_SessionKeymap session_keymap() const;
  void set_session_keymap(::mozc::config::Config_SessionKeymap value);
  private:
  ::mozc::config::Config_SessionKeymap _internal_session_keymap() const;
  void _internal_set_session_keymap(::mozc::config::Config_SessionKeymap value);
  public:

  // optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];
  bool has_selection_shortcut() const;
  private:
  bool _internal_has_selection_shortcut() const;
  public:
  void clear_selection_shortcut();
  ::mozc::config::Config_SelectionShortcut selection_shortcut() const;
  void set_selection_shortcut(::mozc::config::Config_SelectionShortcut value);
  private:
  ::mozc::config::Config_SelectionShortcut _internal_selection_shortcut() const;
  void _internal_set_selection_shortcut(::mozc::config::Config_SelectionShortcut value);
  public:

  // optional bool check_default = 22 [default = true];
  bool has_check_default() const;
  private:
  bool _internal_has_check_default() const;
  public:
  void clear_check_default();
  bool check_default() const;
  void set_check_default(bool value);
  private:
  bool _internal_check_default() const;
  void _internal_set_check_default(bool value);
  public:

  // optional bool use_auto_ime_turn_off = 56 [default = true];
  bool has_use_auto_ime_turn_off() const;
  private:
  bool _internal_has_use_auto_ime_turn_off() const;
  public:
  void clear_use_auto_ime_turn_off();
  bool use_auto_ime_turn_off() const;
  void set_use_auto_ime_turn_off(bool value);
  private:
  bool _internal_use_auto_ime_turn_off() const;
  void _internal_set_use_auto_ime_turn_off(bool value);
  public:

  // optional bool use_cascading_window = 58 [default = true];
  bool has_use_cascading_window() const;
  private:
  bool _internal_has_use_cascading_window() const;
  public:
  void clear_use_cascading_window();
  bool use_cascading_window() const;
  void set_use_cascading_window(bool value);
  private:
  bool _internal_use_cascading_window() const;
  void _internal_set_use_cascading_window(bool value);
  public:

  // optional bool use_date_conversion = 80 [default = true];
  bool has_use_date_conversion() const;
  private:
  bool _internal_has_use_date_conversion() const;
  public:
  void clear_use_date_conversion();
  bool use_date_conversion() const;
  void set_use_date_conversion(bool value);
  private:
  bool _internal_use_date_conversion() const;
  void _internal_set_use_date_conversion(bool value);
  public:

  // optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];
  bool has_shift_key_mode_switch() const;
  private:
  bool _internal_has_shift_key_mode_switch() const;
  public:
  void clear_shift_key_mode_switch();
  ::mozc::config::Config_ShiftKeyModeSwitch shift_key_mode_switch() const;
  void set_shift_key_mode_switch(::mozc::config::Config_ShiftKeyModeSwitch value);
  private:
  ::mozc::config::Config_ShiftKeyModeSwitch _internal_shift_key_mode_switch() const;
  void _internal_set_shift_key_mode_switch(::mozc::config::Config_ShiftKeyModeSwitch value);
  public:

  // optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];
  bool has_numpad_character_form() const;
  private:
  bool _internal_has_numpad_character_form() const;
  public:
  void clear_numpad_character_form();
  ::mozc::config::Config_NumpadCharacterForm numpad_character_form() const;
  void set_numpad_character_form(::mozc::config::Config_NumpadCharacterForm value);
  private:
  ::mozc::config::Config_NumpadCharacterForm _internal_numpad_character_form() const;
  void _internal_set_numpad_character_form(::mozc::config::Config_NumpadCharacterForm value);
  public:

  // optional uint32 auto_conversion_key = 62 [default = 13];
  bool has_auto_conversion_key() const;
  private:
  bool _internal_has_auto_conversion_key() const;
  public:
  void clear_auto_conversion_key();
  ::PROTOBUF_NAMESPACE_ID::uint32 auto_conversion_key() const;
  void set_auto_conversion_key(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_auto_conversion_key() const;
  void _internal_set_auto_conversion_key(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool use_single_kanji_conversion = 81 [default = true];
  bool has_use_single_kanji_conversion() const;
  private:
  bool _internal_has_use_single_kanji_conversion() const;
  public:
  void clear_use_single_kanji_conversion();
  bool use_single_kanji_conversion() const;
  void set_use_single_kanji_conversion(bool value);
  private:
  bool _internal_use_single_kanji_conversion() const;
  void _internal_set_use_single_kanji_conversion(bool value);
  public:

  // optional bool use_symbol_conversion = 82 [default = true];
  bool has_use_symbol_conversion() const;
  private:
  bool _internal_has_use_symbol_conversion() const;
  public:
  void clear_use_symbol_conversion();
  bool use_symbol_conversion() const;
  void set_use_symbol_conversion(bool value);
  private:
  bool _internal_use_symbol_conversion() const;
  void _internal_set_use_symbol_conversion(bool value);
  public:

  // optional bool use_number_conversion = 83 [default = true];
  bool has_use_number_conversion() const;
  private:
  bool _internal_has_use_number_conversion() const;
  public:
  void clear_use_number_conversion();
  bool use_number_conversion() const;
  void set_use_number_conversion(bool value);
  private:
  bool _internal_use_number_conversion() const;
  void _internal_set_use_number_conversion(bool value);
  public:

  // optional bool use_emoticon_conversion = 84 [default = true];
  bool has_use_emoticon_conversion() const;
  private:
  bool _internal_has_use_emoticon_conversion() const;
  public:
  void clear_use_emoticon_conversion();
  bool use_emoticon_conversion() const;
  void set_use_emoticon_conversion(bool value);
  private:
  bool _internal_use_emoticon_conversion() const;
  void _internal_set_use_emoticon_conversion(bool value);
  public:

  // optional bool use_calculator = 85 [default = true];
  bool has_use_calculator() const;
  private:
  bool _internal_has_use_calculator() const;
  public:
  void clear_use_calculator();
  bool use_calculator() const;
  void set_use_calculator(bool value);
  private:
  bool _internal_use_calculator() const;
  void _internal_set_use_calculator(bool value);
  public:

  // optional bool use_t13n_conversion = 86 [default = true];
  bool has_use_t13n_conversion() const;
  private:
  bool _internal_has_use_t13n_conversion() const;
  public:
  void clear_use_t13n_conversion();
  bool use_t13n_conversion() const;
  void set_use_t13n_conversion(bool value);
  private:
  bool _internal_use_t13n_conversion() const;
  void _internal_set_use_t13n_conversion(bool value);
  public:

  // optional bool use_zip_code_conversion = 87 [default = true];
  bool has_use_zip_code_conversion() const;
  private:
  bool _internal_has_use_zip_code_conversion() const;
  public:
  void clear_use_zip_code_conversion();
  bool use_zip_code_conversion() const;
  void set_use_zip_code_conversion(bool value);
  private:
  bool _internal_use_zip_code_conversion() const;
  void _internal_set_use_zip_code_conversion(bool value);
  public:

  // optional bool use_spelling_correction = 88 [default = true];
  bool has_use_spelling_correction() const;
  private:
  bool _internal_has_use_spelling_correction() const;
  public:
  void clear_use_spelling_correction();
  bool use_spelling_correction() const;
  void set_use_spelling_correction(bool value);
  private:
  bool _internal_use_spelling_correction() const;
  void _internal_set_use_spelling_correction(bool value);
  public:

  // optional bool use_history_suggest = 100 [default = true];
  bool has_use_history_suggest() const;
  private:
  bool _internal_has_use_history_suggest() const;
  public:
  void clear_use_history_suggest();
  bool use_history_suggest() const;
  void set_use_history_suggest(bool value);
  private:
  bool _internal_use_history_suggest() const;
  void _internal_set_use_history_suggest(bool value);
  public:

  // optional bool use_dictionary_suggest = 101 [default = true];
  bool has_use_dictionary_suggest() const;
  private:
  bool _internal_has_use_dictionary_suggest() const;
  public:
  void clear_use_dictionary_suggest();
  bool use_dictionary_suggest() const;
  void set_use_dictionary_suggest(bool value);
  private:
  bool _internal_use_dictionary_suggest() const;
  void _internal_set_use_dictionary_suggest(bool value);
  public:

  // optional bool use_realtime_conversion = 102 [default = true];
  bool has_use_realtime_conversion() const;
  private:
  bool _internal_has_use_realtime_conversion() const;
  public:
  void clear_use_realtime_conversion();
  bool use_realtime_conversion() const;
  void set_use_realtime_conversion(bool value);
  private:
  bool _internal_use_realtime_conversion() const;
  void _internal_set_use_realtime_conversion(bool value);
  public:

  // optional bool use_mode_indicator = 120 [default = true];
  bool has_use_mode_indicator() const;
  private:
  bool _internal_has_use_mode_indicator() const;
  public:
  void clear_use_mode_indicator();
  bool use_mode_indicator() const;
  void set_use_mode_indicator(bool value);
  private:
  bool _internal_use_mode_indicator() const;
  void _internal_set_use_mode_indicator(bool value);
  public:

  // optional uint32 suggestions_size = 110 [default = 3];
  bool has_suggestions_size() const;
  private:
  bool _internal_has_suggestions_size() const;
  public:
  void clear_suggestions_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 suggestions_size() const;
  void set_suggestions_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_suggestions_size() const;
  void _internal_set_suggestions_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.config.Config)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule > character_form_rules_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_keymap_table_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_roman_table_;
  ::mozc::config::GeneralConfig* general_config_;
  ::mozc::config::Config_InformationListConfig* information_list_config_;
  ::PROTOBUF_NAMESPACE_ID::int32 verbose_level_;
  bool incognito_mode_;
  bool presentation_mode_;
  bool use_keyboard_to_change_preedit_method_;
  bool use_auto_conversion_;
  int preedit_method_;
  int punctuation_method_;
  bool use_japanese_layout_;
  bool use_kana_modifier_insensitive_conversion_;
  bool use_typing_correction_;
  bool use_emoji_conversion_;
  int symbol_method_;
  int space_character_form_;
  int history_learning_level_;
  int yen_sign_character_;
  int session_keymap_;
  int selection_shortcut_;
  bool check_default_;
  bool use_auto_ime_turn_off_;
  bool use_cascading_window_;
  bool use_date_conversion_;
  int shift_key_mode_switch_;
  int numpad_character_form_;
  ::PROTOBUF_NAMESPACE_ID::uint32 auto_conversion_key_;
  bool use_single_kanji_conversion_;
  bool use_symbol_conversion_;
  bool use_number_conversion_;
  bool use_emoticon_conversion_;
  bool use_calculator_;
  bool use_t13n_conversion_;
  bool use_zip_code_conversion_;
  bool use_spelling_correction_;
  bool use_history_suggest_;
  bool use_dictionary_suggest_;
  bool use_realtime_conversion_;
  bool use_mode_indicator_;
  ::PROTOBUF_NAMESPACE_ID::uint32 suggestions_size_;
  friend struct ::TableStruct_protocol_2fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GeneralConfig

// optional uint32 config_version = 1 [default = 0];
inline bool GeneralConfig::_internal_has_config_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GeneralConfig::has_config_version() const {
  return _internal_has_config_version();
}
inline void GeneralConfig::clear_config_version() {
  config_version_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GeneralConfig::_internal_config_version() const {
  return config_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GeneralConfig::config_version() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.config_version)
  return _internal_config_version();
}
inline void GeneralConfig::_internal_set_config_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  config_version_ = value;
}
inline void GeneralConfig::set_config_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_config_version(value);
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.config_version)
}

// optional string last_modified_product_version = 2 [default = "0.0.0.0"];
inline bool GeneralConfig::_internal_has_last_modified_product_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GeneralConfig::has_last_modified_product_version() const {
  return _internal_has_last_modified_product_version();
}
inline void GeneralConfig::clear_last_modified_product_version() {
  last_modified_product_version_.ClearToDefault(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GeneralConfig::last_modified_product_version() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.last_modified_product_version)
  return _internal_last_modified_product_version();
}
inline void GeneralConfig::set_last_modified_product_version(const std::string& value) {
  _internal_set_last_modified_product_version(value);
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.last_modified_product_version)
}
inline std::string* GeneralConfig::mutable_last_modified_product_version() {
  // @@protoc_insertion_point(field_mutable:mozc.config.GeneralConfig.last_modified_product_version)
  return _internal_mutable_last_modified_product_version();
}
inline const std::string& GeneralConfig::_internal_last_modified_product_version() const {
  return last_modified_product_version_.Get();
}
inline void GeneralConfig::_internal_set_last_modified_product_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  last_modified_product_version_.Set(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), value, GetArena());
}
inline void GeneralConfig::set_last_modified_product_version(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  last_modified_product_version_.Set(
    &::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.GeneralConfig.last_modified_product_version)
}
inline void GeneralConfig::set_last_modified_product_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  last_modified_product_version_.Set(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.config.GeneralConfig.last_modified_product_version)
}
inline void GeneralConfig::set_last_modified_product_version(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  last_modified_product_version_.Set(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.config.GeneralConfig.last_modified_product_version)
}
inline std::string* GeneralConfig::_internal_mutable_last_modified_product_version() {
  _has_bits_[0] |= 0x00000001u;
  return last_modified_product_version_.Mutable(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), GetArena());
}
inline std::string* GeneralConfig::release_last_modified_product_version() {
  // @@protoc_insertion_point(field_release:mozc.config.GeneralConfig.last_modified_product_version)
  if (!_internal_has_last_modified_product_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return last_modified_product_version_.ReleaseNonDefault(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), GetArena());
}
inline void GeneralConfig::set_allocated_last_modified_product_version(std::string* last_modified_product_version) {
  if (last_modified_product_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  last_modified_product_version_.SetAllocated(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), last_modified_product_version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.config.GeneralConfig.last_modified_product_version)
}
inline std::string* GeneralConfig::unsafe_arena_release_last_modified_product_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.config.GeneralConfig.last_modified_product_version)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return last_modified_product_version_.UnsafeArenaRelease(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(),
      GetArena());
}
inline void GeneralConfig::unsafe_arena_set_allocated_last_modified_product_version(
    std::string* last_modified_product_version) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (last_modified_product_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  last_modified_product_version_.UnsafeArenaSetAllocated(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(),
      last_modified_product_version, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.config.GeneralConfig.last_modified_product_version)
}

// optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];
inline bool GeneralConfig::_internal_has_last_modified_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GeneralConfig::has_last_modified_time() const {
  return _internal_has_last_modified_time();
}
inline void GeneralConfig::clear_last_modified_time() {
  last_modified_time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GeneralConfig::_internal_last_modified_time() const {
  return last_modified_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GeneralConfig::last_modified_time() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.last_modified_time)
  return _internal_last_modified_time();
}
inline void GeneralConfig::_internal_set_last_modified_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  last_modified_time_ = value;
}
inline void GeneralConfig::set_last_modified_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_modified_time(value);
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.last_modified_time)
}

// optional string platform = 4 [default = ""];
inline bool GeneralConfig::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GeneralConfig::has_platform() const {
  return _internal_has_platform();
}
inline void GeneralConfig::clear_platform() {
  platform_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GeneralConfig::platform() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.platform)
  return _internal_platform();
}
inline void GeneralConfig::set_platform(const std::string& value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.platform)
}
inline std::string* GeneralConfig::mutable_platform() {
  // @@protoc_insertion_point(field_mutable:mozc.config.GeneralConfig.platform)
  return _internal_mutable_platform();
}
inline const std::string& GeneralConfig::_internal_platform() const {
  return platform_.Get();
}
inline void GeneralConfig::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GeneralConfig::set_platform(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  platform_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.GeneralConfig.platform)
}
inline void GeneralConfig::set_platform(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.config.GeneralConfig.platform)
}
inline void GeneralConfig::set_platform(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.config.GeneralConfig.platform)
}
inline std::string* GeneralConfig::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00000002u;
  return platform_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GeneralConfig::release_platform() {
  // @@protoc_insertion_point(field_release:mozc.config.GeneralConfig.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return platform_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GeneralConfig::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.config.GeneralConfig.platform)
}
inline std::string* GeneralConfig::unsafe_arena_release_platform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.config.GeneralConfig.platform)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return platform_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GeneralConfig::unsafe_arena_set_allocated_platform(
    std::string* platform) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  platform_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      platform, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.config.GeneralConfig.platform)
}

// optional string ui_locale = 5 [default = ""];
inline bool GeneralConfig::_internal_has_ui_locale() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GeneralConfig::has_ui_locale() const {
  return _internal_has_ui_locale();
}
inline void GeneralConfig::clear_ui_locale() {
  ui_locale_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GeneralConfig::ui_locale() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.ui_locale)
  return _internal_ui_locale();
}
inline void GeneralConfig::set_ui_locale(const std::string& value) {
  _internal_set_ui_locale(value);
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.ui_locale)
}
inline std::string* GeneralConfig::mutable_ui_locale() {
  // @@protoc_insertion_point(field_mutable:mozc.config.GeneralConfig.ui_locale)
  return _internal_mutable_ui_locale();
}
inline const std::string& GeneralConfig::_internal_ui_locale() const {
  return ui_locale_.Get();
}
inline void GeneralConfig::_internal_set_ui_locale(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  ui_locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GeneralConfig::set_ui_locale(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  ui_locale_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.GeneralConfig.ui_locale)
}
inline void GeneralConfig::set_ui_locale(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  ui_locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.config.GeneralConfig.ui_locale)
}
inline void GeneralConfig::set_ui_locale(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  ui_locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.config.GeneralConfig.ui_locale)
}
inline std::string* GeneralConfig::_internal_mutable_ui_locale() {
  _has_bits_[0] |= 0x00000004u;
  return ui_locale_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GeneralConfig::release_ui_locale() {
  // @@protoc_insertion_point(field_release:mozc.config.GeneralConfig.ui_locale)
  if (!_internal_has_ui_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return ui_locale_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GeneralConfig::set_allocated_ui_locale(std::string* ui_locale) {
  if (ui_locale != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ui_locale_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ui_locale,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.config.GeneralConfig.ui_locale)
}
inline std::string* GeneralConfig::unsafe_arena_release_ui_locale() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.config.GeneralConfig.ui_locale)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return ui_locale_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GeneralConfig::unsafe_arena_set_allocated_ui_locale(
    std::string* ui_locale) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ui_locale != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ui_locale_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ui_locale, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.config.GeneralConfig.ui_locale)
}

// optional bool upload_usage_stats = 6 [default = false];
inline bool GeneralConfig::_internal_has_upload_usage_stats() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GeneralConfig::has_upload_usage_stats() const {
  return _internal_has_upload_usage_stats();
}
inline void GeneralConfig::clear_upload_usage_stats() {
  upload_usage_stats_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool GeneralConfig::_internal_upload_usage_stats() const {
  return upload_usage_stats_;
}
inline bool GeneralConfig::upload_usage_stats() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.upload_usage_stats)
  return _internal_upload_usage_stats();
}
inline void GeneralConfig::_internal_set_upload_usage_stats(bool value) {
  _has_bits_[0] |= 0x00000020u;
  upload_usage_stats_ = value;
}
inline void GeneralConfig::set_upload_usage_stats(bool value) {
  _internal_set_upload_usage_stats(value);
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.upload_usage_stats)
}

// -------------------------------------------------------------------

// Config_CharacterFormRule

// optional string group = 1;
inline bool Config_CharacterFormRule::_internal_has_group() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Config_CharacterFormRule::has_group() const {
  return _internal_has_group();
}
inline void Config_CharacterFormRule::clear_group() {
  group_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Config_CharacterFormRule::group() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.CharacterFormRule.group)
  return _internal_group();
}
inline void Config_CharacterFormRule::set_group(const std::string& value) {
  _internal_set_group(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.CharacterFormRule.group)
}
inline std::string* Config_CharacterFormRule::mutable_group() {
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.CharacterFormRule.group)
  return _internal_mutable_group();
}
inline const std::string& Config_CharacterFormRule::_internal_group() const {
  return group_.Get();
}
inline void Config_CharacterFormRule::_internal_set_group(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Config_CharacterFormRule::set_group(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  group_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.Config.CharacterFormRule.group)
}
inline void Config_CharacterFormRule::set_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.config.Config.CharacterFormRule.group)
}
inline void Config_CharacterFormRule::set_group(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.config.Config.CharacterFormRule.group)
}
inline std::string* Config_CharacterFormRule::_internal_mutable_group() {
  _has_bits_[0] |= 0x00000001u;
  return group_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Config_CharacterFormRule::release_group() {
  // @@protoc_insertion_point(field_release:mozc.config.Config.CharacterFormRule.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return group_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Config_CharacterFormRule::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  group_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.config.Config.CharacterFormRule.group)
}
inline std::string* Config_CharacterFormRule::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.config.Config.CharacterFormRule.group)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return group_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Config_CharacterFormRule::unsafe_arena_set_allocated_group(
    std::string* group) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (group != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  group_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      group, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.config.Config.CharacterFormRule.group)
}

// optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];
inline bool Config_CharacterFormRule::_internal_has_preedit_character_form() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Config_CharacterFormRule::has_preedit_character_form() const {
  return _internal_has_preedit_character_form();
}
inline void Config_CharacterFormRule::clear_preedit_character_form() {
  preedit_character_form_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::mozc::config::Config_CharacterForm Config_CharacterFormRule::_internal_preedit_character_form() const {
  return static_cast< ::mozc::config::Config_CharacterForm >(preedit_character_form_);
}
inline ::mozc::config::Config_CharacterForm Config_CharacterFormRule::preedit_character_form() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.CharacterFormRule.preedit_character_form)
  return _internal_preedit_character_form();
}
inline void Config_CharacterFormRule::_internal_set_preedit_character_form(::mozc::config::Config_CharacterForm value) {
  assert(::mozc::config::Config_CharacterForm_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  preedit_character_form_ = value;
}
inline void Config_CharacterFormRule::set_preedit_character_form(::mozc::config::Config_CharacterForm value) {
  _internal_set_preedit_character_form(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.CharacterFormRule.preedit_character_form)
}

// optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];
inline bool Config_CharacterFormRule::_internal_has_conversion_character_form() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Config_CharacterFormRule::has_conversion_character_form() const {
  return _internal_has_conversion_character_form();
}
inline void Config_CharacterFormRule::clear_conversion_character_form() {
  conversion_character_form_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::mozc::config::Config_CharacterForm Config_CharacterFormRule::_internal_conversion_character_form() const {
  return static_cast< ::mozc::config::Config_CharacterForm >(conversion_character_form_);
}
inline ::mozc::config::Config_CharacterForm Config_CharacterFormRule::conversion_character_form() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.CharacterFormRule.conversion_character_form)
  return _internal_conversion_character_form();
}
inline void Config_CharacterFormRule::_internal_set_conversion_character_form(::mozc::config::Config_CharacterForm value) {
  assert(::mozc::config::Config_CharacterForm_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  conversion_character_form_ = value;
}
inline void Config_CharacterFormRule::set_conversion_character_form(::mozc::config::Config_CharacterForm value) {
  _internal_set_conversion_character_form(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.CharacterFormRule.conversion_character_form)
}

// -------------------------------------------------------------------

// Config_InformationListConfig

// optional bool use_local_usage_dictionary = 1 [default = true];
inline bool Config_InformationListConfig::_internal_has_use_local_usage_dictionary() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Config_InformationListConfig::has_use_local_usage_dictionary() const {
  return _internal_has_use_local_usage_dictionary();
}
inline void Config_InformationListConfig::clear_use_local_usage_dictionary() {
  use_local_usage_dictionary_ = true;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool Config_InformationListConfig::_internal_use_local_usage_dictionary() const {
  return use_local_usage_dictionary_;
}
inline bool Config_InformationListConfig::use_local_usage_dictionary() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.InformationListConfig.use_local_usage_dictionary)
  return _internal_use_local_usage_dictionary();
}
inline void Config_InformationListConfig::_internal_set_use_local_usage_dictionary(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_local_usage_dictionary_ = value;
}
inline void Config_InformationListConfig::set_use_local_usage_dictionary(bool value) {
  _internal_set_use_local_usage_dictionary(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.InformationListConfig.use_local_usage_dictionary)
}

// -------------------------------------------------------------------

// Config

// optional .mozc.config.GeneralConfig general_config = 1;
inline bool Config::_internal_has_general_config() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || general_config_ != nullptr);
  return value;
}
inline bool Config::has_general_config() const {
  return _internal_has_general_config();
}
inline void Config::clear_general_config() {
  if (general_config_ != nullptr) general_config_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mozc::config::GeneralConfig& Config::_internal_general_config() const {
  const ::mozc::config::GeneralConfig* p = general_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::config::GeneralConfig*>(
      &::mozc::config::_GeneralConfig_default_instance_);
}
inline const ::mozc::config::GeneralConfig& Config::general_config() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.general_config)
  return _internal_general_config();
}
inline void Config::unsafe_arena_set_allocated_general_config(
    ::mozc::config::GeneralConfig* general_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(general_config_);
  }
  general_config_ = general_config;
  if (general_config) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.config.Config.general_config)
}
inline ::mozc::config::GeneralConfig* Config::release_general_config() {
  auto temp = unsafe_arena_release_general_config();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::config::GeneralConfig* Config::unsafe_arena_release_general_config() {
  // @@protoc_insertion_point(field_release:mozc.config.Config.general_config)
  _has_bits_[0] &= ~0x00000004u;
  ::mozc::config::GeneralConfig* temp = general_config_;
  general_config_ = nullptr;
  return temp;
}
inline ::mozc::config::GeneralConfig* Config::_internal_mutable_general_config() {
  _has_bits_[0] |= 0x00000004u;
  if (general_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::config::GeneralConfig>(GetArena());
    general_config_ = p;
  }
  return general_config_;
}
inline ::mozc::config::GeneralConfig* Config::mutable_general_config() {
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.general_config)
  return _internal_mutable_general_config();
}
inline void Config::set_allocated_general_config(::mozc::config::GeneralConfig* general_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete general_config_;
  }
  if (general_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(general_config);
    if (message_arena != submessage_arena) {
      general_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, general_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  general_config_ = general_config;
  // @@protoc_insertion_point(field_set_allocated:mozc.config.Config.general_config)
}

// optional int32 verbose_level = 10 [default = 0];
inline bool Config::_internal_has_verbose_level() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Config::has_verbose_level() const {
  return _internal_has_verbose_level();
}
inline void Config::clear_verbose_level() {
  verbose_level_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Config::_internal_verbose_level() const {
  return verbose_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Config::verbose_level() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.verbose_level)
  return _internal_verbose_level();
}
inline void Config::_internal_set_verbose_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  verbose_level_ = value;
}
inline void Config::set_verbose_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_verbose_level(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.verbose_level)
}

// optional bool incognito_mode = 20 [default = false];
inline bool Config::_internal_has_incognito_mode() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Config::has_incognito_mode() const {
  return _internal_has_incognito_mode();
}
inline void Config::clear_incognito_mode() {
  incognito_mode_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Config::_internal_incognito_mode() const {
  return incognito_mode_;
}
inline bool Config::incognito_mode() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.incognito_mode)
  return _internal_incognito_mode();
}
inline void Config::_internal_set_incognito_mode(bool value) {
  _has_bits_[0] |= 0x00000020u;
  incognito_mode_ = value;
}
inline void Config::set_incognito_mode(bool value) {
  _internal_set_incognito_mode(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.incognito_mode)
}

// optional bool check_default = 22 [default = true];
inline bool Config::_internal_has_check_default() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Config::has_check_default() const {
  return _internal_has_check_default();
}
inline void Config::clear_check_default() {
  check_default_ = true;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool Config::_internal_check_default() const {
  return check_default_;
}
inline bool Config::check_default() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.check_default)
  return _internal_check_default();
}
inline void Config::_internal_set_check_default(bool value) {
  _has_bits_[0] |= 0x00200000u;
  check_default_ = value;
}
inline void Config::set_check_default(bool value) {
  _internal_set_check_default(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.check_default)
}

// optional bool presentation_mode = 23 [default = false];
inline bool Config::_internal_has_presentation_mode() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Config::has_presentation_mode() const {
  return _internal_has_presentation_mode();
}
inline void Config::clear_presentation_mode() {
  presentation_mode_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Config::_internal_presentation_mode() const {
  return presentation_mode_;
}
inline bool Config::presentation_mode() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.presentation_mode)
  return _internal_presentation_mode();
}
inline void Config::_internal_set_presentation_mode(bool value) {
  _has_bits_[0] |= 0x00000040u;
  presentation_mode_ = value;
}
inline void Config::set_presentation_mode(bool value) {
  _internal_set_presentation_mode(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.presentation_mode)
}

// optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];
inline bool Config::_internal_has_preedit_method() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Config::has_preedit_method() const {
  return _internal_has_preedit_method();
}
inline void Config::clear_preedit_method() {
  preedit_method_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::mozc::config::Config_PreeditMethod Config::_internal_preedit_method() const {
  return static_cast< ::mozc::config::Config_PreeditMethod >(preedit_method_);
}
inline ::mozc::config::Config_PreeditMethod Config::preedit_method() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.preedit_method)
  return _internal_preedit_method();
}
inline void Config::_internal_set_preedit_method(::mozc::config::Config_PreeditMethod value) {
  assert(::mozc::config::Config_PreeditMethod_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  preedit_method_ = value;
}
inline void Config::set_preedit_method(::mozc::config::Config_PreeditMethod value) {
  _internal_set_preedit_method(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.preedit_method)
}

// optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];
inline bool Config::_internal_has_session_keymap() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Config::has_session_keymap() const {
  return _internal_has_session_keymap();
}
inline void Config::clear_session_keymap() {
  session_keymap_ = -1;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::mozc::config::Config_SessionKeymap Config::_internal_session_keymap() const {
  return static_cast< ::mozc::config::Config_SessionKeymap >(session_keymap_);
}
inline ::mozc::config::Config_SessionKeymap Config::session_keymap() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.session_keymap)
  return _internal_session_keymap();
}
inline void Config::_internal_set_session_keymap(::mozc::config::Config_SessionKeymap value) {
  assert(::mozc::config::Config_SessionKeymap_IsValid(value));
  _has_bits_[0] |= 0x00080000u;
  session_keymap_ = value;
}
inline void Config::set_session_keymap(::mozc::config::Config_SessionKeymap value) {
  _internal_set_session_keymap(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.session_keymap)
}

// optional bytes custom_keymap_table = 42;
inline bool Config::_internal_has_custom_keymap_table() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Config::has_custom_keymap_table() const {
  return _internal_has_custom_keymap_table();
}
inline void Config::clear_custom_keymap_table() {
  custom_keymap_table_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Config::custom_keymap_table() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.custom_keymap_table)
  return _internal_custom_keymap_table();
}
inline void Config::set_custom_keymap_table(const std::string& value) {
  _internal_set_custom_keymap_table(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.custom_keymap_table)
}
inline std::string* Config::mutable_custom_keymap_table() {
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.custom_keymap_table)
  return _internal_mutable_custom_keymap_table();
}
inline const std::string& Config::_internal_custom_keymap_table() const {
  return custom_keymap_table_.Get();
}
inline void Config::_internal_set_custom_keymap_table(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  custom_keymap_table_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Config::set_custom_keymap_table(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  custom_keymap_table_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.Config.custom_keymap_table)
}
inline void Config::set_custom_keymap_table(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  custom_keymap_table_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.config.Config.custom_keymap_table)
}
inline void Config::set_custom_keymap_table(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  custom_keymap_table_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.config.Config.custom_keymap_table)
}
inline std::string* Config::_internal_mutable_custom_keymap_table() {
  _has_bits_[0] |= 0x00000001u;
  return custom_keymap_table_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Config::release_custom_keymap_table() {
  // @@protoc_insertion_point(field_release:mozc.config.Config.custom_keymap_table)
  if (!_internal_has_custom_keymap_table()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return custom_keymap_table_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Config::set_allocated_custom_keymap_table(std::string* custom_keymap_table) {
  if (custom_keymap_table != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  custom_keymap_table_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), custom_keymap_table,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.config.Config.custom_keymap_table)
}
inline std::string* Config::unsafe_arena_release_custom_keymap_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.config.Config.custom_keymap_table)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return custom_keymap_table_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Config::unsafe_arena_set_allocated_custom_keymap_table(
    std::string* custom_keymap_table) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (custom_keymap_table != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  custom_keymap_table_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      custom_keymap_table, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.config.Config.custom_keymap_table)
}

// optional bytes custom_roman_table = 43;
inline bool Config::_internal_has_custom_roman_table() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Config::has_custom_roman_table() const {
  return _internal_has_custom_roman_table();
}
inline void Config::clear_custom_roman_table() {
  custom_roman_table_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Config::custom_roman_table() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.custom_roman_table)
  return _internal_custom_roman_table();
}
inline void Config::set_custom_roman_table(const std::string& value) {
  _internal_set_custom_roman_table(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.custom_roman_table)
}
inline std::string* Config::mutable_custom_roman_table() {
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.custom_roman_table)
  return _internal_mutable_custom_roman_table();
}
inline const std::string& Config::_internal_custom_roman_table() const {
  return custom_roman_table_.Get();
}
inline void Config::_internal_set_custom_roman_table(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  custom_roman_table_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Config::set_custom_roman_table(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  custom_roman_table_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.Config.custom_roman_table)
}
inline void Config::set_custom_roman_table(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  custom_roman_table_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.config.Config.custom_roman_table)
}
inline void Config::set_custom_roman_table(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  custom_roman_table_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.config.Config.custom_roman_table)
}
inline std::string* Config::_internal_mutable_custom_roman_table() {
  _has_bits_[0] |= 0x00000002u;
  return custom_roman_table_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Config::release_custom_roman_table() {
  // @@protoc_insertion_point(field_release:mozc.config.Config.custom_roman_table)
  if (!_internal_has_custom_roman_table()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return custom_roman_table_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Config::set_allocated_custom_roman_table(std::string* custom_roman_table) {
  if (custom_roman_table != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  custom_roman_table_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), custom_roman_table,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.config.Config.custom_roman_table)
}
inline std::string* Config::unsafe_arena_release_custom_roman_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.config.Config.custom_roman_table)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return custom_roman_table_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Config::unsafe_arena_set_allocated_custom_roman_table(
    std::string* custom_roman_table) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (custom_roman_table != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  custom_roman_table_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      custom_roman_table, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.config.Config.custom_roman_table)
}

// optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];
inline bool Config::_internal_has_punctuation_method() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Config::has_punctuation_method() const {
  return _internal_has_punctuation_method();
}
inline void Config::clear_punctuation_method() {
  punctuation_method_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::mozc::config::Config_PunctuationMethod Config::_internal_punctuation_method() const {
  return static_cast< ::mozc::config::Config_PunctuationMethod >(punctuation_method_);
}
inline ::mozc::config::Config_PunctuationMethod Config::punctuation_method() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.punctuation_method)
  return _internal_punctuation_method();
}
inline void Config::_internal_set_punctuation_method(::mozc::config::Config_PunctuationMethod value) {
  assert(::mozc::config::Config_PunctuationMethod_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  punctuation_method_ = value;
}
inline void Config::set_punctuation_method(::mozc::config::Config_PunctuationMethod value) {
  _internal_set_punctuation_method(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.punctuation_method)
}

// optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];
inline bool Config::_internal_has_symbol_method() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Config::has_symbol_method() const {
  return _internal_has_symbol_method();
}
inline void Config::clear_symbol_method() {
  symbol_method_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::mozc::config::Config_SymbolMethod Config::_internal_symbol_method() const {
  return static_cast< ::mozc::config::Config_SymbolMethod >(symbol_method_);
}
inline ::mozc::config::Config_SymbolMethod Config::symbol_method() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.symbol_method)
  return _internal_symbol_method();
}
inline void Config::_internal_set_symbol_method(::mozc::config::Config_SymbolMethod value) {
  assert(::mozc::config::Config_SymbolMethod_IsValid(value));
  _has_bits_[0] |= 0x00008000u;
  symbol_method_ = value;
}
inline void Config::set_symbol_method(::mozc::config::Config_SymbolMethod value) {
  _internal_set_symbol_method(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.symbol_method)
}

// optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];
inline bool Config::_internal_has_space_character_form() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Config::has_space_character_form() const {
  return _internal_has_space_character_form();
}
inline void Config::clear_space_character_form() {
  space_character_form_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::mozc::config::Config_FundamentalCharacterForm Config::_internal_space_character_form() const {
  return static_cast< ::mozc::config::Config_FundamentalCharacterForm >(space_character_form_);
}
inline ::mozc::config::Config_FundamentalCharacterForm Config::space_character_form() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.space_character_form)
  return _internal_space_character_form();
}
inline void Config::_internal_set_space_character_form(::mozc::config::Config_FundamentalCharacterForm value) {
  assert(::mozc::config::Config_FundamentalCharacterForm_IsValid(value));
  _has_bits_[0] |= 0x00010000u;
  space_character_form_ = value;
}
inline void Config::set_space_character_form(::mozc::config::Config_FundamentalCharacterForm value) {
  _internal_set_space_character_form(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.space_character_form)
}

// optional bool use_keyboard_to_change_preedit_method = 48 [default = false];
inline bool Config::_internal_has_use_keyboard_to_change_preedit_method() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Config::has_use_keyboard_to_change_preedit_method() const {
  return _internal_has_use_keyboard_to_change_preedit_method();
}
inline void Config::clear_use_keyboard_to_change_preedit_method() {
  use_keyboard_to_change_preedit_method_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Config::_internal_use_keyboard_to_change_preedit_method() const {
  return use_keyboard_to_change_preedit_method_;
}
inline bool Config::use_keyboard_to_change_preedit_method() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_keyboard_to_change_preedit_method)
  return _internal_use_keyboard_to_change_preedit_method();
}
inline void Config::_internal_set_use_keyboard_to_change_preedit_method(bool value) {
  _has_bits_[0] |= 0x00000080u;
  use_keyboard_to_change_preedit_method_ = value;
}
inline void Config::set_use_keyboard_to_change_preedit_method(bool value) {
  _internal_set_use_keyboard_to_change_preedit_method(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_keyboard_to_change_preedit_method)
}

// optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];
inline bool Config::_internal_has_history_learning_level() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Config::has_history_learning_level() const {
  return _internal_has_history_learning_level();
}
inline void Config::clear_history_learning_level() {
  history_learning_level_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::mozc::config::Config_HistoryLearningLevel Config::_internal_history_learning_level() const {
  return static_cast< ::mozc::config::Config_HistoryLearningLevel >(history_learning_level_);
}
inline ::mozc::config::Config_HistoryLearningLevel Config::history_learning_level() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.history_learning_level)
  return _internal_history_learning_level();
}
inline void Config::_internal_set_history_learning_level(::mozc::config::Config_HistoryLearningLevel value) {
  assert(::mozc::config::Config_HistoryLearningLevel_IsValid(value));
  _has_bits_[0] |= 0x00020000u;
  history_learning_level_ = value;
}
inline void Config::set_history_learning_level(::mozc::config::Config_HistoryLearningLevel value) {
  _internal_set_history_learning_level(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.history_learning_level)
}

// optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];
inline bool Config::_internal_has_selection_shortcut() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Config::has_selection_shortcut() const {
  return _internal_has_selection_shortcut();
}
inline void Config::clear_selection_shortcut() {
  selection_shortcut_ = 1;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::mozc::config::Config_SelectionShortcut Config::_internal_selection_shortcut() const {
  return static_cast< ::mozc::config::Config_SelectionShortcut >(selection_shortcut_);
}
inline ::mozc::config::Config_SelectionShortcut Config::selection_shortcut() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.selection_shortcut)
  return _internal_selection_shortcut();
}
inline void Config::_internal_set_selection_shortcut(::mozc::config::Config_SelectionShortcut value) {
  assert(::mozc::config::Config_SelectionShortcut_IsValid(value));
  _has_bits_[0] |= 0x00100000u;
  selection_shortcut_ = value;
}
inline void Config::set_selection_shortcut(::mozc::config::Config_SelectionShortcut value) {
  _internal_set_selection_shortcut(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.selection_shortcut)
}

// repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;
inline int Config::_internal_character_form_rules_size() const {
  return character_form_rules_.size();
}
inline int Config::character_form_rules_size() const {
  return _internal_character_form_rules_size();
}
inline void Config::clear_character_form_rules() {
  character_form_rules_.Clear();
}
inline ::mozc::config::Config_CharacterFormRule* Config::mutable_character_form_rules(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.character_form_rules)
  return character_form_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >*
Config::mutable_character_form_rules() {
  // @@protoc_insertion_point(field_mutable_list:mozc.config.Config.character_form_rules)
  return &character_form_rules_;
}
inline const ::mozc::config::Config_CharacterFormRule& Config::_internal_character_form_rules(int index) const {
  return character_form_rules_.Get(index);
}
inline const ::mozc::config::Config_CharacterFormRule& Config::character_form_rules(int index) const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.character_form_rules)
  return _internal_character_form_rules(index);
}
inline ::mozc::config::Config_CharacterFormRule* Config::_internal_add_character_form_rules() {
  return character_form_rules_.Add();
}
inline ::mozc::config::Config_CharacterFormRule* Config::add_character_form_rules() {
  // @@protoc_insertion_point(field_add:mozc.config.Config.character_form_rules)
  return _internal_add_character_form_rules();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >&
Config::character_form_rules() const {
  // @@protoc_insertion_point(field_list:mozc.config.Config.character_form_rules)
  return character_form_rules_;
}

// optional bool use_auto_ime_turn_off = 56 [default = true];
inline bool Config::_internal_has_use_auto_ime_turn_off() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Config::has_use_auto_ime_turn_off() const {
  return _internal_has_use_auto_ime_turn_off();
}
inline void Config::clear_use_auto_ime_turn_off() {
  use_auto_ime_turn_off_ = true;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool Config::_internal_use_auto_ime_turn_off() const {
  return use_auto_ime_turn_off_;
}
inline bool Config::use_auto_ime_turn_off() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_auto_ime_turn_off)
  return _internal_use_auto_ime_turn_off();
}
inline void Config::_internal_set_use_auto_ime_turn_off(bool value) {
  _has_bits_[0] |= 0x00400000u;
  use_auto_ime_turn_off_ = value;
}
inline void Config::set_use_auto_ime_turn_off(bool value) {
  _internal_set_use_auto_ime_turn_off(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_auto_ime_turn_off)
}

// optional bool use_cascading_window = 58 [default = true];
inline bool Config::_internal_has_use_cascading_window() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Config::has_use_cascading_window() const {
  return _internal_has_use_cascading_window();
}
inline void Config::clear_use_cascading_window() {
  use_cascading_window_ = true;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool Config::_internal_use_cascading_window() const {
  return use_cascading_window_;
}
inline bool Config::use_cascading_window() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_cascading_window)
  return _internal_use_cascading_window();
}
inline void Config::_internal_set_use_cascading_window(bool value) {
  _has_bits_[0] |= 0x00800000u;
  use_cascading_window_ = value;
}
inline void Config::set_use_cascading_window(bool value) {
  _internal_set_use_cascading_window(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_cascading_window)
}

// optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];
inline bool Config::_internal_has_shift_key_mode_switch() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool Config::has_shift_key_mode_switch() const {
  return _internal_has_shift_key_mode_switch();
}
inline void Config::clear_shift_key_mode_switch() {
  shift_key_mode_switch_ = 1;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::mozc::config::Config_ShiftKeyModeSwitch Config::_internal_shift_key_mode_switch() const {
  return static_cast< ::mozc::config::Config_ShiftKeyModeSwitch >(shift_key_mode_switch_);
}
inline ::mozc::config::Config_ShiftKeyModeSwitch Config::shift_key_mode_switch() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.shift_key_mode_switch)
  return _internal_shift_key_mode_switch();
}
inline void Config::_internal_set_shift_key_mode_switch(::mozc::config::Config_ShiftKeyModeSwitch value) {
  assert(::mozc::config::Config_ShiftKeyModeSwitch_IsValid(value));
  _has_bits_[0] |= 0x02000000u;
  shift_key_mode_switch_ = value;
}
inline void Config::set_shift_key_mode_switch(::mozc::config::Config_ShiftKeyModeSwitch value) {
  _internal_set_shift_key_mode_switch(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.shift_key_mode_switch)
}

// optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];
inline bool Config::_internal_has_numpad_character_form() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool Config::has_numpad_character_form() const {
  return _internal_has_numpad_character_form();
}
inline void Config::clear_numpad_character_form() {
  numpad_character_form_ = 2;
  _has_bits_[0] &= ~0x04000000u;
}
inline ::mozc::config::Config_NumpadCharacterForm Config::_internal_numpad_character_form() const {
  return static_cast< ::mozc::config::Config_NumpadCharacterForm >(numpad_character_form_);
}
inline ::mozc::config::Config_NumpadCharacterForm Config::numpad_character_form() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.numpad_character_form)
  return _internal_numpad_character_form();
}
inline void Config::_internal_set_numpad_character_form(::mozc::config::Config_NumpadCharacterForm value) {
  assert(::mozc::config::Config_NumpadCharacterForm_IsValid(value));
  _has_bits_[0] |= 0x04000000u;
  numpad_character_form_ = value;
}
inline void Config::set_numpad_character_form(::mozc::config::Config_NumpadCharacterForm value) {
  _internal_set_numpad_character_form(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.numpad_character_form)
}

// optional bool use_auto_conversion = 61 [default = false];
inline bool Config::_internal_has_use_auto_conversion() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Config::has_use_auto_conversion() const {
  return _internal_has_use_auto_conversion();
}
inline void Config::clear_use_auto_conversion() {
  use_auto_conversion_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Config::_internal_use_auto_conversion() const {
  return use_auto_conversion_;
}
inline bool Config::use_auto_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_auto_conversion)
  return _internal_use_auto_conversion();
}
inline void Config::_internal_set_use_auto_conversion(bool value) {
  _has_bits_[0] |= 0x00000100u;
  use_auto_conversion_ = value;
}
inline void Config::set_use_auto_conversion(bool value) {
  _internal_set_use_auto_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_auto_conversion)
}

// optional uint32 auto_conversion_key = 62 [default = 13];
inline bool Config::_internal_has_auto_conversion_key() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool Config::has_auto_conversion_key() const {
  return _internal_has_auto_conversion_key();
}
inline void Config::clear_auto_conversion_key() {
  auto_conversion_key_ = 13u;
  _has_bits_[0] &= ~0x08000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Config::_internal_auto_conversion_key() const {
  return auto_conversion_key_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Config::auto_conversion_key() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.auto_conversion_key)
  return _internal_auto_conversion_key();
}
inline void Config::_internal_set_auto_conversion_key(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x08000000u;
  auto_conversion_key_ = value;
}
inline void Config::set_auto_conversion_key(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_auto_conversion_key(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.auto_conversion_key)
}

// optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];
inline bool Config::_internal_has_yen_sign_character() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Config::has_yen_sign_character() const {
  return _internal_has_yen_sign_character();
}
inline void Config::clear_yen_sign_character() {
  yen_sign_character_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::mozc::config::Config_YenSignCharacter Config::_internal_yen_sign_character() const {
  return static_cast< ::mozc::config::Config_YenSignCharacter >(yen_sign_character_);
}
inline ::mozc::config::Config_YenSignCharacter Config::yen_sign_character() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.yen_sign_character)
  return _internal_yen_sign_character();
}
inline void Config::_internal_set_yen_sign_character(::mozc::config::Config_YenSignCharacter value) {
  assert(::mozc::config::Config_YenSignCharacter_IsValid(value));
  _has_bits_[0] |= 0x00040000u;
  yen_sign_character_ = value;
}
inline void Config::set_yen_sign_character(::mozc::config::Config_YenSignCharacter value) {
  _internal_set_yen_sign_character(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.yen_sign_character)
}

// optional bool use_japanese_layout = 64 [default = false];
inline bool Config::_internal_has_use_japanese_layout() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Config::has_use_japanese_layout() const {
  return _internal_has_use_japanese_layout();
}
inline void Config::clear_use_japanese_layout() {
  use_japanese_layout_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool Config::_internal_use_japanese_layout() const {
  return use_japanese_layout_;
}
inline bool Config::use_japanese_layout() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_japanese_layout)
  return _internal_use_japanese_layout();
}
inline void Config::_internal_set_use_japanese_layout(bool value) {
  _has_bits_[0] |= 0x00000800u;
  use_japanese_layout_ = value;
}
inline void Config::set_use_japanese_layout(bool value) {
  _internal_set_use_japanese_layout(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_japanese_layout)
}

// optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];
inline bool Config::_internal_has_use_kana_modifier_insensitive_conversion() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Config::has_use_kana_modifier_insensitive_conversion() const {
  return _internal_has_use_kana_modifier_insensitive_conversion();
}
inline void Config::clear_use_kana_modifier_insensitive_conversion() {
  use_kana_modifier_insensitive_conversion_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool Config::_internal_use_kana_modifier_insensitive_conversion() const {
  return use_kana_modifier_insensitive_conversion_;
}
inline bool Config::use_kana_modifier_insensitive_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_kana_modifier_insensitive_conversion)
  return _internal_use_kana_modifier_insensitive_conversion();
}
inline void Config::_internal_set_use_kana_modifier_insensitive_conversion(bool value) {
  _has_bits_[0] |= 0x00001000u;
  use_kana_modifier_insensitive_conversion_ = value;
}
inline void Config::set_use_kana_modifier_insensitive_conversion(bool value) {
  _internal_set_use_kana_modifier_insensitive_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_kana_modifier_insensitive_conversion)
}

// optional bool use_typing_correction = 66 [default = false];
inline bool Config::_internal_has_use_typing_correction() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Config::has_use_typing_correction() const {
  return _internal_has_use_typing_correction();
}
inline void Config::clear_use_typing_correction() {
  use_typing_correction_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool Config::_internal_use_typing_correction() const {
  return use_typing_correction_;
}
inline bool Config::use_typing_correction() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_typing_correction)
  return _internal_use_typing_correction();
}
inline void Config::_internal_set_use_typing_correction(bool value) {
  _has_bits_[0] |= 0x00002000u;
  use_typing_correction_ = value;
}
inline void Config::set_use_typing_correction(bool value) {
  _internal_set_use_typing_correction(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_typing_correction)
}

// optional bool use_date_conversion = 80 [default = true];
inline bool Config::_internal_has_use_date_conversion() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool Config::has_use_date_conversion() const {
  return _internal_has_use_date_conversion();
}
inline void Config::clear_use_date_conversion() {
  use_date_conversion_ = true;
  _has_bits_[0] &= ~0x01000000u;
}
inline bool Config::_internal_use_date_conversion() const {
  return use_date_conversion_;
}
inline bool Config::use_date_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_date_conversion)
  return _internal_use_date_conversion();
}
inline void Config::_internal_set_use_date_conversion(bool value) {
  _has_bits_[0] |= 0x01000000u;
  use_date_conversion_ = value;
}
inline void Config::set_use_date_conversion(bool value) {
  _internal_set_use_date_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_date_conversion)
}

// optional bool use_single_kanji_conversion = 81 [default = true];
inline bool Config::_internal_has_use_single_kanji_conversion() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool Config::has_use_single_kanji_conversion() const {
  return _internal_has_use_single_kanji_conversion();
}
inline void Config::clear_use_single_kanji_conversion() {
  use_single_kanji_conversion_ = true;
  _has_bits_[0] &= ~0x10000000u;
}
inline bool Config::_internal_use_single_kanji_conversion() const {
  return use_single_kanji_conversion_;
}
inline bool Config::use_single_kanji_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_single_kanji_conversion)
  return _internal_use_single_kanji_conversion();
}
inline void Config::_internal_set_use_single_kanji_conversion(bool value) {
  _has_bits_[0] |= 0x10000000u;
  use_single_kanji_conversion_ = value;
}
inline void Config::set_use_single_kanji_conversion(bool value) {
  _internal_set_use_single_kanji_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_single_kanji_conversion)
}

// optional bool use_symbol_conversion = 82 [default = true];
inline bool Config::_internal_has_use_symbol_conversion() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool Config::has_use_symbol_conversion() const {
  return _internal_has_use_symbol_conversion();
}
inline void Config::clear_use_symbol_conversion() {
  use_symbol_conversion_ = true;
  _has_bits_[0] &= ~0x20000000u;
}
inline bool Config::_internal_use_symbol_conversion() const {
  return use_symbol_conversion_;
}
inline bool Config::use_symbol_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_symbol_conversion)
  return _internal_use_symbol_conversion();
}
inline void Config::_internal_set_use_symbol_conversion(bool value) {
  _has_bits_[0] |= 0x20000000u;
  use_symbol_conversion_ = value;
}
inline void Config::set_use_symbol_conversion(bool value) {
  _internal_set_use_symbol_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_symbol_conversion)
}

// optional bool use_number_conversion = 83 [default = true];
inline bool Config::_internal_has_use_number_conversion() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool Config::has_use_number_conversion() const {
  return _internal_has_use_number_conversion();
}
inline void Config::clear_use_number_conversion() {
  use_number_conversion_ = true;
  _has_bits_[0] &= ~0x40000000u;
}
inline bool Config::_internal_use_number_conversion() const {
  return use_number_conversion_;
}
inline bool Config::use_number_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_number_conversion)
  return _internal_use_number_conversion();
}
inline void Config::_internal_set_use_number_conversion(bool value) {
  _has_bits_[0] |= 0x40000000u;
  use_number_conversion_ = value;
}
inline void Config::set_use_number_conversion(bool value) {
  _internal_set_use_number_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_number_conversion)
}

// optional bool use_emoticon_conversion = 84 [default = true];
inline bool Config::_internal_has_use_emoticon_conversion() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool Config::has_use_emoticon_conversion() const {
  return _internal_has_use_emoticon_conversion();
}
inline void Config::clear_use_emoticon_conversion() {
  use_emoticon_conversion_ = true;
  _has_bits_[0] &= ~0x80000000u;
}
inline bool Config::_internal_use_emoticon_conversion() const {
  return use_emoticon_conversion_;
}
inline bool Config::use_emoticon_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_emoticon_conversion)
  return _internal_use_emoticon_conversion();
}
inline void Config::_internal_set_use_emoticon_conversion(bool value) {
  _has_bits_[0] |= 0x80000000u;
  use_emoticon_conversion_ = value;
}
inline void Config::set_use_emoticon_conversion(bool value) {
  _internal_set_use_emoticon_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_emoticon_conversion)
}

// optional bool use_calculator = 85 [default = true];
inline bool Config::_internal_has_use_calculator() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool Config::has_use_calculator() const {
  return _internal_has_use_calculator();
}
inline void Config::clear_use_calculator() {
  use_calculator_ = true;
  _has_bits_[1] &= ~0x00000001u;
}
inline bool Config::_internal_use_calculator() const {
  return use_calculator_;
}
inline bool Config::use_calculator() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_calculator)
  return _internal_use_calculator();
}
inline void Config::_internal_set_use_calculator(bool value) {
  _has_bits_[1] |= 0x00000001u;
  use_calculator_ = value;
}
inline void Config::set_use_calculator(bool value) {
  _internal_set_use_calculator(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_calculator)
}

// optional bool use_t13n_conversion = 86 [default = true];
inline bool Config::_internal_has_use_t13n_conversion() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool Config::has_use_t13n_conversion() const {
  return _internal_has_use_t13n_conversion();
}
inline void Config::clear_use_t13n_conversion() {
  use_t13n_conversion_ = true;
  _has_bits_[1] &= ~0x00000002u;
}
inline bool Config::_internal_use_t13n_conversion() const {
  return use_t13n_conversion_;
}
inline bool Config::use_t13n_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_t13n_conversion)
  return _internal_use_t13n_conversion();
}
inline void Config::_internal_set_use_t13n_conversion(bool value) {
  _has_bits_[1] |= 0x00000002u;
  use_t13n_conversion_ = value;
}
inline void Config::set_use_t13n_conversion(bool value) {
  _internal_set_use_t13n_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_t13n_conversion)
}

// optional bool use_zip_code_conversion = 87 [default = true];
inline bool Config::_internal_has_use_zip_code_conversion() const {
  bool value = (_has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool Config::has_use_zip_code_conversion() const {
  return _internal_has_use_zip_code_conversion();
}
inline void Config::clear_use_zip_code_conversion() {
  use_zip_code_conversion_ = true;
  _has_bits_[1] &= ~0x00000004u;
}
inline bool Config::_internal_use_zip_code_conversion() const {
  return use_zip_code_conversion_;
}
inline bool Config::use_zip_code_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_zip_code_conversion)
  return _internal_use_zip_code_conversion();
}
inline void Config::_internal_set_use_zip_code_conversion(bool value) {
  _has_bits_[1] |= 0x00000004u;
  use_zip_code_conversion_ = value;
}
inline void Config::set_use_zip_code_conversion(bool value) {
  _internal_set_use_zip_code_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_zip_code_conversion)
}

// optional bool use_spelling_correction = 88 [default = true];
inline bool Config::_internal_has_use_spelling_correction() const {
  bool value = (_has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool Config::has_use_spelling_correction() const {
  return _internal_has_use_spelling_correction();
}
inline void Config::clear_use_spelling_correction() {
  use_spelling_correction_ = true;
  _has_bits_[1] &= ~0x00000008u;
}
inline bool Config::_internal_use_spelling_correction() const {
  return use_spelling_correction_;
}
inline bool Config::use_spelling_correction() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_spelling_correction)
  return _internal_use_spelling_correction();
}
inline void Config::_internal_set_use_spelling_correction(bool value) {
  _has_bits_[1] |= 0x00000008u;
  use_spelling_correction_ = value;
}
inline void Config::set_use_spelling_correction(bool value) {
  _internal_set_use_spelling_correction(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_spelling_correction)
}

// optional bool use_emoji_conversion = 89 [default = false];
inline bool Config::_internal_has_use_emoji_conversion() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Config::has_use_emoji_conversion() const {
  return _internal_has_use_emoji_conversion();
}
inline void Config::clear_use_emoji_conversion() {
  use_emoji_conversion_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool Config::_internal_use_emoji_conversion() const {
  return use_emoji_conversion_;
}
inline bool Config::use_emoji_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_emoji_conversion)
  return _internal_use_emoji_conversion();
}
inline void Config::_internal_set_use_emoji_conversion(bool value) {
  _has_bits_[0] |= 0x00004000u;
  use_emoji_conversion_ = value;
}
inline void Config::set_use_emoji_conversion(bool value) {
  _internal_set_use_emoji_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_emoji_conversion)
}

// optional .mozc.config.Config.InformationListConfig information_list_config = 90;
inline bool Config::_internal_has_information_list_config() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || information_list_config_ != nullptr);
  return value;
}
inline bool Config::has_information_list_config() const {
  return _internal_has_information_list_config();
}
inline void Config::clear_information_list_config() {
  if (information_list_config_ != nullptr) information_list_config_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mozc::config::Config_InformationListConfig& Config::_internal_information_list_config() const {
  const ::mozc::config::Config_InformationListConfig* p = information_list_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::config::Config_InformationListConfig*>(
      &::mozc::config::_Config_InformationListConfig_default_instance_);
}
inline const ::mozc::config::Config_InformationListConfig& Config::information_list_config() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.information_list_config)
  return _internal_information_list_config();
}
inline void Config::unsafe_arena_set_allocated_information_list_config(
    ::mozc::config::Config_InformationListConfig* information_list_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(information_list_config_);
  }
  information_list_config_ = information_list_config;
  if (information_list_config) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.config.Config.information_list_config)
}
inline ::mozc::config::Config_InformationListConfig* Config::release_information_list_config() {
  auto temp = unsafe_arena_release_information_list_config();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::config::Config_InformationListConfig* Config::unsafe_arena_release_information_list_config() {
  // @@protoc_insertion_point(field_release:mozc.config.Config.information_list_config)
  _has_bits_[0] &= ~0x00000008u;
  ::mozc::config::Config_InformationListConfig* temp = information_list_config_;
  information_list_config_ = nullptr;
  return temp;
}
inline ::mozc::config::Config_InformationListConfig* Config::_internal_mutable_information_list_config() {
  _has_bits_[0] |= 0x00000008u;
  if (information_list_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::config::Config_InformationListConfig>(GetArena());
    information_list_config_ = p;
  }
  return information_list_config_;
}
inline ::mozc::config::Config_InformationListConfig* Config::mutable_information_list_config() {
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.information_list_config)
  return _internal_mutable_information_list_config();
}
inline void Config::set_allocated_information_list_config(::mozc::config::Config_InformationListConfig* information_list_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete information_list_config_;
  }
  if (information_list_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(information_list_config);
    if (message_arena != submessage_arena) {
      information_list_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, information_list_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  information_list_config_ = information_list_config;
  // @@protoc_insertion_point(field_set_allocated:mozc.config.Config.information_list_config)
}

// optional bool use_history_suggest = 100 [default = true];
inline bool Config::_internal_has_use_history_suggest() const {
  bool value = (_has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool Config::has_use_history_suggest() const {
  return _internal_has_use_history_suggest();
}
inline void Config::clear_use_history_suggest() {
  use_history_suggest_ = true;
  _has_bits_[1] &= ~0x00000010u;
}
inline bool Config::_internal_use_history_suggest() const {
  return use_history_suggest_;
}
inline bool Config::use_history_suggest() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_history_suggest)
  return _internal_use_history_suggest();
}
inline void Config::_internal_set_use_history_suggest(bool value) {
  _has_bits_[1] |= 0x00000010u;
  use_history_suggest_ = value;
}
inline void Config::set_use_history_suggest(bool value) {
  _internal_set_use_history_suggest(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_history_suggest)
}

// optional bool use_dictionary_suggest = 101 [default = true];
inline bool Config::_internal_has_use_dictionary_suggest() const {
  bool value = (_has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool Config::has_use_dictionary_suggest() const {
  return _internal_has_use_dictionary_suggest();
}
inline void Config::clear_use_dictionary_suggest() {
  use_dictionary_suggest_ = true;
  _has_bits_[1] &= ~0x00000020u;
}
inline bool Config::_internal_use_dictionary_suggest() const {
  return use_dictionary_suggest_;
}
inline bool Config::use_dictionary_suggest() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_dictionary_suggest)
  return _internal_use_dictionary_suggest();
}
inline void Config::_internal_set_use_dictionary_suggest(bool value) {
  _has_bits_[1] |= 0x00000020u;
  use_dictionary_suggest_ = value;
}
inline void Config::set_use_dictionary_suggest(bool value) {
  _internal_set_use_dictionary_suggest(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_dictionary_suggest)
}

// optional bool use_realtime_conversion = 102 [default = true];
inline bool Config::_internal_has_use_realtime_conversion() const {
  bool value = (_has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool Config::has_use_realtime_conversion() const {
  return _internal_has_use_realtime_conversion();
}
inline void Config::clear_use_realtime_conversion() {
  use_realtime_conversion_ = true;
  _has_bits_[1] &= ~0x00000040u;
}
inline bool Config::_internal_use_realtime_conversion() const {
  return use_realtime_conversion_;
}
inline bool Config::use_realtime_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_realtime_conversion)
  return _internal_use_realtime_conversion();
}
inline void Config::_internal_set_use_realtime_conversion(bool value) {
  _has_bits_[1] |= 0x00000040u;
  use_realtime_conversion_ = value;
}
inline void Config::set_use_realtime_conversion(bool value) {
  _internal_set_use_realtime_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_realtime_conversion)
}

// optional uint32 suggestions_size = 110 [default = 3];
inline bool Config::_internal_has_suggestions_size() const {
  bool value = (_has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool Config::has_suggestions_size() const {
  return _internal_has_suggestions_size();
}
inline void Config::clear_suggestions_size() {
  suggestions_size_ = 3u;
  _has_bits_[1] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Config::_internal_suggestions_size() const {
  return suggestions_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Config::suggestions_size() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.suggestions_size)
  return _internal_suggestions_size();
}
inline void Config::_internal_set_suggestions_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000100u;
  suggestions_size_ = value;
}
inline void Config::set_suggestions_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_suggestions_size(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.suggestions_size)
}

// optional bool use_mode_indicator = 120 [default = true];
inline bool Config::_internal_has_use_mode_indicator() const {
  bool value = (_has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool Config::has_use_mode_indicator() const {
  return _internal_has_use_mode_indicator();
}
inline void Config::clear_use_mode_indicator() {
  use_mode_indicator_ = true;
  _has_bits_[1] &= ~0x00000080u;
}
inline bool Config::_internal_use_mode_indicator() const {
  return use_mode_indicator_;
}
inline bool Config::use_mode_indicator() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_mode_indicator)
  return _internal_use_mode_indicator();
}
inline void Config::_internal_set_use_mode_indicator(bool value) {
  _has_bits_[1] |= 0x00000080u;
  use_mode_indicator_ = value;
}
inline void Config::set_use_mode_indicator(bool value) {
  _internal_set_use_mode_indicator(value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_mode_indicator)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace config
}  // namespace mozc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mozc::config::Config_PreeditMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_PreeditMethod>() {
  return ::mozc::config::Config_PreeditMethod_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_SessionKeymap> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_SessionKeymap>() {
  return ::mozc::config::Config_SessionKeymap_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_PunctuationMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_PunctuationMethod>() {
  return ::mozc::config::Config_PunctuationMethod_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_SymbolMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_SymbolMethod>() {
  return ::mozc::config::Config_SymbolMethod_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_FundamentalCharacterForm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_FundamentalCharacterForm>() {
  return ::mozc::config::Config_FundamentalCharacterForm_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_HistoryLearningLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_HistoryLearningLevel>() {
  return ::mozc::config::Config_HistoryLearningLevel_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_SelectionShortcut> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_SelectionShortcut>() {
  return ::mozc::config::Config_SelectionShortcut_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_CharacterForm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_CharacterForm>() {
  return ::mozc::config::Config_CharacterForm_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_ShiftKeyModeSwitch> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_ShiftKeyModeSwitch>() {
  return ::mozc::config::Config_ShiftKeyModeSwitch_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_NumpadCharacterForm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_NumpadCharacterForm>() {
  return ::mozc::config::Config_NumpadCharacterForm_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_AutoConversionKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_AutoConversionKey>() {
  return ::mozc::config::Config_AutoConversionKey_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_YenSignCharacter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_YenSignCharacter>() {
  return ::mozc::config::Config_YenSignCharacter_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protocol_2fconfig_2eproto
