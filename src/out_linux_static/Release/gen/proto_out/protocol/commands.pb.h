// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol/commands.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocol_2fcommands_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protocol_2fcommands_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "protocol/candidates.pb.h"
#include "protocol/config.pb.h"
#include "protocol/engine_builder.pb.h"
#include "protocol/user_dictionary_storage.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protocol_2fcommands_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protocol_2fcommands_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_2fcommands_2eproto;
namespace mozc {
namespace commands {
class ApplicationInfo;
class ApplicationInfoDefaultTypeInternal;
extern ApplicationInfoDefaultTypeInternal _ApplicationInfo_default_instance_;
class Capability;
class CapabilityDefaultTypeInternal;
extern CapabilityDefaultTypeInternal _Capability_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class CommandList;
class CommandListDefaultTypeInternal;
extern CommandListDefaultTypeInternal _CommandList_default_instance_;
class Context;
class ContextDefaultTypeInternal;
extern ContextDefaultTypeInternal _Context_default_instance_;
class DecoderExperimentParams;
class DecoderExperimentParamsDefaultTypeInternal;
extern DecoderExperimentParamsDefaultTypeInternal _DecoderExperimentParams_default_instance_;
class DeletionRange;
class DeletionRangeDefaultTypeInternal;
extern DeletionRangeDefaultTypeInternal _DeletionRange_default_instance_;
class GenericStorageEntry;
class GenericStorageEntryDefaultTypeInternal;
extern GenericStorageEntryDefaultTypeInternal _GenericStorageEntry_default_instance_;
class Input;
class InputDefaultTypeInternal;
extern InputDefaultTypeInternal _Input_default_instance_;
class Input_TouchEvent;
class Input_TouchEventDefaultTypeInternal;
extern Input_TouchEventDefaultTypeInternal _Input_TouchEvent_default_instance_;
class Input_TouchPosition;
class Input_TouchPositionDefaultTypeInternal;
extern Input_TouchPositionDefaultTypeInternal _Input_TouchPosition_default_instance_;
class KeyEvent;
class KeyEventDefaultTypeInternal;
extern KeyEventDefaultTypeInternal _KeyEvent_default_instance_;
class KeyEvent_ProbableKeyEvent;
class KeyEvent_ProbableKeyEventDefaultTypeInternal;
extern KeyEvent_ProbableKeyEventDefaultTypeInternal _KeyEvent_ProbableKeyEvent_default_instance_;
class Output;
class OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Output_Callback;
class Output_CallbackDefaultTypeInternal;
extern Output_CallbackDefaultTypeInternal _Output_Callback_default_instance_;
class Preedit;
class PreeditDefaultTypeInternal;
extern PreeditDefaultTypeInternal _Preedit_default_instance_;
class Preedit_Segment;
class Preedit_SegmentDefaultTypeInternal;
extern Preedit_SegmentDefaultTypeInternal _Preedit_Segment_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Result;
class ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class SessionCommand;
class SessionCommandDefaultTypeInternal;
extern SessionCommandDefaultTypeInternal _SessionCommand_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace commands
}  // namespace mozc
PROTOBUF_NAMESPACE_OPEN
template<> ::mozc::commands::ApplicationInfo* Arena::CreateMaybeMessage<::mozc::commands::ApplicationInfo>(Arena*);
template<> ::mozc::commands::Capability* Arena::CreateMaybeMessage<::mozc::commands::Capability>(Arena*);
template<> ::mozc::commands::Command* Arena::CreateMaybeMessage<::mozc::commands::Command>(Arena*);
template<> ::mozc::commands::CommandList* Arena::CreateMaybeMessage<::mozc::commands::CommandList>(Arena*);
template<> ::mozc::commands::Context* Arena::CreateMaybeMessage<::mozc::commands::Context>(Arena*);
template<> ::mozc::commands::DecoderExperimentParams* Arena::CreateMaybeMessage<::mozc::commands::DecoderExperimentParams>(Arena*);
template<> ::mozc::commands::DeletionRange* Arena::CreateMaybeMessage<::mozc::commands::DeletionRange>(Arena*);
template<> ::mozc::commands::GenericStorageEntry* Arena::CreateMaybeMessage<::mozc::commands::GenericStorageEntry>(Arena*);
template<> ::mozc::commands::Input* Arena::CreateMaybeMessage<::mozc::commands::Input>(Arena*);
template<> ::mozc::commands::Input_TouchEvent* Arena::CreateMaybeMessage<::mozc::commands::Input_TouchEvent>(Arena*);
template<> ::mozc::commands::Input_TouchPosition* Arena::CreateMaybeMessage<::mozc::commands::Input_TouchPosition>(Arena*);
template<> ::mozc::commands::KeyEvent* Arena::CreateMaybeMessage<::mozc::commands::KeyEvent>(Arena*);
template<> ::mozc::commands::KeyEvent_ProbableKeyEvent* Arena::CreateMaybeMessage<::mozc::commands::KeyEvent_ProbableKeyEvent>(Arena*);
template<> ::mozc::commands::Output* Arena::CreateMaybeMessage<::mozc::commands::Output>(Arena*);
template<> ::mozc::commands::Output_Callback* Arena::CreateMaybeMessage<::mozc::commands::Output_Callback>(Arena*);
template<> ::mozc::commands::Preedit* Arena::CreateMaybeMessage<::mozc::commands::Preedit>(Arena*);
template<> ::mozc::commands::Preedit_Segment* Arena::CreateMaybeMessage<::mozc::commands::Preedit_Segment>(Arena*);
template<> ::mozc::commands::Request* Arena::CreateMaybeMessage<::mozc::commands::Request>(Arena*);
template<> ::mozc::commands::Result* Arena::CreateMaybeMessage<::mozc::commands::Result>(Arena*);
template<> ::mozc::commands::SessionCommand* Arena::CreateMaybeMessage<::mozc::commands::SessionCommand>(Arena*);
template<> ::mozc::commands::Status* Arena::CreateMaybeMessage<::mozc::commands::Status>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mozc {
namespace commands {

enum KeyEvent_SpecialKey : int {
  KeyEvent_SpecialKey_NO_SPECIALKEY = 0,
  KeyEvent_SpecialKey_DIGIT = 1,
  KeyEvent_SpecialKey_ON = 2,
  KeyEvent_SpecialKey_OFF = 3,
  KeyEvent_SpecialKey_SPACE = 4,
  KeyEvent_SpecialKey_ENTER = 5,
  KeyEvent_SpecialKey_LEFT = 6,
  KeyEvent_SpecialKey_RIGHT = 7,
  KeyEvent_SpecialKey_UP = 8,
  KeyEvent_SpecialKey_DOWN = 9,
  KeyEvent_SpecialKey_ESCAPE = 10,
  KeyEvent_SpecialKey_DEL = 11,
  KeyEvent_SpecialKey_BACKSPACE = 12,
  KeyEvent_SpecialKey_HENKAN = 13,
  KeyEvent_SpecialKey_MUHENKAN = 14,
  KeyEvent_SpecialKey_KANA = 15,
  KeyEvent_SpecialKey_HOME = 16,
  KeyEvent_SpecialKey_END = 17,
  KeyEvent_SpecialKey_TAB = 18,
  KeyEvent_SpecialKey_F1 = 19,
  KeyEvent_SpecialKey_F2 = 20,
  KeyEvent_SpecialKey_F3 = 21,
  KeyEvent_SpecialKey_F4 = 22,
  KeyEvent_SpecialKey_F5 = 23,
  KeyEvent_SpecialKey_F6 = 24,
  KeyEvent_SpecialKey_F7 = 25,
  KeyEvent_SpecialKey_F8 = 26,
  KeyEvent_SpecialKey_F9 = 27,
  KeyEvent_SpecialKey_F10 = 28,
  KeyEvent_SpecialKey_F11 = 29,
  KeyEvent_SpecialKey_F12 = 30,
  KeyEvent_SpecialKey_PAGE_UP = 31,
  KeyEvent_SpecialKey_PAGE_DOWN = 32,
  KeyEvent_SpecialKey_INSERT = 33,
  KeyEvent_SpecialKey_F13 = 34,
  KeyEvent_SpecialKey_F14 = 35,
  KeyEvent_SpecialKey_F15 = 36,
  KeyEvent_SpecialKey_F16 = 37,
  KeyEvent_SpecialKey_F17 = 38,
  KeyEvent_SpecialKey_F18 = 39,
  KeyEvent_SpecialKey_F19 = 40,
  KeyEvent_SpecialKey_F20 = 41,
  KeyEvent_SpecialKey_F21 = 42,
  KeyEvent_SpecialKey_F22 = 43,
  KeyEvent_SpecialKey_F23 = 44,
  KeyEvent_SpecialKey_F24 = 45,
  KeyEvent_SpecialKey_EISU = 46,
  KeyEvent_SpecialKey_NUMPAD0 = 47,
  KeyEvent_SpecialKey_NUMPAD1 = 48,
  KeyEvent_SpecialKey_NUMPAD2 = 49,
  KeyEvent_SpecialKey_NUMPAD3 = 50,
  KeyEvent_SpecialKey_NUMPAD4 = 51,
  KeyEvent_SpecialKey_NUMPAD5 = 52,
  KeyEvent_SpecialKey_NUMPAD6 = 53,
  KeyEvent_SpecialKey_NUMPAD7 = 54,
  KeyEvent_SpecialKey_NUMPAD8 = 55,
  KeyEvent_SpecialKey_NUMPAD9 = 56,
  KeyEvent_SpecialKey_MULTIPLY = 57,
  KeyEvent_SpecialKey_ADD = 58,
  KeyEvent_SpecialKey_SEPARATOR = 59,
  KeyEvent_SpecialKey_SUBTRACT = 60,
  KeyEvent_SpecialKey_DECIMAL = 61,
  KeyEvent_SpecialKey_DIVIDE = 62,
  KeyEvent_SpecialKey_EQUALS = 63,
  KeyEvent_SpecialKey_TEXT_INPUT = 64,
  KeyEvent_SpecialKey_HANKAKU = 65,
  KeyEvent_SpecialKey_KANJI = 66,
  KeyEvent_SpecialKey_KATAKANA = 67,
  KeyEvent_SpecialKey_CAPS_LOCK = 68,
  KeyEvent_SpecialKey_UNDEFINED_KEY = 69,
  KeyEvent_SpecialKey_COMMA = 70,
  KeyEvent_SpecialKey_CLEAR = 71,
  KeyEvent_SpecialKey_VIRTUAL_LEFT = 72,
  KeyEvent_SpecialKey_VIRTUAL_RIGHT = 73,
  KeyEvent_SpecialKey_VIRTUAL_ENTER = 74,
  KeyEvent_SpecialKey_VIRTUAL_UP = 75,
  KeyEvent_SpecialKey_VIRTUAL_DOWN = 76,
  KeyEvent_SpecialKey_NUM_SPECIALKEYS = 77
};
bool KeyEvent_SpecialKey_IsValid(int value);
constexpr KeyEvent_SpecialKey KeyEvent_SpecialKey_SpecialKey_MIN = KeyEvent_SpecialKey_NO_SPECIALKEY;
constexpr KeyEvent_SpecialKey KeyEvent_SpecialKey_SpecialKey_MAX = KeyEvent_SpecialKey_NUM_SPECIALKEYS;
constexpr int KeyEvent_SpecialKey_SpecialKey_ARRAYSIZE = KeyEvent_SpecialKey_SpecialKey_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyEvent_SpecialKey_descriptor();
template<typename T>
inline const std::string& KeyEvent_SpecialKey_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyEvent_SpecialKey>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyEvent_SpecialKey_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyEvent_SpecialKey_descriptor(), enum_t_value);
}
inline bool KeyEvent_SpecialKey_Parse(
    const std::string& name, KeyEvent_SpecialKey* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyEvent_SpecialKey>(
    KeyEvent_SpecialKey_descriptor(), name, value);
}
enum KeyEvent_ModifierKey : int {
  KeyEvent_ModifierKey_CTRL = 1,
  KeyEvent_ModifierKey_ALT = 2,
  KeyEvent_ModifierKey_SHIFT = 4,
  KeyEvent_ModifierKey_KEY_DOWN = 8,
  KeyEvent_ModifierKey_KEY_UP = 16,
  KeyEvent_ModifierKey_LEFT_CTRL = 32,
  KeyEvent_ModifierKey_LEFT_ALT = 64,
  KeyEvent_ModifierKey_LEFT_SHIFT = 128,
  KeyEvent_ModifierKey_RIGHT_CTRL = 256,
  KeyEvent_ModifierKey_RIGHT_ALT = 512,
  KeyEvent_ModifierKey_RIGHT_SHIFT = 1024,
  KeyEvent_ModifierKey_CAPS = 2048
};
bool KeyEvent_ModifierKey_IsValid(int value);
constexpr KeyEvent_ModifierKey KeyEvent_ModifierKey_ModifierKey_MIN = KeyEvent_ModifierKey_CTRL;
constexpr KeyEvent_ModifierKey KeyEvent_ModifierKey_ModifierKey_MAX = KeyEvent_ModifierKey_CAPS;
constexpr int KeyEvent_ModifierKey_ModifierKey_ARRAYSIZE = KeyEvent_ModifierKey_ModifierKey_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyEvent_ModifierKey_descriptor();
template<typename T>
inline const std::string& KeyEvent_ModifierKey_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyEvent_ModifierKey>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyEvent_ModifierKey_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyEvent_ModifierKey_descriptor(), enum_t_value);
}
inline bool KeyEvent_ModifierKey_Parse(
    const std::string& name, KeyEvent_ModifierKey* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyEvent_ModifierKey>(
    KeyEvent_ModifierKey_descriptor(), name, value);
}
enum KeyEvent_InputStyle : int {
  KeyEvent_InputStyle_FOLLOW_MODE = 0,
  KeyEvent_InputStyle_AS_IS = 1,
  KeyEvent_InputStyle_DIRECT_INPUT = 2
};
bool KeyEvent_InputStyle_IsValid(int value);
constexpr KeyEvent_InputStyle KeyEvent_InputStyle_InputStyle_MIN = KeyEvent_InputStyle_FOLLOW_MODE;
constexpr KeyEvent_InputStyle KeyEvent_InputStyle_InputStyle_MAX = KeyEvent_InputStyle_DIRECT_INPUT;
constexpr int KeyEvent_InputStyle_InputStyle_ARRAYSIZE = KeyEvent_InputStyle_InputStyle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyEvent_InputStyle_descriptor();
template<typename T>
inline const std::string& KeyEvent_InputStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyEvent_InputStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyEvent_InputStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyEvent_InputStyle_descriptor(), enum_t_value);
}
inline bool KeyEvent_InputStyle_Parse(
    const std::string& name, KeyEvent_InputStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyEvent_InputStyle>(
    KeyEvent_InputStyle_descriptor(), name, value);
}
enum GenericStorageEntry_StorageType : int {
  GenericStorageEntry_StorageType_SYMBOL_HISTORY = 0,
  GenericStorageEntry_StorageType_EMOTICON_HISTORY = 1,
  GenericStorageEntry_StorageType_EMOJI_HISTORY = 2
};
bool GenericStorageEntry_StorageType_IsValid(int value);
constexpr GenericStorageEntry_StorageType GenericStorageEntry_StorageType_StorageType_MIN = GenericStorageEntry_StorageType_SYMBOL_HISTORY;
constexpr GenericStorageEntry_StorageType GenericStorageEntry_StorageType_StorageType_MAX = GenericStorageEntry_StorageType_EMOJI_HISTORY;
constexpr int GenericStorageEntry_StorageType_StorageType_ARRAYSIZE = GenericStorageEntry_StorageType_StorageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GenericStorageEntry_StorageType_descriptor();
template<typename T>
inline const std::string& GenericStorageEntry_StorageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GenericStorageEntry_StorageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GenericStorageEntry_StorageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GenericStorageEntry_StorageType_descriptor(), enum_t_value);
}
inline bool GenericStorageEntry_StorageType_Parse(
    const std::string& name, GenericStorageEntry_StorageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GenericStorageEntry_StorageType>(
    GenericStorageEntry_StorageType_descriptor(), name, value);
}
enum SessionCommand_CommandType : int {
  SessionCommand_CommandType_NONE = 0,
  SessionCommand_CommandType_REVERT = 1,
  SessionCommand_CommandType_SUBMIT = 2,
  SessionCommand_CommandType_SELECT_CANDIDATE = 3,
  SessionCommand_CommandType_HIGHLIGHT_CANDIDATE = 4,
  SessionCommand_CommandType_SWITCH_INPUT_MODE = 5,
  SessionCommand_CommandType_GET_STATUS = 6,
  SessionCommand_CommandType_SUBMIT_CANDIDATE = 7,
  SessionCommand_CommandType_CONVERT_REVERSE = 8,
  SessionCommand_CommandType_UNDO = 9,
  SessionCommand_CommandType_RESET_CONTEXT = 10,
  SessionCommand_CommandType_MOVE_CURSOR = 11,
  SessionCommand_CommandType_SWITCH_INPUT_FIELD_TYPE = 12,
  SessionCommand_CommandType_USAGE_STATS_EVENT = 13,
  SessionCommand_CommandType_UNDO_OR_REWIND = 14,
  SessionCommand_CommandType_EXPAND_SUGGESTION = 15,
  SessionCommand_CommandType_COMMIT_RAW_TEXT = 19,
  SessionCommand_CommandType_CONVERT_PREV_PAGE = 20,
  SessionCommand_CommandType_CONVERT_NEXT_PAGE = 21,
  SessionCommand_CommandType_TURN_ON_IME = 22,
  SessionCommand_CommandType_TURN_OFF_IME = 23,
  SessionCommand_CommandType_DELETE_CANDIDATE_FROM_HISTORY = 24,
  SessionCommand_CommandType_STOP_KEY_TOGGLING = 25
};
bool SessionCommand_CommandType_IsValid(int value);
constexpr SessionCommand_CommandType SessionCommand_CommandType_CommandType_MIN = SessionCommand_CommandType_NONE;
constexpr SessionCommand_CommandType SessionCommand_CommandType_CommandType_MAX = SessionCommand_CommandType_STOP_KEY_TOGGLING;
constexpr int SessionCommand_CommandType_CommandType_ARRAYSIZE = SessionCommand_CommandType_CommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionCommand_CommandType_descriptor();
template<typename T>
inline const std::string& SessionCommand_CommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionCommand_CommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionCommand_CommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionCommand_CommandType_descriptor(), enum_t_value);
}
inline bool SessionCommand_CommandType_Parse(
    const std::string& name, SessionCommand_CommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionCommand_CommandType>(
    SessionCommand_CommandType_descriptor(), name, value);
}
enum SessionCommand_UsageStatsEvent : int {
  SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_SHOW = 1,
  SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_HIDE = 2,
  SessionCommand_UsageStatsEvent_HANDWRITING_OPEN_EVENT = 3,
  SessionCommand_UsageStatsEvent_HANDWRITING_COMMIT_EVENT = 4,
  SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_OPEN_EVENT = 5,
  SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_COMMIT_EVENT = 6,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_LANDSCAPE = 7,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_PORTRAIT = 8,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_0 = 9,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_1 = 10,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_2 = 11,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_3 = 12,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_4 = 13,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_5 = 14,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_6 = 15,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_7 = 16,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_8 = 17,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_9 = 18,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_GE10 = 19,
  SessionCommand_UsageStatsEvent_KEYBOARD_FOLD_EVENT = 20,
  SessionCommand_UsageStatsEvent_KEYBOARD_EXPAND_EVENT = 21,
  SessionCommand_UsageStatsEvent_MUSHROOM_SELECTION_DIALOG_OPEN_EVENT = 22,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_LANDSCAPE = 25,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_PORTRAIT = 26,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_LANDSCAPE = 27,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_PORTRAIT = 28
};
bool SessionCommand_UsageStatsEvent_IsValid(int value);
constexpr SessionCommand_UsageStatsEvent SessionCommand_UsageStatsEvent_UsageStatsEvent_MIN = SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_SHOW;
constexpr SessionCommand_UsageStatsEvent SessionCommand_UsageStatsEvent_UsageStatsEvent_MAX = SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_PORTRAIT;
constexpr int SessionCommand_UsageStatsEvent_UsageStatsEvent_ARRAYSIZE = SessionCommand_UsageStatsEvent_UsageStatsEvent_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionCommand_UsageStatsEvent_descriptor();
template<typename T>
inline const std::string& SessionCommand_UsageStatsEvent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionCommand_UsageStatsEvent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionCommand_UsageStatsEvent_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionCommand_UsageStatsEvent_descriptor(), enum_t_value);
}
inline bool SessionCommand_UsageStatsEvent_Parse(
    const std::string& name, SessionCommand_UsageStatsEvent* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionCommand_UsageStatsEvent>(
    SessionCommand_UsageStatsEvent_descriptor(), name, value);
}
enum Context_InputFieldType : int {
  Context_InputFieldType_NORMAL = 1,
  Context_InputFieldType_PASSWORD = 2,
  Context_InputFieldType_TEL = 3,
  Context_InputFieldType_NUMBER = 4
};
bool Context_InputFieldType_IsValid(int value);
constexpr Context_InputFieldType Context_InputFieldType_InputFieldType_MIN = Context_InputFieldType_NORMAL;
constexpr Context_InputFieldType Context_InputFieldType_InputFieldType_MAX = Context_InputFieldType_NUMBER;
constexpr int Context_InputFieldType_InputFieldType_ARRAYSIZE = Context_InputFieldType_InputFieldType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Context_InputFieldType_descriptor();
template<typename T>
inline const std::string& Context_InputFieldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Context_InputFieldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Context_InputFieldType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Context_InputFieldType_descriptor(), enum_t_value);
}
inline bool Context_InputFieldType_Parse(
    const std::string& name, Context_InputFieldType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Context_InputFieldType>(
    Context_InputFieldType_descriptor(), name, value);
}
enum Capability_TextDeletionCapabilityType : int {
  Capability_TextDeletionCapabilityType_NO_TEXT_DELETION_CAPABILITY = 0,
  Capability_TextDeletionCapabilityType_DELETE_PRECEDING_TEXT = 1
};
bool Capability_TextDeletionCapabilityType_IsValid(int value);
constexpr Capability_TextDeletionCapabilityType Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MIN = Capability_TextDeletionCapabilityType_NO_TEXT_DELETION_CAPABILITY;
constexpr Capability_TextDeletionCapabilityType Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MAX = Capability_TextDeletionCapabilityType_DELETE_PRECEDING_TEXT;
constexpr int Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_ARRAYSIZE = Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Capability_TextDeletionCapabilityType_descriptor();
template<typename T>
inline const std::string& Capability_TextDeletionCapabilityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Capability_TextDeletionCapabilityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Capability_TextDeletionCapabilityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Capability_TextDeletionCapabilityType_descriptor(), enum_t_value);
}
inline bool Capability_TextDeletionCapabilityType_Parse(
    const std::string& name, Capability_TextDeletionCapabilityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Capability_TextDeletionCapabilityType>(
    Capability_TextDeletionCapabilityType_descriptor(), name, value);
}
enum Request_SpecialRomanjiTable : int {
  Request_SpecialRomanjiTable_DEFAULT_TABLE = 0,
  Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HIRAGANA = 10,
  Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HIRAGANA_INTUITIVE = 10000,
  Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HALFWIDTHASCII = 11,
  Request_SpecialRomanjiTable_FLICK_TO_HIRAGANA = 13,
  Request_SpecialRomanjiTable_FLICK_TO_HIRAGANA_INTUITIVE = 10002,
  Request_SpecialRomanjiTable_FLICK_TO_HALFWIDTHASCII = 14,
  Request_SpecialRomanjiTable_FLICK_TO_HALFWIDTHASCII_IOS = 44,
  Request_SpecialRomanjiTable_FLICK_TO_NUMBER = 43,
  Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HIRAGANA = 16,
  Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE = 10001,
  Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_NUMBER = 42,
  Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS = 45,
  Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HALFWIDTHASCII = 17,
  Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HIRAGANA = 20,
  Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HALFWIDTHASCII = 22,
  Request_SpecialRomanjiTable_GODAN_TO_HIRAGANA = 30,
  Request_SpecialRomanjiTable_GODAN_TO_HALFWIDTHASCII = 31,
  Request_SpecialRomanjiTable_NOTOUCH_TO_HIRAGANA = 40,
  Request_SpecialRomanjiTable_NOTOUCH_TO_HALFWIDTHASCII = 41
};
bool Request_SpecialRomanjiTable_IsValid(int value);
constexpr Request_SpecialRomanjiTable Request_SpecialRomanjiTable_SpecialRomanjiTable_MIN = Request_SpecialRomanjiTable_DEFAULT_TABLE;
constexpr Request_SpecialRomanjiTable Request_SpecialRomanjiTable_SpecialRomanjiTable_MAX = Request_SpecialRomanjiTable_FLICK_TO_HIRAGANA_INTUITIVE;
constexpr int Request_SpecialRomanjiTable_SpecialRomanjiTable_ARRAYSIZE = Request_SpecialRomanjiTable_SpecialRomanjiTable_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_SpecialRomanjiTable_descriptor();
template<typename T>
inline const std::string& Request_SpecialRomanjiTable_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_SpecialRomanjiTable>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_SpecialRomanjiTable_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_SpecialRomanjiTable_descriptor(), enum_t_value);
}
inline bool Request_SpecialRomanjiTable_Parse(
    const std::string& name, Request_SpecialRomanjiTable* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_SpecialRomanjiTable>(
    Request_SpecialRomanjiTable_descriptor(), name, value);
}
enum Request_SpaceOnAlphanumeric : int {
  Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_KEEPING_COMPOSITION = 0,
  Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_COMMITING_COMPOSITION = 1,
  Request_SpaceOnAlphanumeric_COMMIT = 2
};
bool Request_SpaceOnAlphanumeric_IsValid(int value);
constexpr Request_SpaceOnAlphanumeric Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MIN = Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_KEEPING_COMPOSITION;
constexpr Request_SpaceOnAlphanumeric Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MAX = Request_SpaceOnAlphanumeric_COMMIT;
constexpr int Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_ARRAYSIZE = Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_SpaceOnAlphanumeric_descriptor();
template<typename T>
inline const std::string& Request_SpaceOnAlphanumeric_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_SpaceOnAlphanumeric>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_SpaceOnAlphanumeric_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_SpaceOnAlphanumeric_descriptor(), enum_t_value);
}
inline bool Request_SpaceOnAlphanumeric_Parse(
    const std::string& name, Request_SpaceOnAlphanumeric* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_SpaceOnAlphanumeric>(
    Request_SpaceOnAlphanumeric_descriptor(), name, value);
}
enum Request_EmojiCarrierType : int {
  Request_EmojiCarrierType_UNICODE_EMOJI = 1,
  Request_EmojiCarrierType_DOCOMO_EMOJI = 2,
  Request_EmojiCarrierType_SOFTBANK_EMOJI = 4,
  Request_EmojiCarrierType_KDDI_EMOJI = 8
};
bool Request_EmojiCarrierType_IsValid(int value);
constexpr Request_EmojiCarrierType Request_EmojiCarrierType_EmojiCarrierType_MIN = Request_EmojiCarrierType_UNICODE_EMOJI;
constexpr Request_EmojiCarrierType Request_EmojiCarrierType_EmojiCarrierType_MAX = Request_EmojiCarrierType_KDDI_EMOJI;
constexpr int Request_EmojiCarrierType_EmojiCarrierType_ARRAYSIZE = Request_EmojiCarrierType_EmojiCarrierType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_EmojiCarrierType_descriptor();
template<typename T>
inline const std::string& Request_EmojiCarrierType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_EmojiCarrierType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_EmojiCarrierType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_EmojiCarrierType_descriptor(), enum_t_value);
}
inline bool Request_EmojiCarrierType_Parse(
    const std::string& name, Request_EmojiCarrierType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_EmojiCarrierType>(
    Request_EmojiCarrierType_descriptor(), name, value);
}
enum Request_RewriterCapability : int {
  Request_RewriterCapability_NOT_AVAILABLE = 0,
  Request_RewriterCapability_CONVERSION = 1,
  Request_RewriterCapability_PREDICTION = 2,
  Request_RewriterCapability_SUGGESTION = 4,
  Request_RewriterCapability_ALL = 7
};
bool Request_RewriterCapability_IsValid(int value);
constexpr Request_RewriterCapability Request_RewriterCapability_RewriterCapability_MIN = Request_RewriterCapability_NOT_AVAILABLE;
constexpr Request_RewriterCapability Request_RewriterCapability_RewriterCapability_MAX = Request_RewriterCapability_ALL;
constexpr int Request_RewriterCapability_RewriterCapability_ARRAYSIZE = Request_RewriterCapability_RewriterCapability_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_RewriterCapability_descriptor();
template<typename T>
inline const std::string& Request_RewriterCapability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_RewriterCapability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_RewriterCapability_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_RewriterCapability_descriptor(), enum_t_value);
}
inline bool Request_RewriterCapability_Parse(
    const std::string& name, Request_RewriterCapability* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_RewriterCapability>(
    Request_RewriterCapability_descriptor(), name, value);
}
enum Request_CrossingEdgeBehavior : int {
  Request_CrossingEdgeBehavior_DO_NOTHING = 0,
  Request_CrossingEdgeBehavior_COMMIT_WITHOUT_CONSUMING = 1
};
bool Request_CrossingEdgeBehavior_IsValid(int value);
constexpr Request_CrossingEdgeBehavior Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MIN = Request_CrossingEdgeBehavior_DO_NOTHING;
constexpr Request_CrossingEdgeBehavior Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MAX = Request_CrossingEdgeBehavior_COMMIT_WITHOUT_CONSUMING;
constexpr int Request_CrossingEdgeBehavior_CrossingEdgeBehavior_ARRAYSIZE = Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_CrossingEdgeBehavior_descriptor();
template<typename T>
inline const std::string& Request_CrossingEdgeBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_CrossingEdgeBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_CrossingEdgeBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_CrossingEdgeBehavior_descriptor(), enum_t_value);
}
inline bool Request_CrossingEdgeBehavior_Parse(
    const std::string& name, Request_CrossingEdgeBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_CrossingEdgeBehavior>(
    Request_CrossingEdgeBehavior_descriptor(), name, value);
}
enum Request_LanguageAwareInputBehavior : int {
  Request_LanguageAwareInputBehavior_DEFAULT_LANGUAGE_AWARE_BEHAVIOR = 0,
  Request_LanguageAwareInputBehavior_NO_LANGUAGE_AWARE_INPUT = 1,
  Request_LanguageAwareInputBehavior_LANGUAGE_AWARE_SUGGESTION = 2
};
bool Request_LanguageAwareInputBehavior_IsValid(int value);
constexpr Request_LanguageAwareInputBehavior Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MIN = Request_LanguageAwareInputBehavior_DEFAULT_LANGUAGE_AWARE_BEHAVIOR;
constexpr Request_LanguageAwareInputBehavior Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MAX = Request_LanguageAwareInputBehavior_LANGUAGE_AWARE_SUGGESTION;
constexpr int Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_ARRAYSIZE = Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_LanguageAwareInputBehavior_descriptor();
template<typename T>
inline const std::string& Request_LanguageAwareInputBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_LanguageAwareInputBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_LanguageAwareInputBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_LanguageAwareInputBehavior_descriptor(), enum_t_value);
}
inline bool Request_LanguageAwareInputBehavior_Parse(
    const std::string& name, Request_LanguageAwareInputBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_LanguageAwareInputBehavior>(
    Request_LanguageAwareInputBehavior_descriptor(), name, value);
}
enum Input_CommandType : int {
  Input_CommandType_NONE = 0,
  Input_CommandType_CREATE_SESSION = 1,
  Input_CommandType_DELETE_SESSION = 2,
  Input_CommandType_SEND_KEY = 3,
  Input_CommandType_TEST_SEND_KEY = 4,
  Input_CommandType_SEND_COMMAND = 5,
  Input_CommandType_GET_CONFIG = 6,
  Input_CommandType_SET_CONFIG = 7,
  Input_CommandType_SET_IMPOSED_CONFIG = 22,
  Input_CommandType_SET_REQUEST = 17,
  Input_CommandType_SYNC_DATA = 8,
  Input_CommandType_SHUTDOWN = 9,
  Input_CommandType_RELOAD = 10,
  Input_CommandType_CLEAR_USER_HISTORY = 11,
  Input_CommandType_CLEAR_USER_PREDICTION = 12,
  Input_CommandType_CLEAR_UNUSED_USER_PREDICTION = 16,
  Input_CommandType_CLEANUP = 13,
  Input_CommandType_NO_OPERATION = 14,
  Input_CommandType_SEND_USER_DICTIONARY_COMMAND = 26,
  Input_CommandType_SEND_ENGINE_RELOAD_REQUEST = 27,
  Input_CommandType_NUM_OF_COMMANDS = 28
};
bool Input_CommandType_IsValid(int value);
constexpr Input_CommandType Input_CommandType_CommandType_MIN = Input_CommandType_NONE;
constexpr Input_CommandType Input_CommandType_CommandType_MAX = Input_CommandType_NUM_OF_COMMANDS;
constexpr int Input_CommandType_CommandType_ARRAYSIZE = Input_CommandType_CommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Input_CommandType_descriptor();
template<typename T>
inline const std::string& Input_CommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Input_CommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Input_CommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Input_CommandType_descriptor(), enum_t_value);
}
inline bool Input_CommandType_Parse(
    const std::string& name, Input_CommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Input_CommandType>(
    Input_CommandType_descriptor(), name, value);
}
enum Input_TouchAction : int {
  Input_TouchAction_TOUCH_DOWN = 1,
  Input_TouchAction_TOUCH_MOVE = 2,
  Input_TouchAction_TOUCH_UP = 3
};
bool Input_TouchAction_IsValid(int value);
constexpr Input_TouchAction Input_TouchAction_TouchAction_MIN = Input_TouchAction_TOUCH_DOWN;
constexpr Input_TouchAction Input_TouchAction_TouchAction_MAX = Input_TouchAction_TOUCH_UP;
constexpr int Input_TouchAction_TouchAction_ARRAYSIZE = Input_TouchAction_TouchAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Input_TouchAction_descriptor();
template<typename T>
inline const std::string& Input_TouchAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Input_TouchAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Input_TouchAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Input_TouchAction_descriptor(), enum_t_value);
}
inline bool Input_TouchAction_Parse(
    const std::string& name, Input_TouchAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Input_TouchAction>(
    Input_TouchAction_descriptor(), name, value);
}
enum Result_ResultType : int {
  Result_ResultType_NONE = 0,
  Result_ResultType_STRING = 1
};
bool Result_ResultType_IsValid(int value);
constexpr Result_ResultType Result_ResultType_ResultType_MIN = Result_ResultType_NONE;
constexpr Result_ResultType Result_ResultType_ResultType_MAX = Result_ResultType_STRING;
constexpr int Result_ResultType_ResultType_ARRAYSIZE = Result_ResultType_ResultType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_ResultType_descriptor();
template<typename T>
inline const std::string& Result_ResultType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Result_ResultType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Result_ResultType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Result_ResultType_descriptor(), enum_t_value);
}
inline bool Result_ResultType_Parse(
    const std::string& name, Result_ResultType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Result_ResultType>(
    Result_ResultType_descriptor(), name, value);
}
enum Preedit_Segment_Annotation : int {
  Preedit_Segment_Annotation_NONE = 0,
  Preedit_Segment_Annotation_UNDERLINE = 1,
  Preedit_Segment_Annotation_HIGHLIGHT = 2
};
bool Preedit_Segment_Annotation_IsValid(int value);
constexpr Preedit_Segment_Annotation Preedit_Segment_Annotation_Annotation_MIN = Preedit_Segment_Annotation_NONE;
constexpr Preedit_Segment_Annotation Preedit_Segment_Annotation_Annotation_MAX = Preedit_Segment_Annotation_HIGHLIGHT;
constexpr int Preedit_Segment_Annotation_Annotation_ARRAYSIZE = Preedit_Segment_Annotation_Annotation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Preedit_Segment_Annotation_descriptor();
template<typename T>
inline const std::string& Preedit_Segment_Annotation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Preedit_Segment_Annotation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Preedit_Segment_Annotation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Preedit_Segment_Annotation_descriptor(), enum_t_value);
}
inline bool Preedit_Segment_Annotation_Parse(
    const std::string& name, Preedit_Segment_Annotation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Preedit_Segment_Annotation>(
    Preedit_Segment_Annotation_descriptor(), name, value);
}
enum Output_PreeditMethod : int {
  Output_PreeditMethod_ASCII = 0,
  Output_PreeditMethod_KANA = 1
};
bool Output_PreeditMethod_IsValid(int value);
constexpr Output_PreeditMethod Output_PreeditMethod_PreeditMethod_MIN = Output_PreeditMethod_ASCII;
constexpr Output_PreeditMethod Output_PreeditMethod_PreeditMethod_MAX = Output_PreeditMethod_KANA;
constexpr int Output_PreeditMethod_PreeditMethod_ARRAYSIZE = Output_PreeditMethod_PreeditMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Output_PreeditMethod_descriptor();
template<typename T>
inline const std::string& Output_PreeditMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Output_PreeditMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Output_PreeditMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Output_PreeditMethod_descriptor(), enum_t_value);
}
inline bool Output_PreeditMethod_Parse(
    const std::string& name, Output_PreeditMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Output_PreeditMethod>(
    Output_PreeditMethod_descriptor(), name, value);
}
enum Output_ErrorCode : int {
  Output_ErrorCode_SESSION_SUCCESS = 0,
  Output_ErrorCode_SESSION_FAILURE = 1
};
bool Output_ErrorCode_IsValid(int value);
constexpr Output_ErrorCode Output_ErrorCode_ErrorCode_MIN = Output_ErrorCode_SESSION_SUCCESS;
constexpr Output_ErrorCode Output_ErrorCode_ErrorCode_MAX = Output_ErrorCode_SESSION_FAILURE;
constexpr int Output_ErrorCode_ErrorCode_ARRAYSIZE = Output_ErrorCode_ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Output_ErrorCode_descriptor();
template<typename T>
inline const std::string& Output_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Output_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Output_ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Output_ErrorCode_descriptor(), enum_t_value);
}
inline bool Output_ErrorCode_Parse(
    const std::string& name, Output_ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Output_ErrorCode>(
    Output_ErrorCode_descriptor(), name, value);
}
enum Output_ToolMode : int {
  Output_ToolMode_NO_TOOL = 0,
  Output_ToolMode_CONFIG_DIALOG = 1,
  Output_ToolMode_DICTIONARY_TOOL = 2,
  Output_ToolMode_WORD_REGISTER_DIALOG = 3
};
bool Output_ToolMode_IsValid(int value);
constexpr Output_ToolMode Output_ToolMode_ToolMode_MIN = Output_ToolMode_NO_TOOL;
constexpr Output_ToolMode Output_ToolMode_ToolMode_MAX = Output_ToolMode_WORD_REGISTER_DIALOG;
constexpr int Output_ToolMode_ToolMode_ARRAYSIZE = Output_ToolMode_ToolMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Output_ToolMode_descriptor();
template<typename T>
inline const std::string& Output_ToolMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Output_ToolMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Output_ToolMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Output_ToolMode_descriptor(), enum_t_value);
}
inline bool Output_ToolMode_Parse(
    const std::string& name, Output_ToolMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Output_ToolMode>(
    Output_ToolMode_descriptor(), name, value);
}
enum CompositionMode : int {
  DIRECT = 0,
  HIRAGANA = 1,
  FULL_KATAKANA = 2,
  HALF_ASCII = 3,
  FULL_ASCII = 4,
  HALF_KATAKANA = 5,
  NUM_OF_COMPOSITIONS = 6
};
bool CompositionMode_IsValid(int value);
constexpr CompositionMode CompositionMode_MIN = DIRECT;
constexpr CompositionMode CompositionMode_MAX = NUM_OF_COMPOSITIONS;
constexpr int CompositionMode_ARRAYSIZE = CompositionMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompositionMode_descriptor();
template<typename T>
inline const std::string& CompositionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompositionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompositionMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompositionMode_descriptor(), enum_t_value);
}
inline bool CompositionMode_Parse(
    const std::string& name, CompositionMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompositionMode>(
    CompositionMode_descriptor(), name, value);
}
// ===================================================================

class KeyEvent_ProbableKeyEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.KeyEvent.ProbableKeyEvent) */ {
 public:
  inline KeyEvent_ProbableKeyEvent() : KeyEvent_ProbableKeyEvent(nullptr) {};
  virtual ~KeyEvent_ProbableKeyEvent();

  KeyEvent_ProbableKeyEvent(const KeyEvent_ProbableKeyEvent& from);
  KeyEvent_ProbableKeyEvent(KeyEvent_ProbableKeyEvent&& from) noexcept
    : KeyEvent_ProbableKeyEvent() {
    *this = ::std::move(from);
  }

  inline KeyEvent_ProbableKeyEvent& operator=(const KeyEvent_ProbableKeyEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyEvent_ProbableKeyEvent& operator=(KeyEvent_ProbableKeyEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeyEvent_ProbableKeyEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyEvent_ProbableKeyEvent* internal_default_instance() {
    return reinterpret_cast<const KeyEvent_ProbableKeyEvent*>(
               &_KeyEvent_ProbableKeyEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(KeyEvent_ProbableKeyEvent& a, KeyEvent_ProbableKeyEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyEvent_ProbableKeyEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyEvent_ProbableKeyEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyEvent_ProbableKeyEvent* New() const final {
    return CreateMaybeMessage<KeyEvent_ProbableKeyEvent>(nullptr);
  }

  KeyEvent_ProbableKeyEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyEvent_ProbableKeyEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyEvent_ProbableKeyEvent& from);
  void MergeFrom(const KeyEvent_ProbableKeyEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyEvent_ProbableKeyEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.KeyEvent.ProbableKeyEvent";
  }
  protected:
  explicit KeyEvent_ProbableKeyEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModifierKeysFieldNumber = 4,
    kKeyCodeFieldNumber = 1,
    kSpecialKeyFieldNumber = 3,
    kProbabilityFieldNumber = 10,
  };
  // repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
  int modifier_keys_size() const;
  private:
  int _internal_modifier_keys_size() const;
  public:
  void clear_modifier_keys();
  private:
  ::mozc::commands::KeyEvent_ModifierKey _internal_modifier_keys(int index) const;
  void _internal_add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_modifier_keys();
  public:
  ::mozc::commands::KeyEvent_ModifierKey modifier_keys(int index) const;
  void set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value);
  void add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& modifier_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_modifier_keys();

  // optional uint32 key_code = 1;
  bool has_key_code() const;
  private:
  bool _internal_has_key_code() const;
  public:
  void clear_key_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 key_code() const;
  void set_key_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_key_code() const;
  void _internal_set_key_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
  bool has_special_key() const;
  private:
  bool _internal_has_special_key() const;
  public:
  void clear_special_key();
  ::mozc::commands::KeyEvent_SpecialKey special_key() const;
  void set_special_key(::mozc::commands::KeyEvent_SpecialKey value);
  private:
  ::mozc::commands::KeyEvent_SpecialKey _internal_special_key() const;
  void _internal_set_special_key(::mozc::commands::KeyEvent_SpecialKey value);
  public:

  // optional double probability = 10;
  bool has_probability() const;
  private:
  bool _internal_has_probability() const;
  public:
  void clear_probability();
  double probability() const;
  void set_probability(double value);
  private:
  double _internal_probability() const;
  void _internal_set_probability(double value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.KeyEvent.ProbableKeyEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> modifier_keys_;
  ::PROTOBUF_NAMESPACE_ID::uint32 key_code_;
  int special_key_;
  double probability_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class KeyEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.KeyEvent) */ {
 public:
  inline KeyEvent() : KeyEvent(nullptr) {};
  virtual ~KeyEvent();

  KeyEvent(const KeyEvent& from);
  KeyEvent(KeyEvent&& from) noexcept
    : KeyEvent() {
    *this = ::std::move(from);
  }

  inline KeyEvent& operator=(const KeyEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyEvent& operator=(KeyEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeyEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyEvent* internal_default_instance() {
    return reinterpret_cast<const KeyEvent*>(
               &_KeyEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(KeyEvent& a, KeyEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyEvent* New() const final {
    return CreateMaybeMessage<KeyEvent>(nullptr);
  }

  KeyEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyEvent& from);
  void MergeFrom(const KeyEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.KeyEvent";
  }
  protected:
  explicit KeyEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef KeyEvent_ProbableKeyEvent ProbableKeyEvent;

  typedef KeyEvent_SpecialKey SpecialKey;
  static constexpr SpecialKey NO_SPECIALKEY =
    KeyEvent_SpecialKey_NO_SPECIALKEY;
  static constexpr SpecialKey DIGIT =
    KeyEvent_SpecialKey_DIGIT;
  static constexpr SpecialKey ON =
    KeyEvent_SpecialKey_ON;
  static constexpr SpecialKey OFF =
    KeyEvent_SpecialKey_OFF;
  static constexpr SpecialKey SPACE =
    KeyEvent_SpecialKey_SPACE;
  static constexpr SpecialKey ENTER =
    KeyEvent_SpecialKey_ENTER;
  static constexpr SpecialKey LEFT =
    KeyEvent_SpecialKey_LEFT;
  static constexpr SpecialKey RIGHT =
    KeyEvent_SpecialKey_RIGHT;
  static constexpr SpecialKey UP =
    KeyEvent_SpecialKey_UP;
  static constexpr SpecialKey DOWN =
    KeyEvent_SpecialKey_DOWN;
  static constexpr SpecialKey ESCAPE =
    KeyEvent_SpecialKey_ESCAPE;
  static constexpr SpecialKey DEL =
    KeyEvent_SpecialKey_DEL;
  static constexpr SpecialKey BACKSPACE =
    KeyEvent_SpecialKey_BACKSPACE;
  static constexpr SpecialKey HENKAN =
    KeyEvent_SpecialKey_HENKAN;
  static constexpr SpecialKey MUHENKAN =
    KeyEvent_SpecialKey_MUHENKAN;
  static constexpr SpecialKey KANA =
    KeyEvent_SpecialKey_KANA;
  static constexpr SpecialKey HOME =
    KeyEvent_SpecialKey_HOME;
  static constexpr SpecialKey END =
    KeyEvent_SpecialKey_END;
  static constexpr SpecialKey TAB =
    KeyEvent_SpecialKey_TAB;
  static constexpr SpecialKey F1 =
    KeyEvent_SpecialKey_F1;
  static constexpr SpecialKey F2 =
    KeyEvent_SpecialKey_F2;
  static constexpr SpecialKey F3 =
    KeyEvent_SpecialKey_F3;
  static constexpr SpecialKey F4 =
    KeyEvent_SpecialKey_F4;
  static constexpr SpecialKey F5 =
    KeyEvent_SpecialKey_F5;
  static constexpr SpecialKey F6 =
    KeyEvent_SpecialKey_F6;
  static constexpr SpecialKey F7 =
    KeyEvent_SpecialKey_F7;
  static constexpr SpecialKey F8 =
    KeyEvent_SpecialKey_F8;
  static constexpr SpecialKey F9 =
    KeyEvent_SpecialKey_F9;
  static constexpr SpecialKey F10 =
    KeyEvent_SpecialKey_F10;
  static constexpr SpecialKey F11 =
    KeyEvent_SpecialKey_F11;
  static constexpr SpecialKey F12 =
    KeyEvent_SpecialKey_F12;
  static constexpr SpecialKey PAGE_UP =
    KeyEvent_SpecialKey_PAGE_UP;
  static constexpr SpecialKey PAGE_DOWN =
    KeyEvent_SpecialKey_PAGE_DOWN;
  static constexpr SpecialKey INSERT =
    KeyEvent_SpecialKey_INSERT;
  static constexpr SpecialKey F13 =
    KeyEvent_SpecialKey_F13;
  static constexpr SpecialKey F14 =
    KeyEvent_SpecialKey_F14;
  static constexpr SpecialKey F15 =
    KeyEvent_SpecialKey_F15;
  static constexpr SpecialKey F16 =
    KeyEvent_SpecialKey_F16;
  static constexpr SpecialKey F17 =
    KeyEvent_SpecialKey_F17;
  static constexpr SpecialKey F18 =
    KeyEvent_SpecialKey_F18;
  static constexpr SpecialKey F19 =
    KeyEvent_SpecialKey_F19;
  static constexpr SpecialKey F20 =
    KeyEvent_SpecialKey_F20;
  static constexpr SpecialKey F21 =
    KeyEvent_SpecialKey_F21;
  static constexpr SpecialKey F22 =
    KeyEvent_SpecialKey_F22;
  static constexpr SpecialKey F23 =
    KeyEvent_SpecialKey_F23;
  static constexpr SpecialKey F24 =
    KeyEvent_SpecialKey_F24;
  static constexpr SpecialKey EISU =
    KeyEvent_SpecialKey_EISU;
  static constexpr SpecialKey NUMPAD0 =
    KeyEvent_SpecialKey_NUMPAD0;
  static constexpr SpecialKey NUMPAD1 =
    KeyEvent_SpecialKey_NUMPAD1;
  static constexpr SpecialKey NUMPAD2 =
    KeyEvent_SpecialKey_NUMPAD2;
  static constexpr SpecialKey NUMPAD3 =
    KeyEvent_SpecialKey_NUMPAD3;
  static constexpr SpecialKey NUMPAD4 =
    KeyEvent_SpecialKey_NUMPAD4;
  static constexpr SpecialKey NUMPAD5 =
    KeyEvent_SpecialKey_NUMPAD5;
  static constexpr SpecialKey NUMPAD6 =
    KeyEvent_SpecialKey_NUMPAD6;
  static constexpr SpecialKey NUMPAD7 =
    KeyEvent_SpecialKey_NUMPAD7;
  static constexpr SpecialKey NUMPAD8 =
    KeyEvent_SpecialKey_NUMPAD8;
  static constexpr SpecialKey NUMPAD9 =
    KeyEvent_SpecialKey_NUMPAD9;
  static constexpr SpecialKey MULTIPLY =
    KeyEvent_SpecialKey_MULTIPLY;
  static constexpr SpecialKey ADD =
    KeyEvent_SpecialKey_ADD;
  static constexpr SpecialKey SEPARATOR =
    KeyEvent_SpecialKey_SEPARATOR;
  static constexpr SpecialKey SUBTRACT =
    KeyEvent_SpecialKey_SUBTRACT;
  static constexpr SpecialKey DECIMAL =
    KeyEvent_SpecialKey_DECIMAL;
  static constexpr SpecialKey DIVIDE =
    KeyEvent_SpecialKey_DIVIDE;
  static constexpr SpecialKey EQUALS =
    KeyEvent_SpecialKey_EQUALS;
  static constexpr SpecialKey TEXT_INPUT =
    KeyEvent_SpecialKey_TEXT_INPUT;
  static constexpr SpecialKey HANKAKU =
    KeyEvent_SpecialKey_HANKAKU;
  static constexpr SpecialKey KANJI =
    KeyEvent_SpecialKey_KANJI;
  static constexpr SpecialKey KATAKANA =
    KeyEvent_SpecialKey_KATAKANA;
  static constexpr SpecialKey CAPS_LOCK =
    KeyEvent_SpecialKey_CAPS_LOCK;
  static constexpr SpecialKey UNDEFINED_KEY =
    KeyEvent_SpecialKey_UNDEFINED_KEY;
  static constexpr SpecialKey COMMA =
    KeyEvent_SpecialKey_COMMA;
  static constexpr SpecialKey CLEAR =
    KeyEvent_SpecialKey_CLEAR;
  static constexpr SpecialKey VIRTUAL_LEFT =
    KeyEvent_SpecialKey_VIRTUAL_LEFT;
  static constexpr SpecialKey VIRTUAL_RIGHT =
    KeyEvent_SpecialKey_VIRTUAL_RIGHT;
  static constexpr SpecialKey VIRTUAL_ENTER =
    KeyEvent_SpecialKey_VIRTUAL_ENTER;
  static constexpr SpecialKey VIRTUAL_UP =
    KeyEvent_SpecialKey_VIRTUAL_UP;
  static constexpr SpecialKey VIRTUAL_DOWN =
    KeyEvent_SpecialKey_VIRTUAL_DOWN;
  static constexpr SpecialKey NUM_SPECIALKEYS =
    KeyEvent_SpecialKey_NUM_SPECIALKEYS;
  static inline bool SpecialKey_IsValid(int value) {
    return KeyEvent_SpecialKey_IsValid(value);
  }
  static constexpr SpecialKey SpecialKey_MIN =
    KeyEvent_SpecialKey_SpecialKey_MIN;
  static constexpr SpecialKey SpecialKey_MAX =
    KeyEvent_SpecialKey_SpecialKey_MAX;
  static constexpr int SpecialKey_ARRAYSIZE =
    KeyEvent_SpecialKey_SpecialKey_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SpecialKey_descriptor() {
    return KeyEvent_SpecialKey_descriptor();
  }
  template<typename T>
  static inline const std::string& SpecialKey_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SpecialKey>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SpecialKey_Name.");
    return KeyEvent_SpecialKey_Name(enum_t_value);
  }
  static inline bool SpecialKey_Parse(const std::string& name,
      SpecialKey* value) {
    return KeyEvent_SpecialKey_Parse(name, value);
  }

  typedef KeyEvent_ModifierKey ModifierKey;
  static constexpr ModifierKey CTRL =
    KeyEvent_ModifierKey_CTRL;
  static constexpr ModifierKey ALT =
    KeyEvent_ModifierKey_ALT;
  static constexpr ModifierKey SHIFT =
    KeyEvent_ModifierKey_SHIFT;
  static constexpr ModifierKey KEY_DOWN =
    KeyEvent_ModifierKey_KEY_DOWN;
  static constexpr ModifierKey KEY_UP =
    KeyEvent_ModifierKey_KEY_UP;
  static constexpr ModifierKey LEFT_CTRL =
    KeyEvent_ModifierKey_LEFT_CTRL;
  static constexpr ModifierKey LEFT_ALT =
    KeyEvent_ModifierKey_LEFT_ALT;
  static constexpr ModifierKey LEFT_SHIFT =
    KeyEvent_ModifierKey_LEFT_SHIFT;
  static constexpr ModifierKey RIGHT_CTRL =
    KeyEvent_ModifierKey_RIGHT_CTRL;
  static constexpr ModifierKey RIGHT_ALT =
    KeyEvent_ModifierKey_RIGHT_ALT;
  static constexpr ModifierKey RIGHT_SHIFT =
    KeyEvent_ModifierKey_RIGHT_SHIFT;
  static constexpr ModifierKey CAPS =
    KeyEvent_ModifierKey_CAPS;
  static inline bool ModifierKey_IsValid(int value) {
    return KeyEvent_ModifierKey_IsValid(value);
  }
  static constexpr ModifierKey ModifierKey_MIN =
    KeyEvent_ModifierKey_ModifierKey_MIN;
  static constexpr ModifierKey ModifierKey_MAX =
    KeyEvent_ModifierKey_ModifierKey_MAX;
  static constexpr int ModifierKey_ARRAYSIZE =
    KeyEvent_ModifierKey_ModifierKey_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ModifierKey_descriptor() {
    return KeyEvent_ModifierKey_descriptor();
  }
  template<typename T>
  static inline const std::string& ModifierKey_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ModifierKey>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ModifierKey_Name.");
    return KeyEvent_ModifierKey_Name(enum_t_value);
  }
  static inline bool ModifierKey_Parse(const std::string& name,
      ModifierKey* value) {
    return KeyEvent_ModifierKey_Parse(name, value);
  }

  typedef KeyEvent_InputStyle InputStyle;
  static constexpr InputStyle FOLLOW_MODE =
    KeyEvent_InputStyle_FOLLOW_MODE;
  static constexpr InputStyle AS_IS =
    KeyEvent_InputStyle_AS_IS;
  static constexpr InputStyle DIRECT_INPUT =
    KeyEvent_InputStyle_DIRECT_INPUT;
  static inline bool InputStyle_IsValid(int value) {
    return KeyEvent_InputStyle_IsValid(value);
  }
  static constexpr InputStyle InputStyle_MIN =
    KeyEvent_InputStyle_InputStyle_MIN;
  static constexpr InputStyle InputStyle_MAX =
    KeyEvent_InputStyle_InputStyle_MAX;
  static constexpr int InputStyle_ARRAYSIZE =
    KeyEvent_InputStyle_InputStyle_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InputStyle_descriptor() {
    return KeyEvent_InputStyle_descriptor();
  }
  template<typename T>
  static inline const std::string& InputStyle_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InputStyle>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InputStyle_Name.");
    return KeyEvent_InputStyle_Name(enum_t_value);
  }
  static inline bool InputStyle_Parse(const std::string& name,
      InputStyle* value) {
    return KeyEvent_InputStyle_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModifierKeysFieldNumber = 4,
    kProbableKeyEventFieldNumber = 8,
    kKeyStringFieldNumber = 5,
    kKeyCodeFieldNumber = 1,
    kModifiersFieldNumber = 2,
    kSpecialKeyFieldNumber = 3,
    kInputStyleFieldNumber = 6,
    kModeFieldNumber = 7,
    kActivatedFieldNumber = 9,
  };
  // repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
  int modifier_keys_size() const;
  private:
  int _internal_modifier_keys_size() const;
  public:
  void clear_modifier_keys();
  private:
  ::mozc::commands::KeyEvent_ModifierKey _internal_modifier_keys(int index) const;
  void _internal_add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_modifier_keys();
  public:
  ::mozc::commands::KeyEvent_ModifierKey modifier_keys(int index) const;
  void set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value);
  void add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& modifier_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_modifier_keys();

  // repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;
  int probable_key_event_size() const;
  private:
  int _internal_probable_key_event_size() const;
  public:
  void clear_probable_key_event();
  ::mozc::commands::KeyEvent_ProbableKeyEvent* mutable_probable_key_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >*
      mutable_probable_key_event();
  private:
  const ::mozc::commands::KeyEvent_ProbableKeyEvent& _internal_probable_key_event(int index) const;
  ::mozc::commands::KeyEvent_ProbableKeyEvent* _internal_add_probable_key_event();
  public:
  const ::mozc::commands::KeyEvent_ProbableKeyEvent& probable_key_event(int index) const;
  ::mozc::commands::KeyEvent_ProbableKeyEvent* add_probable_key_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >&
      probable_key_event() const;

  // optional string key_string = 5;
  bool has_key_string() const;
  private:
  bool _internal_has_key_string() const;
  public:
  void clear_key_string();
  const std::string& key_string() const;
  void set_key_string(const std::string& value);
  void set_key_string(std::string&& value);
  void set_key_string(const char* value);
  void set_key_string(const char* value, size_t size);
  std::string* mutable_key_string();
  std::string* release_key_string();
  void set_allocated_key_string(std::string* key_string);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key_string();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key_string(
      std::string* key_string);
  private:
  const std::string& _internal_key_string() const;
  void _internal_set_key_string(const std::string& value);
  std::string* _internal_mutable_key_string();
  public:

  // optional uint32 key_code = 1;
  bool has_key_code() const;
  private:
  bool _internal_has_key_code() const;
  public:
  void clear_key_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 key_code() const;
  void set_key_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_key_code() const;
  void _internal_set_key_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 modifiers = 2;
  bool has_modifiers() const;
  private:
  bool _internal_has_modifiers() const;
  public:
  void clear_modifiers();
  ::PROTOBUF_NAMESPACE_ID::uint32 modifiers() const;
  void set_modifiers(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_modifiers() const;
  void _internal_set_modifiers(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
  bool has_special_key() const;
  private:
  bool _internal_has_special_key() const;
  public:
  void clear_special_key();
  ::mozc::commands::KeyEvent_SpecialKey special_key() const;
  void set_special_key(::mozc::commands::KeyEvent_SpecialKey value);
  private:
  ::mozc::commands::KeyEvent_SpecialKey _internal_special_key() const;
  void _internal_set_special_key(::mozc::commands::KeyEvent_SpecialKey value);
  public:

  // optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];
  bool has_input_style() const;
  private:
  bool _internal_has_input_style() const;
  public:
  void clear_input_style();
  ::mozc::commands::KeyEvent_InputStyle input_style() const;
  void set_input_style(::mozc::commands::KeyEvent_InputStyle value);
  private:
  ::mozc::commands::KeyEvent_InputStyle _internal_input_style() const;
  void _internal_set_input_style(::mozc::commands::KeyEvent_InputStyle value);
  public:

  // optional .mozc.commands.CompositionMode mode = 7;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::mozc::commands::CompositionMode mode() const;
  void set_mode(::mozc::commands::CompositionMode value);
  private:
  ::mozc::commands::CompositionMode _internal_mode() const;
  void _internal_set_mode(::mozc::commands::CompositionMode value);
  public:

  // optional bool activated = 9;
  bool has_activated() const;
  private:
  bool _internal_has_activated() const;
  public:
  void clear_activated();
  bool activated() const;
  void set_activated(bool value);
  private:
  bool _internal_activated() const;
  void _internal_set_activated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.KeyEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> modifier_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent > probable_key_event_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_string_;
  ::PROTOBUF_NAMESPACE_ID::uint32 key_code_;
  ::PROTOBUF_NAMESPACE_ID::uint32 modifiers_;
  int special_key_;
  int input_style_;
  int mode_;
  bool activated_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GenericStorageEntry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.GenericStorageEntry) */ {
 public:
  inline GenericStorageEntry() : GenericStorageEntry(nullptr) {};
  virtual ~GenericStorageEntry();

  GenericStorageEntry(const GenericStorageEntry& from);
  GenericStorageEntry(GenericStorageEntry&& from) noexcept
    : GenericStorageEntry() {
    *this = ::std::move(from);
  }

  inline GenericStorageEntry& operator=(const GenericStorageEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericStorageEntry& operator=(GenericStorageEntry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenericStorageEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenericStorageEntry* internal_default_instance() {
    return reinterpret_cast<const GenericStorageEntry*>(
               &_GenericStorageEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GenericStorageEntry& a, GenericStorageEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericStorageEntry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericStorageEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericStorageEntry* New() const final {
    return CreateMaybeMessage<GenericStorageEntry>(nullptr);
  }

  GenericStorageEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericStorageEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenericStorageEntry& from);
  void MergeFrom(const GenericStorageEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericStorageEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.GenericStorageEntry";
  }
  protected:
  explicit GenericStorageEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GenericStorageEntry_StorageType StorageType;
  static constexpr StorageType SYMBOL_HISTORY =
    GenericStorageEntry_StorageType_SYMBOL_HISTORY;
  static constexpr StorageType EMOTICON_HISTORY =
    GenericStorageEntry_StorageType_EMOTICON_HISTORY;
  static constexpr StorageType EMOJI_HISTORY =
    GenericStorageEntry_StorageType_EMOJI_HISTORY;
  static inline bool StorageType_IsValid(int value) {
    return GenericStorageEntry_StorageType_IsValid(value);
  }
  static constexpr StorageType StorageType_MIN =
    GenericStorageEntry_StorageType_StorageType_MIN;
  static constexpr StorageType StorageType_MAX =
    GenericStorageEntry_StorageType_StorageType_MAX;
  static constexpr int StorageType_ARRAYSIZE =
    GenericStorageEntry_StorageType_StorageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StorageType_descriptor() {
    return GenericStorageEntry_StorageType_descriptor();
  }
  template<typename T>
  static inline const std::string& StorageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StorageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StorageType_Name.");
    return GenericStorageEntry_StorageType_Name(enum_t_value);
  }
  static inline bool StorageType_Parse(const std::string& name,
      StorageType* value) {
    return GenericStorageEntry_StorageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kKeyFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated bytes value = 3;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const void* value, size_t size);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value();
  private:
  const std::string& _internal_value(int index) const;
  std::string* _internal_add_value();
  public:

  // optional string key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional .mozc.commands.GenericStorageEntry.StorageType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::mozc::commands::GenericStorageEntry_StorageType type() const;
  void set_type(::mozc::commands::GenericStorageEntry_StorageType value);
  private:
  ::mozc::commands::GenericStorageEntry_StorageType _internal_type() const;
  void _internal_set_type(::mozc::commands::GenericStorageEntry_StorageType value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.GenericStorageEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int type_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class SessionCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.SessionCommand) */ {
 public:
  inline SessionCommand() : SessionCommand(nullptr) {};
  virtual ~SessionCommand();

  SessionCommand(const SessionCommand& from);
  SessionCommand(SessionCommand&& from) noexcept
    : SessionCommand() {
    *this = ::std::move(from);
  }

  inline SessionCommand& operator=(const SessionCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionCommand& operator=(SessionCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionCommand* internal_default_instance() {
    return reinterpret_cast<const SessionCommand*>(
               &_SessionCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SessionCommand& a, SessionCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionCommand* New() const final {
    return CreateMaybeMessage<SessionCommand>(nullptr);
  }

  SessionCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionCommand& from);
  void MergeFrom(const SessionCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.SessionCommand";
  }
  protected:
  explicit SessionCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SessionCommand_CommandType CommandType;
  static constexpr CommandType NONE =
    SessionCommand_CommandType_NONE;
  static constexpr CommandType REVERT =
    SessionCommand_CommandType_REVERT;
  static constexpr CommandType SUBMIT =
    SessionCommand_CommandType_SUBMIT;
  static constexpr CommandType SELECT_CANDIDATE =
    SessionCommand_CommandType_SELECT_CANDIDATE;
  static constexpr CommandType HIGHLIGHT_CANDIDATE =
    SessionCommand_CommandType_HIGHLIGHT_CANDIDATE;
  static constexpr CommandType SWITCH_INPUT_MODE =
    SessionCommand_CommandType_SWITCH_INPUT_MODE;
  static constexpr CommandType GET_STATUS =
    SessionCommand_CommandType_GET_STATUS;
  static constexpr CommandType SUBMIT_CANDIDATE =
    SessionCommand_CommandType_SUBMIT_CANDIDATE;
  static constexpr CommandType CONVERT_REVERSE =
    SessionCommand_CommandType_CONVERT_REVERSE;
  static constexpr CommandType UNDO =
    SessionCommand_CommandType_UNDO;
  static constexpr CommandType RESET_CONTEXT =
    SessionCommand_CommandType_RESET_CONTEXT;
  static constexpr CommandType MOVE_CURSOR =
    SessionCommand_CommandType_MOVE_CURSOR;
  static constexpr CommandType SWITCH_INPUT_FIELD_TYPE =
    SessionCommand_CommandType_SWITCH_INPUT_FIELD_TYPE;
  static constexpr CommandType USAGE_STATS_EVENT =
    SessionCommand_CommandType_USAGE_STATS_EVENT;
  static constexpr CommandType UNDO_OR_REWIND =
    SessionCommand_CommandType_UNDO_OR_REWIND;
  static constexpr CommandType EXPAND_SUGGESTION =
    SessionCommand_CommandType_EXPAND_SUGGESTION;
  static constexpr CommandType COMMIT_RAW_TEXT =
    SessionCommand_CommandType_COMMIT_RAW_TEXT;
  static constexpr CommandType CONVERT_PREV_PAGE =
    SessionCommand_CommandType_CONVERT_PREV_PAGE;
  static constexpr CommandType CONVERT_NEXT_PAGE =
    SessionCommand_CommandType_CONVERT_NEXT_PAGE;
  static constexpr CommandType TURN_ON_IME =
    SessionCommand_CommandType_TURN_ON_IME;
  static constexpr CommandType TURN_OFF_IME =
    SessionCommand_CommandType_TURN_OFF_IME;
  static constexpr CommandType DELETE_CANDIDATE_FROM_HISTORY =
    SessionCommand_CommandType_DELETE_CANDIDATE_FROM_HISTORY;
  static constexpr CommandType STOP_KEY_TOGGLING =
    SessionCommand_CommandType_STOP_KEY_TOGGLING;
  static inline bool CommandType_IsValid(int value) {
    return SessionCommand_CommandType_IsValid(value);
  }
  static constexpr CommandType CommandType_MIN =
    SessionCommand_CommandType_CommandType_MIN;
  static constexpr CommandType CommandType_MAX =
    SessionCommand_CommandType_CommandType_MAX;
  static constexpr int CommandType_ARRAYSIZE =
    SessionCommand_CommandType_CommandType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CommandType_descriptor() {
    return SessionCommand_CommandType_descriptor();
  }
  template<typename T>
  static inline const std::string& CommandType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CommandType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CommandType_Name.");
    return SessionCommand_CommandType_Name(enum_t_value);
  }
  static inline bool CommandType_Parse(const std::string& name,
      CommandType* value) {
    return SessionCommand_CommandType_Parse(name, value);
  }

  typedef SessionCommand_UsageStatsEvent UsageStatsEvent;
  static constexpr UsageStatsEvent INFOLIST_WINDOW_SHOW =
    SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_SHOW;
  static constexpr UsageStatsEvent INFOLIST_WINDOW_HIDE =
    SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_HIDE;
  static constexpr UsageStatsEvent HANDWRITING_OPEN_EVENT =
    SessionCommand_UsageStatsEvent_HANDWRITING_OPEN_EVENT;
  static constexpr UsageStatsEvent HANDWRITING_COMMIT_EVENT =
    SessionCommand_UsageStatsEvent_HANDWRITING_COMMIT_EVENT;
  static constexpr UsageStatsEvent CHARACTER_PALETTE_OPEN_EVENT =
    SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_OPEN_EVENT;
  static constexpr UsageStatsEvent CHARACTER_PALETTE_COMMIT_EVENT =
    SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_COMMIT_EVENT;
  static constexpr UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_LANDSCAPE =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_LANDSCAPE;
  static constexpr UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_PORTRAIT =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_PORTRAIT;
  static constexpr UsageStatsEvent SUBMITTED_CANDIDATE_ROW_0 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_0;
  static constexpr UsageStatsEvent SUBMITTED_CANDIDATE_ROW_1 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_1;
  static constexpr UsageStatsEvent SUBMITTED_CANDIDATE_ROW_2 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_2;
  static constexpr UsageStatsEvent SUBMITTED_CANDIDATE_ROW_3 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_3;
  static constexpr UsageStatsEvent SUBMITTED_CANDIDATE_ROW_4 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_4;
  static constexpr UsageStatsEvent SUBMITTED_CANDIDATE_ROW_5 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_5;
  static constexpr UsageStatsEvent SUBMITTED_CANDIDATE_ROW_6 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_6;
  static constexpr UsageStatsEvent SUBMITTED_CANDIDATE_ROW_7 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_7;
  static constexpr UsageStatsEvent SUBMITTED_CANDIDATE_ROW_8 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_8;
  static constexpr UsageStatsEvent SUBMITTED_CANDIDATE_ROW_9 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_9;
  static constexpr UsageStatsEvent SUBMITTED_CANDIDATE_ROW_GE10 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_GE10;
  static constexpr UsageStatsEvent KEYBOARD_FOLD_EVENT =
    SessionCommand_UsageStatsEvent_KEYBOARD_FOLD_EVENT;
  static constexpr UsageStatsEvent KEYBOARD_EXPAND_EVENT =
    SessionCommand_UsageStatsEvent_KEYBOARD_EXPAND_EVENT;
  static constexpr UsageStatsEvent MUSHROOM_SELECTION_DIALOG_OPEN_EVENT =
    SessionCommand_UsageStatsEvent_MUSHROOM_SELECTION_DIALOG_OPEN_EVENT;
  static constexpr UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_LANDSCAPE =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_LANDSCAPE;
  static constexpr UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_PORTRAIT =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_PORTRAIT;
  static constexpr UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_LANDSCAPE =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_LANDSCAPE;
  static constexpr UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_PORTRAIT =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_PORTRAIT;
  static inline bool UsageStatsEvent_IsValid(int value) {
    return SessionCommand_UsageStatsEvent_IsValid(value);
  }
  static constexpr UsageStatsEvent UsageStatsEvent_MIN =
    SessionCommand_UsageStatsEvent_UsageStatsEvent_MIN;
  static constexpr UsageStatsEvent UsageStatsEvent_MAX =
    SessionCommand_UsageStatsEvent_UsageStatsEvent_MAX;
  static constexpr int UsageStatsEvent_ARRAYSIZE =
    SessionCommand_UsageStatsEvent_UsageStatsEvent_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UsageStatsEvent_descriptor() {
    return SessionCommand_UsageStatsEvent_descriptor();
  }
  template<typename T>
  static inline const std::string& UsageStatsEvent_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UsageStatsEvent>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UsageStatsEvent_Name.");
    return SessionCommand_UsageStatsEvent_Name(enum_t_value);
  }
  static inline bool UsageStatsEvent_Parse(const std::string& name,
      UsageStatsEvent* value) {
    return SessionCommand_UsageStatsEvent_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 4,
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kCompositionModeFieldNumber = 3,
    kCursorPositionFieldNumber = 5,
    kUsageStatsEventIntValueFieldNumber = 9,
    kUsageStatsEventFieldNumber = 7,
  };
  // optional string text = 4;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_text();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_text(
      std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // required .mozc.commands.SessionCommand.CommandType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::mozc::commands::SessionCommand_CommandType type() const;
  void set_type(::mozc::commands::SessionCommand_CommandType value);
  private:
  ::mozc::commands::SessionCommand_CommandType _internal_type() const;
  void _internal_set_type(::mozc::commands::SessionCommand_CommandType value);
  public:

  // optional int32 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .mozc.commands.CompositionMode composition_mode = 3;
  bool has_composition_mode() const;
  private:
  bool _internal_has_composition_mode() const;
  public:
  void clear_composition_mode();
  ::mozc::commands::CompositionMode composition_mode() const;
  void set_composition_mode(::mozc::commands::CompositionMode value);
  private:
  ::mozc::commands::CompositionMode _internal_composition_mode() const;
  void _internal_set_composition_mode(::mozc::commands::CompositionMode value);
  public:

  // optional uint32 cursor_position = 5;
  bool has_cursor_position() const;
  private:
  bool _internal_has_cursor_position() const;
  public:
  void clear_cursor_position();
  ::PROTOBUF_NAMESPACE_ID::uint32 cursor_position() const;
  void set_cursor_position(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_cursor_position() const;
  void _internal_set_cursor_position(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int32 usage_stats_event_int_value = 9;
  bool has_usage_stats_event_int_value() const;
  private:
  bool _internal_has_usage_stats_event_int_value() const;
  public:
  void clear_usage_stats_event_int_value();
  ::PROTOBUF_NAMESPACE_ID::int32 usage_stats_event_int_value() const;
  void set_usage_stats_event_int_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_usage_stats_event_int_value() const;
  void _internal_set_usage_stats_event_int_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .mozc.commands.SessionCommand.UsageStatsEvent usage_stats_event = 7;
  bool has_usage_stats_event() const;
  private:
  bool _internal_has_usage_stats_event() const;
  public:
  void clear_usage_stats_event();
  ::mozc::commands::SessionCommand_UsageStatsEvent usage_stats_event() const;
  void set_usage_stats_event(::mozc::commands::SessionCommand_UsageStatsEvent value);
  private:
  ::mozc::commands::SessionCommand_UsageStatsEvent _internal_usage_stats_event() const;
  void _internal_set_usage_stats_event(::mozc::commands::SessionCommand_UsageStatsEvent value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.SessionCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  int composition_mode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cursor_position_;
  ::PROTOBUF_NAMESPACE_ID::int32 usage_stats_event_int_value_;
  int usage_stats_event_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Context PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Context) */ {
 public:
  inline Context() : Context(nullptr) {};
  virtual ~Context();

  Context(const Context& from);
  Context(Context&& from) noexcept
    : Context() {
    *this = ::std::move(from);
  }

  inline Context& operator=(const Context& from) {
    CopyFrom(from);
    return *this;
  }
  inline Context& operator=(Context&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Context& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Context* internal_default_instance() {
    return reinterpret_cast<const Context*>(
               &_Context_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Context& a, Context& b) {
    a.Swap(&b);
  }
  inline void Swap(Context* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Context* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Context* New() const final {
    return CreateMaybeMessage<Context>(nullptr);
  }

  Context* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Context>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Context& from);
  void MergeFrom(const Context& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Context* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Context";
  }
  protected:
  explicit Context(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Context_InputFieldType InputFieldType;
  static constexpr InputFieldType NORMAL =
    Context_InputFieldType_NORMAL;
  static constexpr InputFieldType PASSWORD =
    Context_InputFieldType_PASSWORD;
  static constexpr InputFieldType TEL =
    Context_InputFieldType_TEL;
  static constexpr InputFieldType NUMBER =
    Context_InputFieldType_NUMBER;
  static inline bool InputFieldType_IsValid(int value) {
    return Context_InputFieldType_IsValid(value);
  }
  static constexpr InputFieldType InputFieldType_MIN =
    Context_InputFieldType_InputFieldType_MIN;
  static constexpr InputFieldType InputFieldType_MAX =
    Context_InputFieldType_InputFieldType_MAX;
  static constexpr int InputFieldType_ARRAYSIZE =
    Context_InputFieldType_InputFieldType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InputFieldType_descriptor() {
    return Context_InputFieldType_descriptor();
  }
  template<typename T>
  static inline const std::string& InputFieldType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InputFieldType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InputFieldType_Name.");
    return Context_InputFieldType_Name(enum_t_value);
  }
  static inline bool InputFieldType_Parse(const std::string& name,
      InputFieldType* value) {
    return Context_InputFieldType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExperimentalFeaturesFieldNumber = 100,
    kPrecedingTextFieldNumber = 1,
    kFollowingTextFieldNumber = 2,
    kSuppressSuggestionFieldNumber = 3,
    kRevisionFieldNumber = 5,
    kInputFieldTypeFieldNumber = 4,
  };
  // repeated string experimental_features = 100;
  int experimental_features_size() const;
  private:
  int _internal_experimental_features_size() const;
  public:
  void clear_experimental_features();
  const std::string& experimental_features(int index) const;
  std::string* mutable_experimental_features(int index);
  void set_experimental_features(int index, const std::string& value);
  void set_experimental_features(int index, std::string&& value);
  void set_experimental_features(int index, const char* value);
  void set_experimental_features(int index, const char* value, size_t size);
  std::string* add_experimental_features();
  void add_experimental_features(const std::string& value);
  void add_experimental_features(std::string&& value);
  void add_experimental_features(const char* value);
  void add_experimental_features(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& experimental_features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_experimental_features();
  private:
  const std::string& _internal_experimental_features(int index) const;
  std::string* _internal_add_experimental_features();
  public:

  // optional string preceding_text = 1;
  bool has_preceding_text() const;
  private:
  bool _internal_has_preceding_text() const;
  public:
  void clear_preceding_text();
  const std::string& preceding_text() const;
  void set_preceding_text(const std::string& value);
  void set_preceding_text(std::string&& value);
  void set_preceding_text(const char* value);
  void set_preceding_text(const char* value, size_t size);
  std::string* mutable_preceding_text();
  std::string* release_preceding_text();
  void set_allocated_preceding_text(std::string* preceding_text);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_preceding_text();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_preceding_text(
      std::string* preceding_text);
  private:
  const std::string& _internal_preceding_text() const;
  void _internal_set_preceding_text(const std::string& value);
  std::string* _internal_mutable_preceding_text();
  public:

  // optional string following_text = 2;
  bool has_following_text() const;
  private:
  bool _internal_has_following_text() const;
  public:
  void clear_following_text();
  const std::string& following_text() const;
  void set_following_text(const std::string& value);
  void set_following_text(std::string&& value);
  void set_following_text(const char* value);
  void set_following_text(const char* value, size_t size);
  std::string* mutable_following_text();
  std::string* release_following_text();
  void set_allocated_following_text(std::string* following_text);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_following_text();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_following_text(
      std::string* following_text);
  private:
  const std::string& _internal_following_text() const;
  void _internal_set_following_text(const std::string& value);
  std::string* _internal_mutable_following_text();
  public:

  // optional bool suppress_suggestion = 3 [default = false];
  bool has_suppress_suggestion() const;
  private:
  bool _internal_has_suppress_suggestion() const;
  public:
  void clear_suppress_suggestion();
  bool suppress_suggestion() const;
  void set_suppress_suggestion(bool value);
  private:
  bool _internal_suppress_suggestion() const;
  void _internal_set_suppress_suggestion(bool value);
  public:

  // optional int32 revision = 5 [default = 0];
  bool has_revision() const;
  private:
  bool _internal_has_revision() const;
  public:
  void clear_revision();
  ::PROTOBUF_NAMESPACE_ID::int32 revision() const;
  void set_revision(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_revision() const;
  void _internal_set_revision(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .mozc.commands.Context.InputFieldType input_field_type = 4;
  bool has_input_field_type() const;
  private:
  bool _internal_has_input_field_type() const;
  public:
  void clear_input_field_type();
  ::mozc::commands::Context_InputFieldType input_field_type() const;
  void set_input_field_type(::mozc::commands::Context_InputFieldType value);
  private:
  ::mozc::commands::Context_InputFieldType _internal_input_field_type() const;
  void _internal_set_input_field_type(::mozc::commands::Context_InputFieldType value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Context)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> experimental_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preceding_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr following_text_;
  bool suppress_suggestion_;
  ::PROTOBUF_NAMESPACE_ID::int32 revision_;
  int input_field_type_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Capability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Capability) */ {
 public:
  inline Capability() : Capability(nullptr) {};
  virtual ~Capability();

  Capability(const Capability& from);
  Capability(Capability&& from) noexcept
    : Capability() {
    *this = ::std::move(from);
  }

  inline Capability& operator=(const Capability& from) {
    CopyFrom(from);
    return *this;
  }
  inline Capability& operator=(Capability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Capability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Capability* internal_default_instance() {
    return reinterpret_cast<const Capability*>(
               &_Capability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Capability& a, Capability& b) {
    a.Swap(&b);
  }
  inline void Swap(Capability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Capability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Capability* New() const final {
    return CreateMaybeMessage<Capability>(nullptr);
  }

  Capability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Capability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Capability& from);
  void MergeFrom(const Capability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Capability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Capability";
  }
  protected:
  explicit Capability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Capability_TextDeletionCapabilityType TextDeletionCapabilityType;
  static constexpr TextDeletionCapabilityType NO_TEXT_DELETION_CAPABILITY =
    Capability_TextDeletionCapabilityType_NO_TEXT_DELETION_CAPABILITY;
  static constexpr TextDeletionCapabilityType DELETE_PRECEDING_TEXT =
    Capability_TextDeletionCapabilityType_DELETE_PRECEDING_TEXT;
  static inline bool TextDeletionCapabilityType_IsValid(int value) {
    return Capability_TextDeletionCapabilityType_IsValid(value);
  }
  static constexpr TextDeletionCapabilityType TextDeletionCapabilityType_MIN =
    Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MIN;
  static constexpr TextDeletionCapabilityType TextDeletionCapabilityType_MAX =
    Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MAX;
  static constexpr int TextDeletionCapabilityType_ARRAYSIZE =
    Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TextDeletionCapabilityType_descriptor() {
    return Capability_TextDeletionCapabilityType_descriptor();
  }
  template<typename T>
  static inline const std::string& TextDeletionCapabilityType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TextDeletionCapabilityType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TextDeletionCapabilityType_Name.");
    return Capability_TextDeletionCapabilityType_Name(enum_t_value);
  }
  static inline bool TextDeletionCapabilityType_Parse(const std::string& name,
      TextDeletionCapabilityType* value) {
    return Capability_TextDeletionCapabilityType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextDeletionFieldNumber = 1,
  };
  // optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];
  bool has_text_deletion() const;
  private:
  bool _internal_has_text_deletion() const;
  public:
  void clear_text_deletion();
  ::mozc::commands::Capability_TextDeletionCapabilityType text_deletion() const;
  void set_text_deletion(::mozc::commands::Capability_TextDeletionCapabilityType value);
  private:
  ::mozc::commands::Capability_TextDeletionCapabilityType _internal_text_deletion() const;
  void _internal_set_text_deletion(::mozc::commands::Capability_TextDeletionCapabilityType value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Capability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int text_deletion_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class DecoderExperimentParams PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.DecoderExperimentParams) */ {
 public:
  inline DecoderExperimentParams() : DecoderExperimentParams(nullptr) {};
  virtual ~DecoderExperimentParams();

  DecoderExperimentParams(const DecoderExperimentParams& from);
  DecoderExperimentParams(DecoderExperimentParams&& from) noexcept
    : DecoderExperimentParams() {
    *this = ::std::move(from);
  }

  inline DecoderExperimentParams& operator=(const DecoderExperimentParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecoderExperimentParams& operator=(DecoderExperimentParams&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DecoderExperimentParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecoderExperimentParams* internal_default_instance() {
    return reinterpret_cast<const DecoderExperimentParams*>(
               &_DecoderExperimentParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DecoderExperimentParams& a, DecoderExperimentParams& b) {
    a.Swap(&b);
  }
  inline void Swap(DecoderExperimentParams* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecoderExperimentParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecoderExperimentParams* New() const final {
    return CreateMaybeMessage<DecoderExperimentParams>(nullptr);
  }

  DecoderExperimentParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecoderExperimentParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DecoderExperimentParams& from);
  void MergeFrom(const DecoderExperimentParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecoderExperimentParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.DecoderExperimentParams";
  }
  protected:
  explicit DecoderExperimentParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableSimplifiedRankingFieldNumber = 1,
  };
  // optional bool enable_simplified_ranking = 1;
  bool has_enable_simplified_ranking() const;
  private:
  bool _internal_has_enable_simplified_ranking() const;
  public:
  void clear_enable_simplified_ranking();
  bool enable_simplified_ranking() const;
  void set_enable_simplified_ranking(bool value);
  private:
  bool _internal_enable_simplified_ranking() const;
  void _internal_set_enable_simplified_ranking(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.DecoderExperimentParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enable_simplified_ranking_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Request PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Request) */ {
 public:
  inline Request() : Request(nullptr) {};
  virtual ~Request();

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(nullptr);
  }

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Request_SpecialRomanjiTable SpecialRomanjiTable;
  static constexpr SpecialRomanjiTable DEFAULT_TABLE =
    Request_SpecialRomanjiTable_DEFAULT_TABLE;
  static constexpr SpecialRomanjiTable TWELVE_KEYS_TO_HIRAGANA =
    Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HIRAGANA;
  static constexpr SpecialRomanjiTable TWELVE_KEYS_TO_HIRAGANA_INTUITIVE =
    Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HIRAGANA_INTUITIVE;
  static constexpr SpecialRomanjiTable TWELVE_KEYS_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HALFWIDTHASCII;
  static constexpr SpecialRomanjiTable FLICK_TO_HIRAGANA =
    Request_SpecialRomanjiTable_FLICK_TO_HIRAGANA;
  static constexpr SpecialRomanjiTable FLICK_TO_HIRAGANA_INTUITIVE =
    Request_SpecialRomanjiTable_FLICK_TO_HIRAGANA_INTUITIVE;
  static constexpr SpecialRomanjiTable FLICK_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_FLICK_TO_HALFWIDTHASCII;
  static constexpr SpecialRomanjiTable FLICK_TO_HALFWIDTHASCII_IOS =
    Request_SpecialRomanjiTable_FLICK_TO_HALFWIDTHASCII_IOS;
  static constexpr SpecialRomanjiTable FLICK_TO_NUMBER =
    Request_SpecialRomanjiTable_FLICK_TO_NUMBER;
  static constexpr SpecialRomanjiTable TOGGLE_FLICK_TO_HIRAGANA =
    Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HIRAGANA;
  static constexpr SpecialRomanjiTable TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE =
    Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE;
  static constexpr SpecialRomanjiTable TOGGLE_FLICK_TO_NUMBER =
    Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_NUMBER;
  static constexpr SpecialRomanjiTable TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS =
    Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS;
  static constexpr SpecialRomanjiTable TOGGLE_FLICK_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HALFWIDTHASCII;
  static constexpr SpecialRomanjiTable QWERTY_MOBILE_TO_HIRAGANA =
    Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HIRAGANA;
  static constexpr SpecialRomanjiTable QWERTY_MOBILE_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HALFWIDTHASCII;
  static constexpr SpecialRomanjiTable GODAN_TO_HIRAGANA =
    Request_SpecialRomanjiTable_GODAN_TO_HIRAGANA;
  static constexpr SpecialRomanjiTable GODAN_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_GODAN_TO_HALFWIDTHASCII;
  static constexpr SpecialRomanjiTable NOTOUCH_TO_HIRAGANA =
    Request_SpecialRomanjiTable_NOTOUCH_TO_HIRAGANA;
  static constexpr SpecialRomanjiTable NOTOUCH_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_NOTOUCH_TO_HALFWIDTHASCII;
  static inline bool SpecialRomanjiTable_IsValid(int value) {
    return Request_SpecialRomanjiTable_IsValid(value);
  }
  static constexpr SpecialRomanjiTable SpecialRomanjiTable_MIN =
    Request_SpecialRomanjiTable_SpecialRomanjiTable_MIN;
  static constexpr SpecialRomanjiTable SpecialRomanjiTable_MAX =
    Request_SpecialRomanjiTable_SpecialRomanjiTable_MAX;
  static constexpr int SpecialRomanjiTable_ARRAYSIZE =
    Request_SpecialRomanjiTable_SpecialRomanjiTable_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SpecialRomanjiTable_descriptor() {
    return Request_SpecialRomanjiTable_descriptor();
  }
  template<typename T>
  static inline const std::string& SpecialRomanjiTable_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SpecialRomanjiTable>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SpecialRomanjiTable_Name.");
    return Request_SpecialRomanjiTable_Name(enum_t_value);
  }
  static inline bool SpecialRomanjiTable_Parse(const std::string& name,
      SpecialRomanjiTable* value) {
    return Request_SpecialRomanjiTable_Parse(name, value);
  }

  typedef Request_SpaceOnAlphanumeric SpaceOnAlphanumeric;
  static constexpr SpaceOnAlphanumeric SPACE_OR_CONVERT_KEEPING_COMPOSITION =
    Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_KEEPING_COMPOSITION;
  static constexpr SpaceOnAlphanumeric SPACE_OR_CONVERT_COMMITING_COMPOSITION =
    Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_COMMITING_COMPOSITION;
  static constexpr SpaceOnAlphanumeric COMMIT =
    Request_SpaceOnAlphanumeric_COMMIT;
  static inline bool SpaceOnAlphanumeric_IsValid(int value) {
    return Request_SpaceOnAlphanumeric_IsValid(value);
  }
  static constexpr SpaceOnAlphanumeric SpaceOnAlphanumeric_MIN =
    Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MIN;
  static constexpr SpaceOnAlphanumeric SpaceOnAlphanumeric_MAX =
    Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MAX;
  static constexpr int SpaceOnAlphanumeric_ARRAYSIZE =
    Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SpaceOnAlphanumeric_descriptor() {
    return Request_SpaceOnAlphanumeric_descriptor();
  }
  template<typename T>
  static inline const std::string& SpaceOnAlphanumeric_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SpaceOnAlphanumeric>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SpaceOnAlphanumeric_Name.");
    return Request_SpaceOnAlphanumeric_Name(enum_t_value);
  }
  static inline bool SpaceOnAlphanumeric_Parse(const std::string& name,
      SpaceOnAlphanumeric* value) {
    return Request_SpaceOnAlphanumeric_Parse(name, value);
  }

  typedef Request_EmojiCarrierType EmojiCarrierType;
  static constexpr EmojiCarrierType UNICODE_EMOJI =
    Request_EmojiCarrierType_UNICODE_EMOJI;
  static constexpr EmojiCarrierType DOCOMO_EMOJI =
    Request_EmojiCarrierType_DOCOMO_EMOJI;
  static constexpr EmojiCarrierType SOFTBANK_EMOJI =
    Request_EmojiCarrierType_SOFTBANK_EMOJI;
  static constexpr EmojiCarrierType KDDI_EMOJI =
    Request_EmojiCarrierType_KDDI_EMOJI;
  static inline bool EmojiCarrierType_IsValid(int value) {
    return Request_EmojiCarrierType_IsValid(value);
  }
  static constexpr EmojiCarrierType EmojiCarrierType_MIN =
    Request_EmojiCarrierType_EmojiCarrierType_MIN;
  static constexpr EmojiCarrierType EmojiCarrierType_MAX =
    Request_EmojiCarrierType_EmojiCarrierType_MAX;
  static constexpr int EmojiCarrierType_ARRAYSIZE =
    Request_EmojiCarrierType_EmojiCarrierType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EmojiCarrierType_descriptor() {
    return Request_EmojiCarrierType_descriptor();
  }
  template<typename T>
  static inline const std::string& EmojiCarrierType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EmojiCarrierType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EmojiCarrierType_Name.");
    return Request_EmojiCarrierType_Name(enum_t_value);
  }
  static inline bool EmojiCarrierType_Parse(const std::string& name,
      EmojiCarrierType* value) {
    return Request_EmojiCarrierType_Parse(name, value);
  }

  typedef Request_RewriterCapability RewriterCapability;
  static constexpr RewriterCapability NOT_AVAILABLE =
    Request_RewriterCapability_NOT_AVAILABLE;
  static constexpr RewriterCapability CONVERSION =
    Request_RewriterCapability_CONVERSION;
  static constexpr RewriterCapability PREDICTION =
    Request_RewriterCapability_PREDICTION;
  static constexpr RewriterCapability SUGGESTION =
    Request_RewriterCapability_SUGGESTION;
  static constexpr RewriterCapability ALL =
    Request_RewriterCapability_ALL;
  static inline bool RewriterCapability_IsValid(int value) {
    return Request_RewriterCapability_IsValid(value);
  }
  static constexpr RewriterCapability RewriterCapability_MIN =
    Request_RewriterCapability_RewriterCapability_MIN;
  static constexpr RewriterCapability RewriterCapability_MAX =
    Request_RewriterCapability_RewriterCapability_MAX;
  static constexpr int RewriterCapability_ARRAYSIZE =
    Request_RewriterCapability_RewriterCapability_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RewriterCapability_descriptor() {
    return Request_RewriterCapability_descriptor();
  }
  template<typename T>
  static inline const std::string& RewriterCapability_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RewriterCapability>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RewriterCapability_Name.");
    return Request_RewriterCapability_Name(enum_t_value);
  }
  static inline bool RewriterCapability_Parse(const std::string& name,
      RewriterCapability* value) {
    return Request_RewriterCapability_Parse(name, value);
  }

  typedef Request_CrossingEdgeBehavior CrossingEdgeBehavior;
  static constexpr CrossingEdgeBehavior DO_NOTHING =
    Request_CrossingEdgeBehavior_DO_NOTHING;
  static constexpr CrossingEdgeBehavior COMMIT_WITHOUT_CONSUMING =
    Request_CrossingEdgeBehavior_COMMIT_WITHOUT_CONSUMING;
  static inline bool CrossingEdgeBehavior_IsValid(int value) {
    return Request_CrossingEdgeBehavior_IsValid(value);
  }
  static constexpr CrossingEdgeBehavior CrossingEdgeBehavior_MIN =
    Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MIN;
  static constexpr CrossingEdgeBehavior CrossingEdgeBehavior_MAX =
    Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MAX;
  static constexpr int CrossingEdgeBehavior_ARRAYSIZE =
    Request_CrossingEdgeBehavior_CrossingEdgeBehavior_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CrossingEdgeBehavior_descriptor() {
    return Request_CrossingEdgeBehavior_descriptor();
  }
  template<typename T>
  static inline const std::string& CrossingEdgeBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CrossingEdgeBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CrossingEdgeBehavior_Name.");
    return Request_CrossingEdgeBehavior_Name(enum_t_value);
  }
  static inline bool CrossingEdgeBehavior_Parse(const std::string& name,
      CrossingEdgeBehavior* value) {
    return Request_CrossingEdgeBehavior_Parse(name, value);
  }

  typedef Request_LanguageAwareInputBehavior LanguageAwareInputBehavior;
  static constexpr LanguageAwareInputBehavior DEFAULT_LANGUAGE_AWARE_BEHAVIOR =
    Request_LanguageAwareInputBehavior_DEFAULT_LANGUAGE_AWARE_BEHAVIOR;
  static constexpr LanguageAwareInputBehavior NO_LANGUAGE_AWARE_INPUT =
    Request_LanguageAwareInputBehavior_NO_LANGUAGE_AWARE_INPUT;
  static constexpr LanguageAwareInputBehavior LANGUAGE_AWARE_SUGGESTION =
    Request_LanguageAwareInputBehavior_LANGUAGE_AWARE_SUGGESTION;
  static inline bool LanguageAwareInputBehavior_IsValid(int value) {
    return Request_LanguageAwareInputBehavior_IsValid(value);
  }
  static constexpr LanguageAwareInputBehavior LanguageAwareInputBehavior_MIN =
    Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MIN;
  static constexpr LanguageAwareInputBehavior LanguageAwareInputBehavior_MAX =
    Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MAX;
  static constexpr int LanguageAwareInputBehavior_ARRAYSIZE =
    Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LanguageAwareInputBehavior_descriptor() {
    return Request_LanguageAwareInputBehavior_descriptor();
  }
  template<typename T>
  static inline const std::string& LanguageAwareInputBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LanguageAwareInputBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LanguageAwareInputBehavior_Name.");
    return Request_LanguageAwareInputBehavior_Name(enum_t_value);
  }
  static inline bool LanguageAwareInputBehavior_Parse(const std::string& name,
      LanguageAwareInputBehavior* value) {
    return Request_LanguageAwareInputBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeyboardNameFieldNumber = 7,
    kDecoderExperimentParamsFieldNumber = 17,
    kSpecialRomanjiTableFieldNumber = 4,
    kZeroQuerySuggestionFieldNumber = 1,
    kMixedConversionFieldNumber = 2,
    kKanaModifierInsensitiveConversionFieldNumber = 9,
    kAutoPartialSuggestionFieldNumber = 10,
    kSpaceOnAlphanumericFieldNumber = 6,
    kCrossingEdgeBehaviorFieldNumber = 13,
    kLanguageAwareInputFieldNumber = 14,
    kCandidatesSizeLimitFieldNumber = 16,
    kUpdateInputModeFromSurroundingTextFieldNumber = 8,
    kAvailableEmojiCarrierFieldNumber = 11,
    kEmojiRewriterCapabilityFieldNumber = 12,
    kCandidatePageSizeFieldNumber = 15,
  };
  // optional string keyboard_name = 7;
  bool has_keyboard_name() const;
  private:
  bool _internal_has_keyboard_name() const;
  public:
  void clear_keyboard_name();
  const std::string& keyboard_name() const;
  void set_keyboard_name(const std::string& value);
  void set_keyboard_name(std::string&& value);
  void set_keyboard_name(const char* value);
  void set_keyboard_name(const char* value, size_t size);
  std::string* mutable_keyboard_name();
  std::string* release_keyboard_name();
  void set_allocated_keyboard_name(std::string* keyboard_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_keyboard_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_keyboard_name(
      std::string* keyboard_name);
  private:
  const std::string& _internal_keyboard_name() const;
  void _internal_set_keyboard_name(const std::string& value);
  std::string* _internal_mutable_keyboard_name();
  public:

  // optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;
  bool has_decoder_experiment_params() const;
  private:
  bool _internal_has_decoder_experiment_params() const;
  public:
  void clear_decoder_experiment_params();
  const ::mozc::commands::DecoderExperimentParams& decoder_experiment_params() const;
  ::mozc::commands::DecoderExperimentParams* release_decoder_experiment_params();
  ::mozc::commands::DecoderExperimentParams* mutable_decoder_experiment_params();
  void set_allocated_decoder_experiment_params(::mozc::commands::DecoderExperimentParams* decoder_experiment_params);
  private:
  const ::mozc::commands::DecoderExperimentParams& _internal_decoder_experiment_params() const;
  ::mozc::commands::DecoderExperimentParams* _internal_mutable_decoder_experiment_params();
  public:
  void unsafe_arena_set_allocated_decoder_experiment_params(
      ::mozc::commands::DecoderExperimentParams* decoder_experiment_params);
  ::mozc::commands::DecoderExperimentParams* unsafe_arena_release_decoder_experiment_params();

  // optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];
  bool has_special_romanji_table() const;
  private:
  bool _internal_has_special_romanji_table() const;
  public:
  void clear_special_romanji_table();
  ::mozc::commands::Request_SpecialRomanjiTable special_romanji_table() const;
  void set_special_romanji_table(::mozc::commands::Request_SpecialRomanjiTable value);
  private:
  ::mozc::commands::Request_SpecialRomanjiTable _internal_special_romanji_table() const;
  void _internal_set_special_romanji_table(::mozc::commands::Request_SpecialRomanjiTable value);
  public:

  // optional bool zero_query_suggestion = 1 [default = false];
  bool has_zero_query_suggestion() const;
  private:
  bool _internal_has_zero_query_suggestion() const;
  public:
  void clear_zero_query_suggestion();
  bool zero_query_suggestion() const;
  void set_zero_query_suggestion(bool value);
  private:
  bool _internal_zero_query_suggestion() const;
  void _internal_set_zero_query_suggestion(bool value);
  public:

  // optional bool mixed_conversion = 2 [default = false];
  bool has_mixed_conversion() const;
  private:
  bool _internal_has_mixed_conversion() const;
  public:
  void clear_mixed_conversion();
  bool mixed_conversion() const;
  void set_mixed_conversion(bool value);
  private:
  bool _internal_mixed_conversion() const;
  void _internal_set_mixed_conversion(bool value);
  public:

  // optional bool kana_modifier_insensitive_conversion = 9 [default = false];
  bool has_kana_modifier_insensitive_conversion() const;
  private:
  bool _internal_has_kana_modifier_insensitive_conversion() const;
  public:
  void clear_kana_modifier_insensitive_conversion();
  bool kana_modifier_insensitive_conversion() const;
  void set_kana_modifier_insensitive_conversion(bool value);
  private:
  bool _internal_kana_modifier_insensitive_conversion() const;
  void _internal_set_kana_modifier_insensitive_conversion(bool value);
  public:

  // optional bool auto_partial_suggestion = 10 [default = false];
  bool has_auto_partial_suggestion() const;
  private:
  bool _internal_has_auto_partial_suggestion() const;
  public:
  void clear_auto_partial_suggestion();
  bool auto_partial_suggestion() const;
  void set_auto_partial_suggestion(bool value);
  private:
  bool _internal_auto_partial_suggestion() const;
  void _internal_set_auto_partial_suggestion(bool value);
  public:

  // optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];
  bool has_space_on_alphanumeric() const;
  private:
  bool _internal_has_space_on_alphanumeric() const;
  public:
  void clear_space_on_alphanumeric();
  ::mozc::commands::Request_SpaceOnAlphanumeric space_on_alphanumeric() const;
  void set_space_on_alphanumeric(::mozc::commands::Request_SpaceOnAlphanumeric value);
  private:
  ::mozc::commands::Request_SpaceOnAlphanumeric _internal_space_on_alphanumeric() const;
  void _internal_set_space_on_alphanumeric(::mozc::commands::Request_SpaceOnAlphanumeric value);
  public:

  // optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];
  bool has_crossing_edge_behavior() const;
  private:
  bool _internal_has_crossing_edge_behavior() const;
  public:
  void clear_crossing_edge_behavior();
  ::mozc::commands::Request_CrossingEdgeBehavior crossing_edge_behavior() const;
  void set_crossing_edge_behavior(::mozc::commands::Request_CrossingEdgeBehavior value);
  private:
  ::mozc::commands::Request_CrossingEdgeBehavior _internal_crossing_edge_behavior() const;
  void _internal_set_crossing_edge_behavior(::mozc::commands::Request_CrossingEdgeBehavior value);
  public:

  // optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];
  bool has_language_aware_input() const;
  private:
  bool _internal_has_language_aware_input() const;
  public:
  void clear_language_aware_input();
  ::mozc::commands::Request_LanguageAwareInputBehavior language_aware_input() const;
  void set_language_aware_input(::mozc::commands::Request_LanguageAwareInputBehavior value);
  private:
  ::mozc::commands::Request_LanguageAwareInputBehavior _internal_language_aware_input() const;
  void _internal_set_language_aware_input(::mozc::commands::Request_LanguageAwareInputBehavior value);
  public:

  // optional int32 candidates_size_limit = 16;
  bool has_candidates_size_limit() const;
  private:
  bool _internal_has_candidates_size_limit() const;
  public:
  void clear_candidates_size_limit();
  ::PROTOBUF_NAMESPACE_ID::int32 candidates_size_limit() const;
  void set_candidates_size_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_candidates_size_limit() const;
  void _internal_set_candidates_size_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool update_input_mode_from_surrounding_text = 8 [default = true];
  bool has_update_input_mode_from_surrounding_text() const;
  private:
  bool _internal_has_update_input_mode_from_surrounding_text() const;
  public:
  void clear_update_input_mode_from_surrounding_text();
  bool update_input_mode_from_surrounding_text() const;
  void set_update_input_mode_from_surrounding_text(bool value);
  private:
  bool _internal_update_input_mode_from_surrounding_text() const;
  void _internal_set_update_input_mode_from_surrounding_text(bool value);
  public:

  // optional int32 available_emoji_carrier = 11 [default = 1];
  bool has_available_emoji_carrier() const;
  private:
  bool _internal_has_available_emoji_carrier() const;
  public:
  void clear_available_emoji_carrier();
  ::PROTOBUF_NAMESPACE_ID::int32 available_emoji_carrier() const;
  void set_available_emoji_carrier(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_available_emoji_carrier() const;
  void _internal_set_available_emoji_carrier(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 emoji_rewriter_capability = 12 [default = 1];
  bool has_emoji_rewriter_capability() const;
  private:
  bool _internal_has_emoji_rewriter_capability() const;
  public:
  void clear_emoji_rewriter_capability();
  ::PROTOBUF_NAMESPACE_ID::int32 emoji_rewriter_capability() const;
  void set_emoji_rewriter_capability(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_emoji_rewriter_capability() const;
  void _internal_set_emoji_rewriter_capability(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 candidate_page_size = 15 [default = 9];
  bool has_candidate_page_size() const;
  private:
  bool _internal_has_candidate_page_size() const;
  public:
  void clear_candidate_page_size();
  ::PROTOBUF_NAMESPACE_ID::int32 candidate_page_size() const;
  void set_candidate_page_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_candidate_page_size() const;
  void _internal_set_candidate_page_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyboard_name_;
  ::mozc::commands::DecoderExperimentParams* decoder_experiment_params_;
  int special_romanji_table_;
  bool zero_query_suggestion_;
  bool mixed_conversion_;
  bool kana_modifier_insensitive_conversion_;
  bool auto_partial_suggestion_;
  int space_on_alphanumeric_;
  int crossing_edge_behavior_;
  int language_aware_input_;
  ::PROTOBUF_NAMESPACE_ID::int32 candidates_size_limit_;
  bool update_input_mode_from_surrounding_text_;
  ::PROTOBUF_NAMESPACE_ID::int32 available_emoji_carrier_;
  ::PROTOBUF_NAMESPACE_ID::int32 emoji_rewriter_capability_;
  ::PROTOBUF_NAMESPACE_ID::int32 candidate_page_size_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class ApplicationInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.ApplicationInfo) */ {
 public:
  inline ApplicationInfo() : ApplicationInfo(nullptr) {};
  virtual ~ApplicationInfo();

  ApplicationInfo(const ApplicationInfo& from);
  ApplicationInfo(ApplicationInfo&& from) noexcept
    : ApplicationInfo() {
    *this = ::std::move(from);
  }

  inline ApplicationInfo& operator=(const ApplicationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationInfo& operator=(ApplicationInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ApplicationInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApplicationInfo* internal_default_instance() {
    return reinterpret_cast<const ApplicationInfo*>(
               &_ApplicationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ApplicationInfo& a, ApplicationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplicationInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplicationInfo* New() const final {
    return CreateMaybeMessage<ApplicationInfo>(nullptr);
  }

  ApplicationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplicationInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ApplicationInfo& from);
  void MergeFrom(const ApplicationInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplicationInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.ApplicationInfo";
  }
  protected:
  explicit ApplicationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessIdFieldNumber = 1,
    kThreadIdFieldNumber = 2,
    kTimezoneOffsetFieldNumber = 3,
  };
  // optional uint32 process_id = 1;
  bool has_process_id() const;
  private:
  bool _internal_has_process_id() const;
  public:
  void clear_process_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 process_id() const;
  void set_process_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_process_id() const;
  void _internal_set_process_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 thread_id = 2;
  bool has_thread_id() const;
  private:
  bool _internal_has_thread_id() const;
  public:
  void clear_thread_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 thread_id() const;
  void set_thread_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_thread_id() const;
  void _internal_set_thread_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int32 timezone_offset = 3;
  bool has_timezone_offset() const;
  private:
  bool _internal_has_timezone_offset() const;
  public:
  void clear_timezone_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 timezone_offset() const;
  void set_timezone_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_timezone_offset() const;
  void _internal_set_timezone_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.ApplicationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 process_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 thread_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 timezone_offset_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Input_TouchPosition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Input.TouchPosition) */ {
 public:
  inline Input_TouchPosition() : Input_TouchPosition(nullptr) {};
  virtual ~Input_TouchPosition();

  Input_TouchPosition(const Input_TouchPosition& from);
  Input_TouchPosition(Input_TouchPosition&& from) noexcept
    : Input_TouchPosition() {
    *this = ::std::move(from);
  }

  inline Input_TouchPosition& operator=(const Input_TouchPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Input_TouchPosition& operator=(Input_TouchPosition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Input_TouchPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Input_TouchPosition* internal_default_instance() {
    return reinterpret_cast<const Input_TouchPosition*>(
               &_Input_TouchPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Input_TouchPosition& a, Input_TouchPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(Input_TouchPosition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Input_TouchPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Input_TouchPosition* New() const final {
    return CreateMaybeMessage<Input_TouchPosition>(nullptr);
  }

  Input_TouchPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Input_TouchPosition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Input_TouchPosition& from);
  void MergeFrom(const Input_TouchPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input_TouchPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Input.TouchPosition";
  }
  protected:
  explicit Input_TouchPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kActionFieldNumber = 1,
  };
  // optional float x = 2;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional int64 timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .mozc.commands.Input.TouchAction action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::mozc::commands::Input_TouchAction action() const;
  void set_action(::mozc::commands::Input_TouchAction value);
  private:
  ::mozc::commands::Input_TouchAction _internal_action() const;
  void _internal_set_action(::mozc::commands::Input_TouchAction value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Input.TouchPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  int action_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Input_TouchEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Input.TouchEvent) */ {
 public:
  inline Input_TouchEvent() : Input_TouchEvent(nullptr) {};
  virtual ~Input_TouchEvent();

  Input_TouchEvent(const Input_TouchEvent& from);
  Input_TouchEvent(Input_TouchEvent&& from) noexcept
    : Input_TouchEvent() {
    *this = ::std::move(from);
  }

  inline Input_TouchEvent& operator=(const Input_TouchEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline Input_TouchEvent& operator=(Input_TouchEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Input_TouchEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Input_TouchEvent* internal_default_instance() {
    return reinterpret_cast<const Input_TouchEvent*>(
               &_Input_TouchEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Input_TouchEvent& a, Input_TouchEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(Input_TouchEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Input_TouchEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Input_TouchEvent* New() const final {
    return CreateMaybeMessage<Input_TouchEvent>(nullptr);
  }

  Input_TouchEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Input_TouchEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Input_TouchEvent& from);
  void MergeFrom(const Input_TouchEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input_TouchEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Input.TouchEvent";
  }
  protected:
  explicit Input_TouchEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrokeFieldNumber = 2,
    kSourceIdFieldNumber = 1,
  };
  // repeated .mozc.commands.Input.TouchPosition stroke = 2;
  int stroke_size() const;
  private:
  int _internal_stroke_size() const;
  public:
  void clear_stroke();
  ::mozc::commands::Input_TouchPosition* mutable_stroke(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >*
      mutable_stroke();
  private:
  const ::mozc::commands::Input_TouchPosition& _internal_stroke(int index) const;
  ::mozc::commands::Input_TouchPosition* _internal_add_stroke();
  public:
  const ::mozc::commands::Input_TouchPosition& stroke(int index) const;
  ::mozc::commands::Input_TouchPosition* add_stroke();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >&
      stroke() const;

  // optional uint32 source_id = 1;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 source_id() const;
  void set_source_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_source_id() const;
  void _internal_set_source_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Input.TouchEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Input_TouchPosition > stroke_;
  ::PROTOBUF_NAMESPACE_ID::uint32 source_id_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Input PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Input) */ {
 public:
  inline Input() : Input(nullptr) {};
  virtual ~Input();

  Input(const Input& from);
  Input(Input&& from) noexcept
    : Input() {
    *this = ::std::move(from);
  }

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }
  inline Input& operator=(Input&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Input* internal_default_instance() {
    return reinterpret_cast<const Input*>(
               &_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Input& a, Input& b) {
    a.Swap(&b);
  }
  inline void Swap(Input* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Input* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Input* New() const final {
    return CreateMaybeMessage<Input>(nullptr);
  }

  Input* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Input>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Input& from);
  void MergeFrom(const Input& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Input";
  }
  protected:
  explicit Input(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Input_TouchPosition TouchPosition;
  typedef Input_TouchEvent TouchEvent;

  typedef Input_CommandType CommandType;
  static constexpr CommandType NONE =
    Input_CommandType_NONE;
  static constexpr CommandType CREATE_SESSION =
    Input_CommandType_CREATE_SESSION;
  static constexpr CommandType DELETE_SESSION =
    Input_CommandType_DELETE_SESSION;
  static constexpr CommandType SEND_KEY =
    Input_CommandType_SEND_KEY;
  static constexpr CommandType TEST_SEND_KEY =
    Input_CommandType_TEST_SEND_KEY;
  static constexpr CommandType SEND_COMMAND =
    Input_CommandType_SEND_COMMAND;
  static constexpr CommandType GET_CONFIG =
    Input_CommandType_GET_CONFIG;
  static constexpr CommandType SET_CONFIG =
    Input_CommandType_SET_CONFIG;
  static constexpr CommandType SET_IMPOSED_CONFIG =
    Input_CommandType_SET_IMPOSED_CONFIG;
  static constexpr CommandType SET_REQUEST =
    Input_CommandType_SET_REQUEST;
  static constexpr CommandType SYNC_DATA =
    Input_CommandType_SYNC_DATA;
  static constexpr CommandType SHUTDOWN =
    Input_CommandType_SHUTDOWN;
  static constexpr CommandType RELOAD =
    Input_CommandType_RELOAD;
  static constexpr CommandType CLEAR_USER_HISTORY =
    Input_CommandType_CLEAR_USER_HISTORY;
  static constexpr CommandType CLEAR_USER_PREDICTION =
    Input_CommandType_CLEAR_USER_PREDICTION;
  static constexpr CommandType CLEAR_UNUSED_USER_PREDICTION =
    Input_CommandType_CLEAR_UNUSED_USER_PREDICTION;
  static constexpr CommandType CLEANUP =
    Input_CommandType_CLEANUP;
  static constexpr CommandType NO_OPERATION =
    Input_CommandType_NO_OPERATION;
  static constexpr CommandType SEND_USER_DICTIONARY_COMMAND =
    Input_CommandType_SEND_USER_DICTIONARY_COMMAND;
  static constexpr CommandType SEND_ENGINE_RELOAD_REQUEST =
    Input_CommandType_SEND_ENGINE_RELOAD_REQUEST;
  static constexpr CommandType NUM_OF_COMMANDS =
    Input_CommandType_NUM_OF_COMMANDS;
  static inline bool CommandType_IsValid(int value) {
    return Input_CommandType_IsValid(value);
  }
  static constexpr CommandType CommandType_MIN =
    Input_CommandType_CommandType_MIN;
  static constexpr CommandType CommandType_MAX =
    Input_CommandType_CommandType_MAX;
  static constexpr int CommandType_ARRAYSIZE =
    Input_CommandType_CommandType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CommandType_descriptor() {
    return Input_CommandType_descriptor();
  }
  template<typename T>
  static inline const std::string& CommandType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CommandType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CommandType_Name.");
    return Input_CommandType_Name(enum_t_value);
  }
  static inline bool CommandType_Parse(const std::string& name,
      CommandType* value) {
    return Input_CommandType_Parse(name, value);
  }

  typedef Input_TouchAction TouchAction;
  static constexpr TouchAction TOUCH_DOWN =
    Input_TouchAction_TOUCH_DOWN;
  static constexpr TouchAction TOUCH_MOVE =
    Input_TouchAction_TOUCH_MOVE;
  static constexpr TouchAction TOUCH_UP =
    Input_TouchAction_TOUCH_UP;
  static inline bool TouchAction_IsValid(int value) {
    return Input_TouchAction_IsValid(value);
  }
  static constexpr TouchAction TouchAction_MIN =
    Input_TouchAction_TouchAction_MIN;
  static constexpr TouchAction TouchAction_MAX =
    Input_TouchAction_TouchAction_MAX;
  static constexpr int TouchAction_ARRAYSIZE =
    Input_TouchAction_TouchAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TouchAction_descriptor() {
    return Input_TouchAction_descriptor();
  }
  template<typename T>
  static inline const std::string& TouchAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TouchAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TouchAction_Name.");
    return Input_TouchAction_Name(enum_t_value);
  }
  static inline bool TouchAction_Parse(const std::string& name,
      TouchAction* value) {
    return Input_TouchAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTouchEventsFieldNumber = 12,
    kKeyFieldNumber = 3,
    kCommandFieldNumber = 4,
    kConfigFieldNumber = 5,
    kContextFieldNumber = 6,
    kCapabilityFieldNumber = 7,
    kApplicationInfoFieldNumber = 8,
    kRequestFieldNumber = 9,
    kStorageEntryFieldNumber = 10,
    kUserDictionaryCommandFieldNumber = 13,
    kEngineReloadRequestFieldNumber = 15,
    kIdFieldNumber = 2,
    kTypeFieldNumber = 1,
    kRequestSuggestionFieldNumber = 14,
  };
  // repeated .mozc.commands.Input.TouchEvent touch_events = 12;
  int touch_events_size() const;
  private:
  int _internal_touch_events_size() const;
  public:
  void clear_touch_events();
  ::mozc::commands::Input_TouchEvent* mutable_touch_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >*
      mutable_touch_events();
  private:
  const ::mozc::commands::Input_TouchEvent& _internal_touch_events(int index) const;
  ::mozc::commands::Input_TouchEvent* _internal_add_touch_events();
  public:
  const ::mozc::commands::Input_TouchEvent& touch_events(int index) const;
  ::mozc::commands::Input_TouchEvent* add_touch_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >&
      touch_events() const;

  // optional .mozc.commands.KeyEvent key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::mozc::commands::KeyEvent& key() const;
  ::mozc::commands::KeyEvent* release_key();
  ::mozc::commands::KeyEvent* mutable_key();
  void set_allocated_key(::mozc::commands::KeyEvent* key);
  private:
  const ::mozc::commands::KeyEvent& _internal_key() const;
  ::mozc::commands::KeyEvent* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::mozc::commands::KeyEvent* key);
  ::mozc::commands::KeyEvent* unsafe_arena_release_key();

  // optional .mozc.commands.SessionCommand command = 4;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::mozc::commands::SessionCommand& command() const;
  ::mozc::commands::SessionCommand* release_command();
  ::mozc::commands::SessionCommand* mutable_command();
  void set_allocated_command(::mozc::commands::SessionCommand* command);
  private:
  const ::mozc::commands::SessionCommand& _internal_command() const;
  ::mozc::commands::SessionCommand* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::mozc::commands::SessionCommand* command);
  ::mozc::commands::SessionCommand* unsafe_arena_release_command();

  // optional .mozc.config.Config config = 5;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::mozc::config::Config& config() const;
  ::mozc::config::Config* release_config();
  ::mozc::config::Config* mutable_config();
  void set_allocated_config(::mozc::config::Config* config);
  private:
  const ::mozc::config::Config& _internal_config() const;
  ::mozc::config::Config* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::mozc::config::Config* config);
  ::mozc::config::Config* unsafe_arena_release_config();

  // optional .mozc.commands.Context context = 6;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::mozc::commands::Context& context() const;
  ::mozc::commands::Context* release_context();
  ::mozc::commands::Context* mutable_context();
  void set_allocated_context(::mozc::commands::Context* context);
  private:
  const ::mozc::commands::Context& _internal_context() const;
  ::mozc::commands::Context* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::mozc::commands::Context* context);
  ::mozc::commands::Context* unsafe_arena_release_context();

  // optional .mozc.commands.Capability capability = 7;
  bool has_capability() const;
  private:
  bool _internal_has_capability() const;
  public:
  void clear_capability();
  const ::mozc::commands::Capability& capability() const;
  ::mozc::commands::Capability* release_capability();
  ::mozc::commands::Capability* mutable_capability();
  void set_allocated_capability(::mozc::commands::Capability* capability);
  private:
  const ::mozc::commands::Capability& _internal_capability() const;
  ::mozc::commands::Capability* _internal_mutable_capability();
  public:
  void unsafe_arena_set_allocated_capability(
      ::mozc::commands::Capability* capability);
  ::mozc::commands::Capability* unsafe_arena_release_capability();

  // optional .mozc.commands.ApplicationInfo application_info = 8;
  bool has_application_info() const;
  private:
  bool _internal_has_application_info() const;
  public:
  void clear_application_info();
  const ::mozc::commands::ApplicationInfo& application_info() const;
  ::mozc::commands::ApplicationInfo* release_application_info();
  ::mozc::commands::ApplicationInfo* mutable_application_info();
  void set_allocated_application_info(::mozc::commands::ApplicationInfo* application_info);
  private:
  const ::mozc::commands::ApplicationInfo& _internal_application_info() const;
  ::mozc::commands::ApplicationInfo* _internal_mutable_application_info();
  public:
  void unsafe_arena_set_allocated_application_info(
      ::mozc::commands::ApplicationInfo* application_info);
  ::mozc::commands::ApplicationInfo* unsafe_arena_release_application_info();

  // optional .mozc.commands.Request request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::mozc::commands::Request& request() const;
  ::mozc::commands::Request* release_request();
  ::mozc::commands::Request* mutable_request();
  void set_allocated_request(::mozc::commands::Request* request);
  private:
  const ::mozc::commands::Request& _internal_request() const;
  ::mozc::commands::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::mozc::commands::Request* request);
  ::mozc::commands::Request* unsafe_arena_release_request();

  // optional .mozc.commands.GenericStorageEntry storage_entry = 10;
  bool has_storage_entry() const;
  private:
  bool _internal_has_storage_entry() const;
  public:
  void clear_storage_entry();
  const ::mozc::commands::GenericStorageEntry& storage_entry() const;
  ::mozc::commands::GenericStorageEntry* release_storage_entry();
  ::mozc::commands::GenericStorageEntry* mutable_storage_entry();
  void set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry);
  private:
  const ::mozc::commands::GenericStorageEntry& _internal_storage_entry() const;
  ::mozc::commands::GenericStorageEntry* _internal_mutable_storage_entry();
  public:
  void unsafe_arena_set_allocated_storage_entry(
      ::mozc::commands::GenericStorageEntry* storage_entry);
  ::mozc::commands::GenericStorageEntry* unsafe_arena_release_storage_entry();

  // optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;
  bool has_user_dictionary_command() const;
  private:
  bool _internal_has_user_dictionary_command() const;
  public:
  void clear_user_dictionary_command();
  const ::mozc::user_dictionary::UserDictionaryCommand& user_dictionary_command() const;
  ::mozc::user_dictionary::UserDictionaryCommand* release_user_dictionary_command();
  ::mozc::user_dictionary::UserDictionaryCommand* mutable_user_dictionary_command();
  void set_allocated_user_dictionary_command(::mozc::user_dictionary::UserDictionaryCommand* user_dictionary_command);
  private:
  const ::mozc::user_dictionary::UserDictionaryCommand& _internal_user_dictionary_command() const;
  ::mozc::user_dictionary::UserDictionaryCommand* _internal_mutable_user_dictionary_command();
  public:
  void unsafe_arena_set_allocated_user_dictionary_command(
      ::mozc::user_dictionary::UserDictionaryCommand* user_dictionary_command);
  ::mozc::user_dictionary::UserDictionaryCommand* unsafe_arena_release_user_dictionary_command();

  // optional .mozc.EngineReloadRequest engine_reload_request = 15;
  bool has_engine_reload_request() const;
  private:
  bool _internal_has_engine_reload_request() const;
  public:
  void clear_engine_reload_request();
  const ::mozc::EngineReloadRequest& engine_reload_request() const;
  ::mozc::EngineReloadRequest* release_engine_reload_request();
  ::mozc::EngineReloadRequest* mutable_engine_reload_request();
  void set_allocated_engine_reload_request(::mozc::EngineReloadRequest* engine_reload_request);
  private:
  const ::mozc::EngineReloadRequest& _internal_engine_reload_request() const;
  ::mozc::EngineReloadRequest* _internal_mutable_engine_reload_request();
  public:
  void unsafe_arena_set_allocated_engine_reload_request(
      ::mozc::EngineReloadRequest* engine_reload_request);
  ::mozc::EngineReloadRequest* unsafe_arena_release_engine_reload_request();

  // optional uint64 id = 2 [jstype = JS_STRING];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .mozc.commands.Input.CommandType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::mozc::commands::Input_CommandType type() const;
  void set_type(::mozc::commands::Input_CommandType value);
  private:
  ::mozc::commands::Input_CommandType _internal_type() const;
  void _internal_set_type(::mozc::commands::Input_CommandType value);
  public:

  // optional bool request_suggestion = 14 [default = true];
  bool has_request_suggestion() const;
  private:
  bool _internal_has_request_suggestion() const;
  public:
  void clear_request_suggestion();
  bool request_suggestion() const;
  void set_request_suggestion(bool value);
  private:
  bool _internal_request_suggestion() const;
  void _internal_set_request_suggestion(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Input)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Input_TouchEvent > touch_events_;
  ::mozc::commands::KeyEvent* key_;
  ::mozc::commands::SessionCommand* command_;
  ::mozc::config::Config* config_;
  ::mozc::commands::Context* context_;
  ::mozc::commands::Capability* capability_;
  ::mozc::commands::ApplicationInfo* application_info_;
  ::mozc::commands::Request* request_;
  ::mozc::commands::GenericStorageEntry* storage_entry_;
  ::mozc::user_dictionary::UserDictionaryCommand* user_dictionary_command_;
  ::mozc::EngineReloadRequest* engine_reload_request_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  int type_;
  bool request_suggestion_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Result PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Result) */ {
 public:
  inline Result() : Result(nullptr) {};
  virtual ~Result();

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Result* New() const final {
    return CreateMaybeMessage<Result>(nullptr);
  }

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Result";
  }
  protected:
  explicit Result(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Result_ResultType ResultType;
  static constexpr ResultType NONE =
    Result_ResultType_NONE;
  static constexpr ResultType STRING =
    Result_ResultType_STRING;
  static inline bool ResultType_IsValid(int value) {
    return Result_ResultType_IsValid(value);
  }
  static constexpr ResultType ResultType_MIN =
    Result_ResultType_ResultType_MIN;
  static constexpr ResultType ResultType_MAX =
    Result_ResultType_ResultType_MAX;
  static constexpr int ResultType_ARRAYSIZE =
    Result_ResultType_ResultType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ResultType_descriptor() {
    return Result_ResultType_descriptor();
  }
  template<typename T>
  static inline const std::string& ResultType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResultType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResultType_Name.");
    return Result_ResultType_Name(enum_t_value);
  }
  static inline bool ResultType_Parse(const std::string& name,
      ResultType* value) {
    return Result_ResultType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kKeyFieldNumber = 3,
    kTypeFieldNumber = 1,
    kCursorOffsetFieldNumber = 4,
  };
  // required string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional string key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required .mozc.commands.Result.ResultType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::mozc::commands::Result_ResultType type() const;
  void set_type(::mozc::commands::Result_ResultType value);
  private:
  ::mozc::commands::Result_ResultType _internal_type() const;
  void _internal_set_type(::mozc::commands::Result_ResultType value);
  public:

  // optional int32 cursor_offset = 4 [default = 0];
  bool has_cursor_offset() const;
  private:
  bool _internal_has_cursor_offset() const;
  public:
  void clear_cursor_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 cursor_offset() const;
  void set_cursor_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cursor_offset() const;
  void _internal_set_cursor_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Result)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 cursor_offset_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Preedit_Segment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Preedit.Segment) */ {
 public:
  inline Preedit_Segment() : Preedit_Segment(nullptr) {};
  virtual ~Preedit_Segment();

  Preedit_Segment(const Preedit_Segment& from);
  Preedit_Segment(Preedit_Segment&& from) noexcept
    : Preedit_Segment() {
    *this = ::std::move(from);
  }

  inline Preedit_Segment& operator=(const Preedit_Segment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Preedit_Segment& operator=(Preedit_Segment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Preedit_Segment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Preedit_Segment* internal_default_instance() {
    return reinterpret_cast<const Preedit_Segment*>(
               &_Preedit_Segment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Preedit_Segment& a, Preedit_Segment& b) {
    a.Swap(&b);
  }
  inline void Swap(Preedit_Segment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Preedit_Segment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Preedit_Segment* New() const final {
    return CreateMaybeMessage<Preedit_Segment>(nullptr);
  }

  Preedit_Segment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Preedit_Segment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Preedit_Segment& from);
  void MergeFrom(const Preedit_Segment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Preedit_Segment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Preedit.Segment";
  }
  protected:
  explicit Preedit_Segment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Preedit_Segment_Annotation Annotation;
  static constexpr Annotation NONE =
    Preedit_Segment_Annotation_NONE;
  static constexpr Annotation UNDERLINE =
    Preedit_Segment_Annotation_UNDERLINE;
  static constexpr Annotation HIGHLIGHT =
    Preedit_Segment_Annotation_HIGHLIGHT;
  static inline bool Annotation_IsValid(int value) {
    return Preedit_Segment_Annotation_IsValid(value);
  }
  static constexpr Annotation Annotation_MIN =
    Preedit_Segment_Annotation_Annotation_MIN;
  static constexpr Annotation Annotation_MAX =
    Preedit_Segment_Annotation_Annotation_MAX;
  static constexpr int Annotation_ARRAYSIZE =
    Preedit_Segment_Annotation_Annotation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Annotation_descriptor() {
    return Preedit_Segment_Annotation_descriptor();
  }
  template<typename T>
  static inline const std::string& Annotation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Annotation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Annotation_Name.");
    return Preedit_Segment_Annotation_Name(enum_t_value);
  }
  static inline bool Annotation_Parse(const std::string& name,
      Annotation* value) {
    return Preedit_Segment_Annotation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 4,
    kKeyFieldNumber = 6,
    kAnnotationFieldNumber = 3,
    kValueLengthFieldNumber = 5,
  };
  // required string value = 4;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional string key = 6;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required .mozc.commands.Preedit.Segment.Annotation annotation = 3;
  bool has_annotation() const;
  private:
  bool _internal_has_annotation() const;
  public:
  void clear_annotation();
  ::mozc::commands::Preedit_Segment_Annotation annotation() const;
  void set_annotation(::mozc::commands::Preedit_Segment_Annotation value);
  private:
  ::mozc::commands::Preedit_Segment_Annotation _internal_annotation() const;
  void _internal_set_annotation(::mozc::commands::Preedit_Segment_Annotation value);
  public:

  // required uint32 value_length = 5;
  bool has_value_length() const;
  private:
  bool _internal_has_value_length() const;
  public:
  void clear_value_length();
  ::PROTOBUF_NAMESPACE_ID::uint32 value_length() const;
  void set_value_length(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value_length() const;
  void _internal_set_value_length(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Preedit.Segment)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int annotation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_length_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Preedit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Preedit) */ {
 public:
  inline Preedit() : Preedit(nullptr) {};
  virtual ~Preedit();

  Preedit(const Preedit& from);
  Preedit(Preedit&& from) noexcept
    : Preedit() {
    *this = ::std::move(from);
  }

  inline Preedit& operator=(const Preedit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Preedit& operator=(Preedit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Preedit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Preedit* internal_default_instance() {
    return reinterpret_cast<const Preedit*>(
               &_Preedit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Preedit& a, Preedit& b) {
    a.Swap(&b);
  }
  inline void Swap(Preedit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Preedit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Preedit* New() const final {
    return CreateMaybeMessage<Preedit>(nullptr);
  }

  Preedit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Preedit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Preedit& from);
  void MergeFrom(const Preedit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Preedit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Preedit";
  }
  protected:
  explicit Preedit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Preedit_Segment Segment;

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentFieldNumber = 2,
    kCursorFieldNumber = 1,
    kHighlightedPositionFieldNumber = 3,
    kIsToggleableFieldNumber = 4,
  };
  // repeated group Segment = 2 { ... };
  int segment_size() const;
  private:
  int _internal_segment_size() const;
  public:
  void clear_segment();
  ::mozc::commands::Preedit_Segment* mutable_segment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Preedit_Segment >*
      mutable_segment();
  private:
  const ::mozc::commands::Preedit_Segment& _internal_segment(int index) const;
  ::mozc::commands::Preedit_Segment* _internal_add_segment();
  public:
  const ::mozc::commands::Preedit_Segment& segment(int index) const;
  ::mozc::commands::Preedit_Segment* add_segment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Preedit_Segment >&
      segment() const;

  // required uint32 cursor = 1;
  bool has_cursor() const;
  private:
  bool _internal_has_cursor() const;
  public:
  void clear_cursor();
  ::PROTOBUF_NAMESPACE_ID::uint32 cursor() const;
  void set_cursor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_cursor() const;
  void _internal_set_cursor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 highlighted_position = 3;
  bool has_highlighted_position() const;
  private:
  bool _internal_has_highlighted_position() const;
  public:
  void clear_highlighted_position();
  ::PROTOBUF_NAMESPACE_ID::uint32 highlighted_position() const;
  void set_highlighted_position(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_highlighted_position() const;
  void _internal_set_highlighted_position(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool is_toggleable = 4 [default = false];
  bool has_is_toggleable() const;
  private:
  bool _internal_has_is_toggleable() const;
  public:
  void clear_is_toggleable();
  bool is_toggleable() const;
  void set_is_toggleable(bool value);
  private:
  bool _internal_is_toggleable() const;
  void _internal_set_is_toggleable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Preedit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Preedit_Segment > segment_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cursor_;
  ::PROTOBUF_NAMESPACE_ID::uint32 highlighted_position_;
  bool is_toggleable_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Status PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Status) */ {
 public:
  inline Status() : Status(nullptr) {};
  virtual ~Status();

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(nullptr);
  }

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActivatedFieldNumber = 1,
    kModeFieldNumber = 2,
    kComebackModeFieldNumber = 3,
  };
  // optional bool activated = 1;
  bool has_activated() const;
  private:
  bool _internal_has_activated() const;
  public:
  void clear_activated();
  bool activated() const;
  void set_activated(bool value);
  private:
  bool _internal_activated() const;
  void _internal_set_activated(bool value);
  public:

  // optional .mozc.commands.CompositionMode mode = 2;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::mozc::commands::CompositionMode mode() const;
  void set_mode(::mozc::commands::CompositionMode value);
  private:
  ::mozc::commands::CompositionMode _internal_mode() const;
  void _internal_set_mode(::mozc::commands::CompositionMode value);
  public:

  // optional .mozc.commands.CompositionMode comeback_mode = 3;
  bool has_comeback_mode() const;
  private:
  bool _internal_has_comeback_mode() const;
  public:
  void clear_comeback_mode();
  ::mozc::commands::CompositionMode comeback_mode() const;
  void set_comeback_mode(::mozc::commands::CompositionMode value);
  private:
  ::mozc::commands::CompositionMode _internal_comeback_mode() const;
  void _internal_set_comeback_mode(::mozc::commands::CompositionMode value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool activated_;
  int mode_;
  int comeback_mode_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class DeletionRange PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.DeletionRange) */ {
 public:
  inline DeletionRange() : DeletionRange(nullptr) {};
  virtual ~DeletionRange();

  DeletionRange(const DeletionRange& from);
  DeletionRange(DeletionRange&& from) noexcept
    : DeletionRange() {
    *this = ::std::move(from);
  }

  inline DeletionRange& operator=(const DeletionRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletionRange& operator=(DeletionRange&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeletionRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeletionRange* internal_default_instance() {
    return reinterpret_cast<const DeletionRange*>(
               &_DeletionRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DeletionRange& a, DeletionRange& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletionRange* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletionRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeletionRange* New() const final {
    return CreateMaybeMessage<DeletionRange>(nullptr);
  }

  DeletionRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeletionRange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeletionRange& from);
  void MergeFrom(const DeletionRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletionRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.DeletionRange";
  }
  protected:
  explicit DeletionRange(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kLengthFieldNumber = 2,
  };
  // optional int32 offset = 1;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 length = 2;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  ::PROTOBUF_NAMESPACE_ID::int32 length() const;
  void set_length(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_length() const;
  void _internal_set_length(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.DeletionRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 offset_;
  ::PROTOBUF_NAMESPACE_ID::int32 length_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Output_Callback PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Output.Callback) */ {
 public:
  inline Output_Callback() : Output_Callback(nullptr) {};
  virtual ~Output_Callback();

  Output_Callback(const Output_Callback& from);
  Output_Callback(Output_Callback&& from) noexcept
    : Output_Callback() {
    *this = ::std::move(from);
  }

  inline Output_Callback& operator=(const Output_Callback& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output_Callback& operator=(Output_Callback&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Output_Callback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Output_Callback* internal_default_instance() {
    return reinterpret_cast<const Output_Callback*>(
               &_Output_Callback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Output_Callback& a, Output_Callback& b) {
    a.Swap(&b);
  }
  inline void Swap(Output_Callback* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Output_Callback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Output_Callback* New() const final {
    return CreateMaybeMessage<Output_Callback>(nullptr);
  }

  Output_Callback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Output_Callback>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Output_Callback& from);
  void MergeFrom(const Output_Callback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output_Callback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Output.Callback";
  }
  protected:
  explicit Output_Callback(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionCommandFieldNumber = 1,
    kDelayMillisecFieldNumber = 2,
  };
  // optional .mozc.commands.SessionCommand session_command = 1;
  bool has_session_command() const;
  private:
  bool _internal_has_session_command() const;
  public:
  void clear_session_command();
  const ::mozc::commands::SessionCommand& session_command() const;
  ::mozc::commands::SessionCommand* release_session_command();
  ::mozc::commands::SessionCommand* mutable_session_command();
  void set_allocated_session_command(::mozc::commands::SessionCommand* session_command);
  private:
  const ::mozc::commands::SessionCommand& _internal_session_command() const;
  ::mozc::commands::SessionCommand* _internal_mutable_session_command();
  public:
  void unsafe_arena_set_allocated_session_command(
      ::mozc::commands::SessionCommand* session_command);
  ::mozc::commands::SessionCommand* unsafe_arena_release_session_command();

  // optional uint32 delay_millisec = 2;
  bool has_delay_millisec() const;
  private:
  bool _internal_has_delay_millisec() const;
  public:
  void clear_delay_millisec();
  ::PROTOBUF_NAMESPACE_ID::uint32 delay_millisec() const;
  void set_delay_millisec(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_delay_millisec() const;
  void _internal_set_delay_millisec(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Output.Callback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mozc::commands::SessionCommand* session_command_;
  ::PROTOBUF_NAMESPACE_ID::uint32 delay_millisec_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Output PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Output) */ {
 public:
  inline Output() : Output(nullptr) {};
  virtual ~Output();

  Output(const Output& from);
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output& operator=(Output&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }
  inline void Swap(Output* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Output* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Output* New() const final {
    return CreateMaybeMessage<Output>(nullptr);
  }

  Output* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Output";
  }
  protected:
  explicit Output(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Output_Callback Callback;

  typedef Output_PreeditMethod PreeditMethod;
  static constexpr PreeditMethod ASCII =
    Output_PreeditMethod_ASCII;
  static constexpr PreeditMethod KANA =
    Output_PreeditMethod_KANA;
  static inline bool PreeditMethod_IsValid(int value) {
    return Output_PreeditMethod_IsValid(value);
  }
  static constexpr PreeditMethod PreeditMethod_MIN =
    Output_PreeditMethod_PreeditMethod_MIN;
  static constexpr PreeditMethod PreeditMethod_MAX =
    Output_PreeditMethod_PreeditMethod_MAX;
  static constexpr int PreeditMethod_ARRAYSIZE =
    Output_PreeditMethod_PreeditMethod_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PreeditMethod_descriptor() {
    return Output_PreeditMethod_descriptor();
  }
  template<typename T>
  static inline const std::string& PreeditMethod_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PreeditMethod>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PreeditMethod_Name.");
    return Output_PreeditMethod_Name(enum_t_value);
  }
  static inline bool PreeditMethod_Parse(const std::string& name,
      PreeditMethod* value) {
    return Output_PreeditMethod_Parse(name, value);
  }

  typedef Output_ErrorCode ErrorCode;
  static constexpr ErrorCode SESSION_SUCCESS =
    Output_ErrorCode_SESSION_SUCCESS;
  static constexpr ErrorCode SESSION_FAILURE =
    Output_ErrorCode_SESSION_FAILURE;
  static inline bool ErrorCode_IsValid(int value) {
    return Output_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    Output_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    Output_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    Output_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ErrorCode_descriptor() {
    return Output_ErrorCode_descriptor();
  }
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return Output_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(const std::string& name,
      ErrorCode* value) {
    return Output_ErrorCode_Parse(name, value);
  }

  typedef Output_ToolMode ToolMode;
  static constexpr ToolMode NO_TOOL =
    Output_ToolMode_NO_TOOL;
  static constexpr ToolMode CONFIG_DIALOG =
    Output_ToolMode_CONFIG_DIALOG;
  static constexpr ToolMode DICTIONARY_TOOL =
    Output_ToolMode_DICTIONARY_TOOL;
  static constexpr ToolMode WORD_REGISTER_DIALOG =
    Output_ToolMode_WORD_REGISTER_DIALOG;
  static inline bool ToolMode_IsValid(int value) {
    return Output_ToolMode_IsValid(value);
  }
  static constexpr ToolMode ToolMode_MIN =
    Output_ToolMode_ToolMode_MIN;
  static constexpr ToolMode ToolMode_MAX =
    Output_ToolMode_ToolMode_MAX;
  static constexpr int ToolMode_ARRAYSIZE =
    Output_ToolMode_ToolMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ToolMode_descriptor() {
    return Output_ToolMode_descriptor();
  }
  template<typename T>
  static inline const std::string& ToolMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ToolMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ToolMode_Name.");
    return Output_ToolMode_Name(enum_t_value);
  }
  static inline bool ToolMode_Parse(const std::string& name,
      ToolMode* value) {
    return Output_ToolMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 8,
    kResultFieldNumber = 4,
    kPreeditFieldNumber = 5,
    kCandidatesFieldNumber = 6,
    kKeyFieldNumber = 7,
    kConfigFieldNumber = 9,
    kStatusFieldNumber = 13,
    kAllCandidateWordsFieldNumber = 14,
    kDeletionRangeFieldNumber = 16,
    kCallbackFieldNumber = 18,
    kStorageEntryFieldNumber = 19,
    kUserDictionaryCommandStatusFieldNumber = 21,
    kEngineReloadResponseFieldNumber = 22,
    kIdFieldNumber = 1,
    kModeFieldNumber = 2,
    kConsumedFieldNumber = 3,
    kPreeditMethodFieldNumber = 10,
    kErrorCodeFieldNumber = 11,
    kLaunchToolModeFieldNumber = 17,
  };
  // optional string url = 8;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  void set_url(const std::string& value);
  void set_url(std::string&& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  std::string* mutable_url();
  std::string* release_url();
  void set_allocated_url(std::string* url);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_url();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_url(
      std::string* url);
  private:
  const std::string& _internal_url() const;
  void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional .mozc.commands.Result result = 4;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::mozc::commands::Result& result() const;
  ::mozc::commands::Result* release_result();
  ::mozc::commands::Result* mutable_result();
  void set_allocated_result(::mozc::commands::Result* result);
  private:
  const ::mozc::commands::Result& _internal_result() const;
  ::mozc::commands::Result* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::mozc::commands::Result* result);
  ::mozc::commands::Result* unsafe_arena_release_result();

  // optional .mozc.commands.Preedit preedit = 5;
  bool has_preedit() const;
  private:
  bool _internal_has_preedit() const;
  public:
  void clear_preedit();
  const ::mozc::commands::Preedit& preedit() const;
  ::mozc::commands::Preedit* release_preedit();
  ::mozc::commands::Preedit* mutable_preedit();
  void set_allocated_preedit(::mozc::commands::Preedit* preedit);
  private:
  const ::mozc::commands::Preedit& _internal_preedit() const;
  ::mozc::commands::Preedit* _internal_mutable_preedit();
  public:
  void unsafe_arena_set_allocated_preedit(
      ::mozc::commands::Preedit* preedit);
  ::mozc::commands::Preedit* unsafe_arena_release_preedit();

  // optional .mozc.commands.Candidates candidates = 6;
  bool has_candidates() const;
  private:
  bool _internal_has_candidates() const;
  public:
  void clear_candidates();
  const ::mozc::commands::Candidates& candidates() const;
  ::mozc::commands::Candidates* release_candidates();
  ::mozc::commands::Candidates* mutable_candidates();
  void set_allocated_candidates(::mozc::commands::Candidates* candidates);
  private:
  const ::mozc::commands::Candidates& _internal_candidates() const;
  ::mozc::commands::Candidates* _internal_mutable_candidates();
  public:
  void unsafe_arena_set_allocated_candidates(
      ::mozc::commands::Candidates* candidates);
  ::mozc::commands::Candidates* unsafe_arena_release_candidates();

  // optional .mozc.commands.KeyEvent key = 7;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::mozc::commands::KeyEvent& key() const;
  ::mozc::commands::KeyEvent* release_key();
  ::mozc::commands::KeyEvent* mutable_key();
  void set_allocated_key(::mozc::commands::KeyEvent* key);
  private:
  const ::mozc::commands::KeyEvent& _internal_key() const;
  ::mozc::commands::KeyEvent* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::mozc::commands::KeyEvent* key);
  ::mozc::commands::KeyEvent* unsafe_arena_release_key();

  // optional .mozc.config.Config config = 9;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::mozc::config::Config& config() const;
  ::mozc::config::Config* release_config();
  ::mozc::config::Config* mutable_config();
  void set_allocated_config(::mozc::config::Config* config);
  private:
  const ::mozc::config::Config& _internal_config() const;
  ::mozc::config::Config* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::mozc::config::Config* config);
  ::mozc::config::Config* unsafe_arena_release_config();

  // optional .mozc.commands.Status status = 13;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::mozc::commands::Status& status() const;
  ::mozc::commands::Status* release_status();
  ::mozc::commands::Status* mutable_status();
  void set_allocated_status(::mozc::commands::Status* status);
  private:
  const ::mozc::commands::Status& _internal_status() const;
  ::mozc::commands::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::mozc::commands::Status* status);
  ::mozc::commands::Status* unsafe_arena_release_status();

  // optional .mozc.commands.CandidateList all_candidate_words = 14;
  bool has_all_candidate_words() const;
  private:
  bool _internal_has_all_candidate_words() const;
  public:
  void clear_all_candidate_words();
  const ::mozc::commands::CandidateList& all_candidate_words() const;
  ::mozc::commands::CandidateList* release_all_candidate_words();
  ::mozc::commands::CandidateList* mutable_all_candidate_words();
  void set_allocated_all_candidate_words(::mozc::commands::CandidateList* all_candidate_words);
  private:
  const ::mozc::commands::CandidateList& _internal_all_candidate_words() const;
  ::mozc::commands::CandidateList* _internal_mutable_all_candidate_words();
  public:
  void unsafe_arena_set_allocated_all_candidate_words(
      ::mozc::commands::CandidateList* all_candidate_words);
  ::mozc::commands::CandidateList* unsafe_arena_release_all_candidate_words();

  // optional .mozc.commands.DeletionRange deletion_range = 16;
  bool has_deletion_range() const;
  private:
  bool _internal_has_deletion_range() const;
  public:
  void clear_deletion_range();
  const ::mozc::commands::DeletionRange& deletion_range() const;
  ::mozc::commands::DeletionRange* release_deletion_range();
  ::mozc::commands::DeletionRange* mutable_deletion_range();
  void set_allocated_deletion_range(::mozc::commands::DeletionRange* deletion_range);
  private:
  const ::mozc::commands::DeletionRange& _internal_deletion_range() const;
  ::mozc::commands::DeletionRange* _internal_mutable_deletion_range();
  public:
  void unsafe_arena_set_allocated_deletion_range(
      ::mozc::commands::DeletionRange* deletion_range);
  ::mozc::commands::DeletionRange* unsafe_arena_release_deletion_range();

  // optional .mozc.commands.Output.Callback callback = 18;
  bool has_callback() const;
  private:
  bool _internal_has_callback() const;
  public:
  void clear_callback();
  const ::mozc::commands::Output_Callback& callback() const;
  ::mozc::commands::Output_Callback* release_callback();
  ::mozc::commands::Output_Callback* mutable_callback();
  void set_allocated_callback(::mozc::commands::Output_Callback* callback);
  private:
  const ::mozc::commands::Output_Callback& _internal_callback() const;
  ::mozc::commands::Output_Callback* _internal_mutable_callback();
  public:
  void unsafe_arena_set_allocated_callback(
      ::mozc::commands::Output_Callback* callback);
  ::mozc::commands::Output_Callback* unsafe_arena_release_callback();

  // optional .mozc.commands.GenericStorageEntry storage_entry = 19;
  bool has_storage_entry() const;
  private:
  bool _internal_has_storage_entry() const;
  public:
  void clear_storage_entry();
  const ::mozc::commands::GenericStorageEntry& storage_entry() const;
  ::mozc::commands::GenericStorageEntry* release_storage_entry();
  ::mozc::commands::GenericStorageEntry* mutable_storage_entry();
  void set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry);
  private:
  const ::mozc::commands::GenericStorageEntry& _internal_storage_entry() const;
  ::mozc::commands::GenericStorageEntry* _internal_mutable_storage_entry();
  public:
  void unsafe_arena_set_allocated_storage_entry(
      ::mozc::commands::GenericStorageEntry* storage_entry);
  ::mozc::commands::GenericStorageEntry* unsafe_arena_release_storage_entry();

  // optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;
  bool has_user_dictionary_command_status() const;
  private:
  bool _internal_has_user_dictionary_command_status() const;
  public:
  void clear_user_dictionary_command_status();
  const ::mozc::user_dictionary::UserDictionaryCommandStatus& user_dictionary_command_status() const;
  ::mozc::user_dictionary::UserDictionaryCommandStatus* release_user_dictionary_command_status();
  ::mozc::user_dictionary::UserDictionaryCommandStatus* mutable_user_dictionary_command_status();
  void set_allocated_user_dictionary_command_status(::mozc::user_dictionary::UserDictionaryCommandStatus* user_dictionary_command_status);
  private:
  const ::mozc::user_dictionary::UserDictionaryCommandStatus& _internal_user_dictionary_command_status() const;
  ::mozc::user_dictionary::UserDictionaryCommandStatus* _internal_mutable_user_dictionary_command_status();
  public:
  void unsafe_arena_set_allocated_user_dictionary_command_status(
      ::mozc::user_dictionary::UserDictionaryCommandStatus* user_dictionary_command_status);
  ::mozc::user_dictionary::UserDictionaryCommandStatus* unsafe_arena_release_user_dictionary_command_status();

  // optional .mozc.EngineReloadResponse engine_reload_response = 22;
  bool has_engine_reload_response() const;
  private:
  bool _internal_has_engine_reload_response() const;
  public:
  void clear_engine_reload_response();
  const ::mozc::EngineReloadResponse& engine_reload_response() const;
  ::mozc::EngineReloadResponse* release_engine_reload_response();
  ::mozc::EngineReloadResponse* mutable_engine_reload_response();
  void set_allocated_engine_reload_response(::mozc::EngineReloadResponse* engine_reload_response);
  private:
  const ::mozc::EngineReloadResponse& _internal_engine_reload_response() const;
  ::mozc::EngineReloadResponse* _internal_mutable_engine_reload_response();
  public:
  void unsafe_arena_set_allocated_engine_reload_response(
      ::mozc::EngineReloadResponse* engine_reload_response);
  ::mozc::EngineReloadResponse* unsafe_arena_release_engine_reload_response();

  // optional uint64 id = 1 [jstype = JS_STRING];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .mozc.commands.CompositionMode mode = 2;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::mozc::commands::CompositionMode mode() const;
  void set_mode(::mozc::commands::CompositionMode value);
  private:
  ::mozc::commands::CompositionMode _internal_mode() const;
  void _internal_set_mode(::mozc::commands::CompositionMode value);
  public:

  // optional bool consumed = 3;
  bool has_consumed() const;
  private:
  bool _internal_has_consumed() const;
  public:
  void clear_consumed();
  bool consumed() const;
  void set_consumed(bool value);
  private:
  bool _internal_consumed() const;
  void _internal_set_consumed(bool value);
  public:

  // optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];
  bool has_preedit_method() const;
  private:
  bool _internal_has_preedit_method() const;
  public:
  void clear_preedit_method();
  ::mozc::commands::Output_PreeditMethod preedit_method() const;
  void set_preedit_method(::mozc::commands::Output_PreeditMethod value);
  private:
  ::mozc::commands::Output_PreeditMethod _internal_preedit_method() const;
  void _internal_set_preedit_method(::mozc::commands::Output_PreeditMethod value);
  public:

  // optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  ::mozc::commands::Output_ErrorCode error_code() const;
  void set_error_code(::mozc::commands::Output_ErrorCode value);
  private:
  ::mozc::commands::Output_ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::mozc::commands::Output_ErrorCode value);
  public:

  // optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];
  bool has_launch_tool_mode() const;
  private:
  bool _internal_has_launch_tool_mode() const;
  public:
  void clear_launch_tool_mode();
  ::mozc::commands::Output_ToolMode launch_tool_mode() const;
  void set_launch_tool_mode(::mozc::commands::Output_ToolMode value);
  private:
  ::mozc::commands::Output_ToolMode _internal_launch_tool_mode() const;
  void _internal_set_launch_tool_mode(::mozc::commands::Output_ToolMode value);
  public:

  // @@protoc_insertion_point(class_scope:mozc.commands.Output)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::mozc::commands::Result* result_;
  ::mozc::commands::Preedit* preedit_;
  ::mozc::commands::Candidates* candidates_;
  ::mozc::commands::KeyEvent* key_;
  ::mozc::config::Config* config_;
  ::mozc::commands::Status* status_;
  ::mozc::commands::CandidateList* all_candidate_words_;
  ::mozc::commands::DeletionRange* deletion_range_;
  ::mozc::commands::Output_Callback* callback_;
  ::mozc::commands::GenericStorageEntry* storage_entry_;
  ::mozc::user_dictionary::UserDictionaryCommandStatus* user_dictionary_command_status_;
  ::mozc::EngineReloadResponse* engine_reload_response_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  int mode_;
  bool consumed_;
  int preedit_method_;
  int error_code_;
  int launch_tool_mode_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Command PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Command) */ {
 public:
  inline Command() : Command(nullptr) {};
  virtual ~Command();

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.Command";
  }
  protected:
  explicit Command(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 1,
    kOutputFieldNumber = 2,
  };
  // required .mozc.commands.Input input = 1;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::mozc::commands::Input& input() const;
  ::mozc::commands::Input* release_input();
  ::mozc::commands::Input* mutable_input();
  void set_allocated_input(::mozc::commands::Input* input);
  private:
  const ::mozc::commands::Input& _internal_input() const;
  ::mozc::commands::Input* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::mozc::commands::Input* input);
  ::mozc::commands::Input* unsafe_arena_release_input();

  // required .mozc.commands.Output output = 2;
  bool has_output() const;
  private:
  bool _internal_has_output() const;
  public:
  void clear_output();
  const ::mozc::commands::Output& output() const;
  ::mozc::commands::Output* release_output();
  ::mozc::commands::Output* mutable_output();
  void set_allocated_output(::mozc::commands::Output* output);
  private:
  const ::mozc::commands::Output& _internal_output() const;
  ::mozc::commands::Output* _internal_mutable_output();
  public:
  void unsafe_arena_set_allocated_output(
      ::mozc::commands::Output* output);
  ::mozc::commands::Output* unsafe_arena_release_output();

  // @@protoc_insertion_point(class_scope:mozc.commands.Command)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mozc::commands::Input* input_;
  ::mozc::commands::Output* output_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class CommandList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mozc.commands.CommandList) */ {
 public:
  inline CommandList() : CommandList(nullptr) {};
  virtual ~CommandList();

  CommandList(const CommandList& from);
  CommandList(CommandList&& from) noexcept
    : CommandList() {
    *this = ::std::move(from);
  }

  inline CommandList& operator=(const CommandList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandList& operator=(CommandList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandList* internal_default_instance() {
    return reinterpret_cast<const CommandList*>(
               &_CommandList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CommandList& a, CommandList& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandList* New() const final {
    return CreateMaybeMessage<CommandList>(nullptr);
  }

  CommandList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandList& from);
  void MergeFrom(const CommandList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mozc.commands.CommandList";
  }
  protected:
  explicit CommandList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2fcommands_2eproto);
    return ::descriptor_table_protocol_2fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 1,
  };
  // repeated .mozc.commands.Command commands = 1;
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  ::mozc::commands::Command* mutable_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Command >*
      mutable_commands();
  private:
  const ::mozc::commands::Command& _internal_commands(int index) const;
  ::mozc::commands::Command* _internal_add_commands();
  public:
  const ::mozc::commands::Command& commands(int index) const;
  ::mozc::commands::Command* add_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Command >&
      commands() const;

  // @@protoc_insertion_point(class_scope:mozc.commands.CommandList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Command > commands_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2fcommands_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KeyEvent_ProbableKeyEvent

// optional uint32 key_code = 1;
inline bool KeyEvent_ProbableKeyEvent::_internal_has_key_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyEvent_ProbableKeyEvent::has_key_code() const {
  return _internal_has_key_code();
}
inline void KeyEvent_ProbableKeyEvent::clear_key_code() {
  key_code_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KeyEvent_ProbableKeyEvent::_internal_key_code() const {
  return key_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KeyEvent_ProbableKeyEvent::key_code() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.ProbableKeyEvent.key_code)
  return _internal_key_code();
}
inline void KeyEvent_ProbableKeyEvent::_internal_set_key_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  key_code_ = value;
}
inline void KeyEvent_ProbableKeyEvent::set_key_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_key_code(value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.ProbableKeyEvent.key_code)
}

// optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
inline bool KeyEvent_ProbableKeyEvent::_internal_has_special_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeyEvent_ProbableKeyEvent::has_special_key() const {
  return _internal_has_special_key();
}
inline void KeyEvent_ProbableKeyEvent::clear_special_key() {
  special_key_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::mozc::commands::KeyEvent_SpecialKey KeyEvent_ProbableKeyEvent::_internal_special_key() const {
  return static_cast< ::mozc::commands::KeyEvent_SpecialKey >(special_key_);
}
inline ::mozc::commands::KeyEvent_SpecialKey KeyEvent_ProbableKeyEvent::special_key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.ProbableKeyEvent.special_key)
  return _internal_special_key();
}
inline void KeyEvent_ProbableKeyEvent::_internal_set_special_key(::mozc::commands::KeyEvent_SpecialKey value) {
  assert(::mozc::commands::KeyEvent_SpecialKey_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  special_key_ = value;
}
inline void KeyEvent_ProbableKeyEvent::set_special_key(::mozc::commands::KeyEvent_SpecialKey value) {
  _internal_set_special_key(value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.ProbableKeyEvent.special_key)
}

// repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
inline int KeyEvent_ProbableKeyEvent::_internal_modifier_keys_size() const {
  return modifier_keys_.size();
}
inline int KeyEvent_ProbableKeyEvent::modifier_keys_size() const {
  return _internal_modifier_keys_size();
}
inline void KeyEvent_ProbableKeyEvent::clear_modifier_keys() {
  modifier_keys_.Clear();
}
inline ::mozc::commands::KeyEvent_ModifierKey KeyEvent_ProbableKeyEvent::_internal_modifier_keys(int index) const {
  return static_cast< ::mozc::commands::KeyEvent_ModifierKey >(modifier_keys_.Get(index));
}
inline ::mozc::commands::KeyEvent_ModifierKey KeyEvent_ProbableKeyEvent::modifier_keys(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.ProbableKeyEvent.modifier_keys)
  return _internal_modifier_keys(index);
}
inline void KeyEvent_ProbableKeyEvent::set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.ProbableKeyEvent.modifier_keys)
}
inline void KeyEvent_ProbableKeyEvent::_internal_add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Add(value);
}
inline void KeyEvent_ProbableKeyEvent::add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value) {
  // @@protoc_insertion_point(field_add:mozc.commands.KeyEvent.ProbableKeyEvent.modifier_keys)
  _internal_add_modifier_keys(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
KeyEvent_ProbableKeyEvent::modifier_keys() const {
  // @@protoc_insertion_point(field_list:mozc.commands.KeyEvent.ProbableKeyEvent.modifier_keys)
  return modifier_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
KeyEvent_ProbableKeyEvent::_internal_mutable_modifier_keys() {
  return &modifier_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
KeyEvent_ProbableKeyEvent::mutable_modifier_keys() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.KeyEvent.ProbableKeyEvent.modifier_keys)
  return _internal_mutable_modifier_keys();
}

// optional double probability = 10;
inline bool KeyEvent_ProbableKeyEvent::_internal_has_probability() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KeyEvent_ProbableKeyEvent::has_probability() const {
  return _internal_has_probability();
}
inline void KeyEvent_ProbableKeyEvent::clear_probability() {
  probability_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double KeyEvent_ProbableKeyEvent::_internal_probability() const {
  return probability_;
}
inline double KeyEvent_ProbableKeyEvent::probability() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.ProbableKeyEvent.probability)
  return _internal_probability();
}
inline void KeyEvent_ProbableKeyEvent::_internal_set_probability(double value) {
  _has_bits_[0] |= 0x00000004u;
  probability_ = value;
}
inline void KeyEvent_ProbableKeyEvent::set_probability(double value) {
  _internal_set_probability(value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.ProbableKeyEvent.probability)
}

// -------------------------------------------------------------------

// KeyEvent

// optional uint32 key_code = 1;
inline bool KeyEvent::_internal_has_key_code() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeyEvent::has_key_code() const {
  return _internal_has_key_code();
}
inline void KeyEvent::clear_key_code() {
  key_code_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KeyEvent::_internal_key_code() const {
  return key_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KeyEvent::key_code() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.key_code)
  return _internal_key_code();
}
inline void KeyEvent::_internal_set_key_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  key_code_ = value;
}
inline void KeyEvent::set_key_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_key_code(value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.key_code)
}

// optional uint32 modifiers = 2;
inline bool KeyEvent::_internal_has_modifiers() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KeyEvent::has_modifiers() const {
  return _internal_has_modifiers();
}
inline void KeyEvent::clear_modifiers() {
  modifiers_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KeyEvent::_internal_modifiers() const {
  return modifiers_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KeyEvent::modifiers() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.modifiers)
  return _internal_modifiers();
}
inline void KeyEvent::_internal_set_modifiers(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  modifiers_ = value;
}
inline void KeyEvent::set_modifiers(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_modifiers(value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.modifiers)
}

// optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
inline bool KeyEvent::_internal_has_special_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KeyEvent::has_special_key() const {
  return _internal_has_special_key();
}
inline void KeyEvent::clear_special_key() {
  special_key_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::mozc::commands::KeyEvent_SpecialKey KeyEvent::_internal_special_key() const {
  return static_cast< ::mozc::commands::KeyEvent_SpecialKey >(special_key_);
}
inline ::mozc::commands::KeyEvent_SpecialKey KeyEvent::special_key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.special_key)
  return _internal_special_key();
}
inline void KeyEvent::_internal_set_special_key(::mozc::commands::KeyEvent_SpecialKey value) {
  assert(::mozc::commands::KeyEvent_SpecialKey_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  special_key_ = value;
}
inline void KeyEvent::set_special_key(::mozc::commands::KeyEvent_SpecialKey value) {
  _internal_set_special_key(value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.special_key)
}

// repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
inline int KeyEvent::_internal_modifier_keys_size() const {
  return modifier_keys_.size();
}
inline int KeyEvent::modifier_keys_size() const {
  return _internal_modifier_keys_size();
}
inline void KeyEvent::clear_modifier_keys() {
  modifier_keys_.Clear();
}
inline ::mozc::commands::KeyEvent_ModifierKey KeyEvent::_internal_modifier_keys(int index) const {
  return static_cast< ::mozc::commands::KeyEvent_ModifierKey >(modifier_keys_.Get(index));
}
inline ::mozc::commands::KeyEvent_ModifierKey KeyEvent::modifier_keys(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.modifier_keys)
  return _internal_modifier_keys(index);
}
inline void KeyEvent::set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.modifier_keys)
}
inline void KeyEvent::_internal_add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Add(value);
}
inline void KeyEvent::add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value) {
  // @@protoc_insertion_point(field_add:mozc.commands.KeyEvent.modifier_keys)
  _internal_add_modifier_keys(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
KeyEvent::modifier_keys() const {
  // @@protoc_insertion_point(field_list:mozc.commands.KeyEvent.modifier_keys)
  return modifier_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
KeyEvent::_internal_mutable_modifier_keys() {
  return &modifier_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
KeyEvent::mutable_modifier_keys() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.KeyEvent.modifier_keys)
  return _internal_mutable_modifier_keys();
}

// optional string key_string = 5;
inline bool KeyEvent::_internal_has_key_string() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyEvent::has_key_string() const {
  return _internal_has_key_string();
}
inline void KeyEvent::clear_key_string() {
  key_string_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KeyEvent::key_string() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.key_string)
  return _internal_key_string();
}
inline void KeyEvent::set_key_string(const std::string& value) {
  _internal_set_key_string(value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.key_string)
}
inline std::string* KeyEvent::mutable_key_string() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.KeyEvent.key_string)
  return _internal_mutable_key_string();
}
inline const std::string& KeyEvent::_internal_key_string() const {
  return key_string_.Get();
}
inline void KeyEvent::_internal_set_key_string(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void KeyEvent::set_key_string(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_string_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.KeyEvent.key_string)
}
inline void KeyEvent::set_key_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.commands.KeyEvent.key_string)
}
inline void KeyEvent::set_key_string(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.KeyEvent.key_string)
}
inline std::string* KeyEvent::_internal_mutable_key_string() {
  _has_bits_[0] |= 0x00000001u;
  return key_string_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* KeyEvent::release_key_string() {
  // @@protoc_insertion_point(field_release:mozc.commands.KeyEvent.key_string)
  if (!_internal_has_key_string()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_string_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KeyEvent::set_allocated_key_string(std::string* key_string) {
  if (key_string != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_string,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.KeyEvent.key_string)
}
inline std::string* KeyEvent::unsafe_arena_release_key_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.commands.KeyEvent.key_string)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return key_string_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void KeyEvent::unsafe_arena_set_allocated_key_string(
    std::string* key_string) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (key_string != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_string_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key_string, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.KeyEvent.key_string)
}

// optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];
inline bool KeyEvent::_internal_has_input_style() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool KeyEvent::has_input_style() const {
  return _internal_has_input_style();
}
inline void KeyEvent::clear_input_style() {
  input_style_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::mozc::commands::KeyEvent_InputStyle KeyEvent::_internal_input_style() const {
  return static_cast< ::mozc::commands::KeyEvent_InputStyle >(input_style_);
}
inline ::mozc::commands::KeyEvent_InputStyle KeyEvent::input_style() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.input_style)
  return _internal_input_style();
}
inline void KeyEvent::_internal_set_input_style(::mozc::commands::KeyEvent_InputStyle value) {
  assert(::mozc::commands::KeyEvent_InputStyle_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  input_style_ = value;
}
inline void KeyEvent::set_input_style(::mozc::commands::KeyEvent_InputStyle value) {
  _internal_set_input_style(value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.input_style)
}

// optional .mozc.commands.CompositionMode mode = 7;
inline bool KeyEvent::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool KeyEvent::has_mode() const {
  return _internal_has_mode();
}
inline void KeyEvent::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::mozc::commands::CompositionMode KeyEvent::_internal_mode() const {
  return static_cast< ::mozc::commands::CompositionMode >(mode_);
}
inline ::mozc::commands::CompositionMode KeyEvent::mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.mode)
  return _internal_mode();
}
inline void KeyEvent::_internal_set_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  mode_ = value;
}
inline void KeyEvent::set_mode(::mozc::commands::CompositionMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.mode)
}

// repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;
inline int KeyEvent::_internal_probable_key_event_size() const {
  return probable_key_event_.size();
}
inline int KeyEvent::probable_key_event_size() const {
  return _internal_probable_key_event_size();
}
inline void KeyEvent::clear_probable_key_event() {
  probable_key_event_.Clear();
}
inline ::mozc::commands::KeyEvent_ProbableKeyEvent* KeyEvent::mutable_probable_key_event(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.KeyEvent.probable_key_event)
  return probable_key_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >*
KeyEvent::mutable_probable_key_event() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.KeyEvent.probable_key_event)
  return &probable_key_event_;
}
inline const ::mozc::commands::KeyEvent_ProbableKeyEvent& KeyEvent::_internal_probable_key_event(int index) const {
  return probable_key_event_.Get(index);
}
inline const ::mozc::commands::KeyEvent_ProbableKeyEvent& KeyEvent::probable_key_event(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.probable_key_event)
  return _internal_probable_key_event(index);
}
inline ::mozc::commands::KeyEvent_ProbableKeyEvent* KeyEvent::_internal_add_probable_key_event() {
  return probable_key_event_.Add();
}
inline ::mozc::commands::KeyEvent_ProbableKeyEvent* KeyEvent::add_probable_key_event() {
  // @@protoc_insertion_point(field_add:mozc.commands.KeyEvent.probable_key_event)
  return _internal_add_probable_key_event();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >&
KeyEvent::probable_key_event() const {
  // @@protoc_insertion_point(field_list:mozc.commands.KeyEvent.probable_key_event)
  return probable_key_event_;
}

// optional bool activated = 9;
inline bool KeyEvent::_internal_has_activated() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool KeyEvent::has_activated() const {
  return _internal_has_activated();
}
inline void KeyEvent::clear_activated() {
  activated_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool KeyEvent::_internal_activated() const {
  return activated_;
}
inline bool KeyEvent::activated() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.activated)
  return _internal_activated();
}
inline void KeyEvent::_internal_set_activated(bool value) {
  _has_bits_[0] |= 0x00000040u;
  activated_ = value;
}
inline void KeyEvent::set_activated(bool value) {
  _internal_set_activated(value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.activated)
}

// -------------------------------------------------------------------

// GenericStorageEntry

// optional .mozc.commands.GenericStorageEntry.StorageType type = 1;
inline bool GenericStorageEntry::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GenericStorageEntry::has_type() const {
  return _internal_has_type();
}
inline void GenericStorageEntry::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::mozc::commands::GenericStorageEntry_StorageType GenericStorageEntry::_internal_type() const {
  return static_cast< ::mozc::commands::GenericStorageEntry_StorageType >(type_);
}
inline ::mozc::commands::GenericStorageEntry_StorageType GenericStorageEntry::type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.GenericStorageEntry.type)
  return _internal_type();
}
inline void GenericStorageEntry::_internal_set_type(::mozc::commands::GenericStorageEntry_StorageType value) {
  assert(::mozc::commands::GenericStorageEntry_StorageType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void GenericStorageEntry::set_type(::mozc::commands::GenericStorageEntry_StorageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mozc.commands.GenericStorageEntry.type)
}

// optional string key = 2;
inline bool GenericStorageEntry::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GenericStorageEntry::has_key() const {
  return _internal_has_key();
}
inline void GenericStorageEntry::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericStorageEntry::key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.GenericStorageEntry.key)
  return _internal_key();
}
inline void GenericStorageEntry::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:mozc.commands.GenericStorageEntry.key)
}
inline std::string* GenericStorageEntry::mutable_key() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.GenericStorageEntry.key)
  return _internal_mutable_key();
}
inline const std::string& GenericStorageEntry::_internal_key() const {
  return key_.Get();
}
inline void GenericStorageEntry::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenericStorageEntry::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.GenericStorageEntry.key)
}
inline void GenericStorageEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.commands.GenericStorageEntry.key)
}
inline void GenericStorageEntry::set_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.GenericStorageEntry.key)
}
inline std::string* GenericStorageEntry::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenericStorageEntry::release_key() {
  // @@protoc_insertion_point(field_release:mozc.commands.GenericStorageEntry.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenericStorageEntry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.GenericStorageEntry.key)
}
inline std::string* GenericStorageEntry::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.commands.GenericStorageEntry.key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenericStorageEntry::unsafe_arena_set_allocated_key(
    std::string* key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.GenericStorageEntry.key)
}

// repeated bytes value = 3;
inline int GenericStorageEntry::_internal_value_size() const {
  return value_.size();
}
inline int GenericStorageEntry::value_size() const {
  return _internal_value_size();
}
inline void GenericStorageEntry::clear_value() {
  value_.Clear();
}
inline std::string* GenericStorageEntry::add_value() {
  // @@protoc_insertion_point(field_add_mutable:mozc.commands.GenericStorageEntry.value)
  return _internal_add_value();
}
inline const std::string& GenericStorageEntry::_internal_value(int index) const {
  return value_.Get(index);
}
inline const std::string& GenericStorageEntry::value(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.GenericStorageEntry.value)
  return _internal_value(index);
}
inline std::string* GenericStorageEntry::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.GenericStorageEntry.value)
  return value_.Mutable(index);
}
inline void GenericStorageEntry::set_value(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:mozc.commands.GenericStorageEntry.value)
  value_.Mutable(index)->assign(value);
}
inline void GenericStorageEntry::set_value(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:mozc.commands.GenericStorageEntry.value)
  value_.Mutable(index)->assign(std::move(value));
}
inline void GenericStorageEntry::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mozc.commands.GenericStorageEntry.value)
}
inline void GenericStorageEntry::set_value(int index, const void* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.GenericStorageEntry.value)
}
inline std::string* GenericStorageEntry::_internal_add_value() {
  return value_.Add();
}
inline void GenericStorageEntry::add_value(const std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mozc.commands.GenericStorageEntry.value)
}
inline void GenericStorageEntry::add_value(std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mozc.commands.GenericStorageEntry.value)
}
inline void GenericStorageEntry::add_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mozc.commands.GenericStorageEntry.value)
}
inline void GenericStorageEntry::add_value(const void* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mozc.commands.GenericStorageEntry.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GenericStorageEntry::value() const {
  // @@protoc_insertion_point(field_list:mozc.commands.GenericStorageEntry.value)
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GenericStorageEntry::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.GenericStorageEntry.value)
  return &value_;
}

// -------------------------------------------------------------------

// SessionCommand

// required .mozc.commands.SessionCommand.CommandType type = 1;
inline bool SessionCommand::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SessionCommand::has_type() const {
  return _internal_has_type();
}
inline void SessionCommand::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::mozc::commands::SessionCommand_CommandType SessionCommand::_internal_type() const {
  return static_cast< ::mozc::commands::SessionCommand_CommandType >(type_);
}
inline ::mozc::commands::SessionCommand_CommandType SessionCommand::type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.type)
  return _internal_type();
}
inline void SessionCommand::_internal_set_type(::mozc::commands::SessionCommand_CommandType value) {
  assert(::mozc::commands::SessionCommand_CommandType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void SessionCommand::set_type(::mozc::commands::SessionCommand_CommandType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.type)
}

// optional int32 id = 2;
inline bool SessionCommand::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SessionCommand::has_id() const {
  return _internal_has_id();
}
inline void SessionCommand::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SessionCommand::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SessionCommand::id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.id)
  return _internal_id();
}
inline void SessionCommand::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
}
inline void SessionCommand::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.id)
}

// optional .mozc.commands.CompositionMode composition_mode = 3;
inline bool SessionCommand::_internal_has_composition_mode() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SessionCommand::has_composition_mode() const {
  return _internal_has_composition_mode();
}
inline void SessionCommand::clear_composition_mode() {
  composition_mode_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::mozc::commands::CompositionMode SessionCommand::_internal_composition_mode() const {
  return static_cast< ::mozc::commands::CompositionMode >(composition_mode_);
}
inline ::mozc::commands::CompositionMode SessionCommand::composition_mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.composition_mode)
  return _internal_composition_mode();
}
inline void SessionCommand::_internal_set_composition_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  composition_mode_ = value;
}
inline void SessionCommand::set_composition_mode(::mozc::commands::CompositionMode value) {
  _internal_set_composition_mode(value);
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.composition_mode)
}

// optional string text = 4;
inline bool SessionCommand::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SessionCommand::has_text() const {
  return _internal_has_text();
}
inline void SessionCommand::clear_text() {
  text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionCommand::text() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.text)
  return _internal_text();
}
inline void SessionCommand::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.text)
}
inline std::string* SessionCommand::mutable_text() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.SessionCommand.text)
  return _internal_mutable_text();
}
inline const std::string& SessionCommand::_internal_text() const {
  return text_.Get();
}
inline void SessionCommand::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SessionCommand::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.SessionCommand.text)
}
inline void SessionCommand::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.commands.SessionCommand.text)
}
inline void SessionCommand::set_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.SessionCommand.text)
}
inline std::string* SessionCommand::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SessionCommand::release_text() {
  // @@protoc_insertion_point(field_release:mozc.commands.SessionCommand.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SessionCommand::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.SessionCommand.text)
}
inline std::string* SessionCommand::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.commands.SessionCommand.text)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return text_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SessionCommand::unsafe_arena_set_allocated_text(
    std::string* text) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      text, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.SessionCommand.text)
}

// optional uint32 cursor_position = 5;
inline bool SessionCommand::_internal_has_cursor_position() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SessionCommand::has_cursor_position() const {
  return _internal_has_cursor_position();
}
inline void SessionCommand::clear_cursor_position() {
  cursor_position_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionCommand::_internal_cursor_position() const {
  return cursor_position_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionCommand::cursor_position() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.cursor_position)
  return _internal_cursor_position();
}
inline void SessionCommand::_internal_set_cursor_position(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  cursor_position_ = value;
}
inline void SessionCommand::set_cursor_position(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_cursor_position(value);
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.cursor_position)
}

// optional .mozc.commands.SessionCommand.UsageStatsEvent usage_stats_event = 7;
inline bool SessionCommand::_internal_has_usage_stats_event() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SessionCommand::has_usage_stats_event() const {
  return _internal_has_usage_stats_event();
}
inline void SessionCommand::clear_usage_stats_event() {
  usage_stats_event_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::mozc::commands::SessionCommand_UsageStatsEvent SessionCommand::_internal_usage_stats_event() const {
  return static_cast< ::mozc::commands::SessionCommand_UsageStatsEvent >(usage_stats_event_);
}
inline ::mozc::commands::SessionCommand_UsageStatsEvent SessionCommand::usage_stats_event() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.usage_stats_event)
  return _internal_usage_stats_event();
}
inline void SessionCommand::_internal_set_usage_stats_event(::mozc::commands::SessionCommand_UsageStatsEvent value) {
  assert(::mozc::commands::SessionCommand_UsageStatsEvent_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  usage_stats_event_ = value;
}
inline void SessionCommand::set_usage_stats_event(::mozc::commands::SessionCommand_UsageStatsEvent value) {
  _internal_set_usage_stats_event(value);
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.usage_stats_event)
}

// optional int32 usage_stats_event_int_value = 9;
inline bool SessionCommand::_internal_has_usage_stats_event_int_value() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SessionCommand::has_usage_stats_event_int_value() const {
  return _internal_has_usage_stats_event_int_value();
}
inline void SessionCommand::clear_usage_stats_event_int_value() {
  usage_stats_event_int_value_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SessionCommand::_internal_usage_stats_event_int_value() const {
  return usage_stats_event_int_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SessionCommand::usage_stats_event_int_value() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.usage_stats_event_int_value)
  return _internal_usage_stats_event_int_value();
}
inline void SessionCommand::_internal_set_usage_stats_event_int_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  usage_stats_event_int_value_ = value;
}
inline void SessionCommand::set_usage_stats_event_int_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_usage_stats_event_int_value(value);
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.usage_stats_event_int_value)
}

// -------------------------------------------------------------------

// Context

// optional string preceding_text = 1;
inline bool Context::_internal_has_preceding_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Context::has_preceding_text() const {
  return _internal_has_preceding_text();
}
inline void Context::clear_preceding_text() {
  preceding_text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Context::preceding_text() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.preceding_text)
  return _internal_preceding_text();
}
inline void Context::set_preceding_text(const std::string& value) {
  _internal_set_preceding_text(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Context.preceding_text)
}
inline std::string* Context::mutable_preceding_text() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Context.preceding_text)
  return _internal_mutable_preceding_text();
}
inline const std::string& Context::_internal_preceding_text() const {
  return preceding_text_.Get();
}
inline void Context::_internal_set_preceding_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  preceding_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Context::set_preceding_text(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  preceding_text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Context.preceding_text)
}
inline void Context::set_preceding_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  preceding_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.commands.Context.preceding_text)
}
inline void Context::set_preceding_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  preceding_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Context.preceding_text)
}
inline std::string* Context::_internal_mutable_preceding_text() {
  _has_bits_[0] |= 0x00000001u;
  return preceding_text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Context::release_preceding_text() {
  // @@protoc_insertion_point(field_release:mozc.commands.Context.preceding_text)
  if (!_internal_has_preceding_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return preceding_text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Context::set_allocated_preceding_text(std::string* preceding_text) {
  if (preceding_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  preceding_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), preceding_text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Context.preceding_text)
}
inline std::string* Context::unsafe_arena_release_preceding_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.commands.Context.preceding_text)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return preceding_text_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Context::unsafe_arena_set_allocated_preceding_text(
    std::string* preceding_text) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (preceding_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  preceding_text_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      preceding_text, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Context.preceding_text)
}

// optional string following_text = 2;
inline bool Context::_internal_has_following_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Context::has_following_text() const {
  return _internal_has_following_text();
}
inline void Context::clear_following_text() {
  following_text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Context::following_text() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.following_text)
  return _internal_following_text();
}
inline void Context::set_following_text(const std::string& value) {
  _internal_set_following_text(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Context.following_text)
}
inline std::string* Context::mutable_following_text() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Context.following_text)
  return _internal_mutable_following_text();
}
inline const std::string& Context::_internal_following_text() const {
  return following_text_.Get();
}
inline void Context::_internal_set_following_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  following_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Context::set_following_text(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  following_text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Context.following_text)
}
inline void Context::set_following_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  following_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.commands.Context.following_text)
}
inline void Context::set_following_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  following_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Context.following_text)
}
inline std::string* Context::_internal_mutable_following_text() {
  _has_bits_[0] |= 0x00000002u;
  return following_text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Context::release_following_text() {
  // @@protoc_insertion_point(field_release:mozc.commands.Context.following_text)
  if (!_internal_has_following_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return following_text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Context::set_allocated_following_text(std::string* following_text) {
  if (following_text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  following_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), following_text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Context.following_text)
}
inline std::string* Context::unsafe_arena_release_following_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.commands.Context.following_text)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return following_text_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Context::unsafe_arena_set_allocated_following_text(
    std::string* following_text) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (following_text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  following_text_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      following_text, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Context.following_text)
}

// optional bool suppress_suggestion = 3 [default = false];
inline bool Context::_internal_has_suppress_suggestion() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Context::has_suppress_suggestion() const {
  return _internal_has_suppress_suggestion();
}
inline void Context::clear_suppress_suggestion() {
  suppress_suggestion_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Context::_internal_suppress_suggestion() const {
  return suppress_suggestion_;
}
inline bool Context::suppress_suggestion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.suppress_suggestion)
  return _internal_suppress_suggestion();
}
inline void Context::_internal_set_suppress_suggestion(bool value) {
  _has_bits_[0] |= 0x00000004u;
  suppress_suggestion_ = value;
}
inline void Context::set_suppress_suggestion(bool value) {
  _internal_set_suppress_suggestion(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Context.suppress_suggestion)
}

// optional .mozc.commands.Context.InputFieldType input_field_type = 4;
inline bool Context::_internal_has_input_field_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Context::has_input_field_type() const {
  return _internal_has_input_field_type();
}
inline void Context::clear_input_field_type() {
  input_field_type_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::mozc::commands::Context_InputFieldType Context::_internal_input_field_type() const {
  return static_cast< ::mozc::commands::Context_InputFieldType >(input_field_type_);
}
inline ::mozc::commands::Context_InputFieldType Context::input_field_type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.input_field_type)
  return _internal_input_field_type();
}
inline void Context::_internal_set_input_field_type(::mozc::commands::Context_InputFieldType value) {
  assert(::mozc::commands::Context_InputFieldType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  input_field_type_ = value;
}
inline void Context::set_input_field_type(::mozc::commands::Context_InputFieldType value) {
  _internal_set_input_field_type(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Context.input_field_type)
}

// optional int32 revision = 5 [default = 0];
inline bool Context::_internal_has_revision() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Context::has_revision() const {
  return _internal_has_revision();
}
inline void Context::clear_revision() {
  revision_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Context::_internal_revision() const {
  return revision_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Context::revision() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.revision)
  return _internal_revision();
}
inline void Context::_internal_set_revision(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  revision_ = value;
}
inline void Context::set_revision(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Context.revision)
}

// repeated string experimental_features = 100;
inline int Context::_internal_experimental_features_size() const {
  return experimental_features_.size();
}
inline int Context::experimental_features_size() const {
  return _internal_experimental_features_size();
}
inline void Context::clear_experimental_features() {
  experimental_features_.Clear();
}
inline std::string* Context::add_experimental_features() {
  // @@protoc_insertion_point(field_add_mutable:mozc.commands.Context.experimental_features)
  return _internal_add_experimental_features();
}
inline const std::string& Context::_internal_experimental_features(int index) const {
  return experimental_features_.Get(index);
}
inline const std::string& Context::experimental_features(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.experimental_features)
  return _internal_experimental_features(index);
}
inline std::string* Context::mutable_experimental_features(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Context.experimental_features)
  return experimental_features_.Mutable(index);
}
inline void Context::set_experimental_features(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:mozc.commands.Context.experimental_features)
  experimental_features_.Mutable(index)->assign(value);
}
inline void Context::set_experimental_features(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:mozc.commands.Context.experimental_features)
  experimental_features_.Mutable(index)->assign(std::move(value));
}
inline void Context::set_experimental_features(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  experimental_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mozc.commands.Context.experimental_features)
}
inline void Context::set_experimental_features(int index, const char* value, size_t size) {
  experimental_features_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Context.experimental_features)
}
inline std::string* Context::_internal_add_experimental_features() {
  return experimental_features_.Add();
}
inline void Context::add_experimental_features(const std::string& value) {
  experimental_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mozc.commands.Context.experimental_features)
}
inline void Context::add_experimental_features(std::string&& value) {
  experimental_features_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mozc.commands.Context.experimental_features)
}
inline void Context::add_experimental_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  experimental_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mozc.commands.Context.experimental_features)
}
inline void Context::add_experimental_features(const char* value, size_t size) {
  experimental_features_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mozc.commands.Context.experimental_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Context::experimental_features() const {
  // @@protoc_insertion_point(field_list:mozc.commands.Context.experimental_features)
  return experimental_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Context::mutable_experimental_features() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.Context.experimental_features)
  return &experimental_features_;
}

// -------------------------------------------------------------------

// Capability

// optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];
inline bool Capability::_internal_has_text_deletion() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Capability::has_text_deletion() const {
  return _internal_has_text_deletion();
}
inline void Capability::clear_text_deletion() {
  text_deletion_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::mozc::commands::Capability_TextDeletionCapabilityType Capability::_internal_text_deletion() const {
  return static_cast< ::mozc::commands::Capability_TextDeletionCapabilityType >(text_deletion_);
}
inline ::mozc::commands::Capability_TextDeletionCapabilityType Capability::text_deletion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Capability.text_deletion)
  return _internal_text_deletion();
}
inline void Capability::_internal_set_text_deletion(::mozc::commands::Capability_TextDeletionCapabilityType value) {
  assert(::mozc::commands::Capability_TextDeletionCapabilityType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  text_deletion_ = value;
}
inline void Capability::set_text_deletion(::mozc::commands::Capability_TextDeletionCapabilityType value) {
  _internal_set_text_deletion(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Capability.text_deletion)
}

// -------------------------------------------------------------------

// DecoderExperimentParams

// optional bool enable_simplified_ranking = 1;
inline bool DecoderExperimentParams::_internal_has_enable_simplified_ranking() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DecoderExperimentParams::has_enable_simplified_ranking() const {
  return _internal_has_enable_simplified_ranking();
}
inline void DecoderExperimentParams::clear_enable_simplified_ranking() {
  enable_simplified_ranking_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool DecoderExperimentParams::_internal_enable_simplified_ranking() const {
  return enable_simplified_ranking_;
}
inline bool DecoderExperimentParams::enable_simplified_ranking() const {
  // @@protoc_insertion_point(field_get:mozc.commands.DecoderExperimentParams.enable_simplified_ranking)
  return _internal_enable_simplified_ranking();
}
inline void DecoderExperimentParams::_internal_set_enable_simplified_ranking(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enable_simplified_ranking_ = value;
}
inline void DecoderExperimentParams::set_enable_simplified_ranking(bool value) {
  _internal_set_enable_simplified_ranking(value);
  // @@protoc_insertion_point(field_set:mozc.commands.DecoderExperimentParams.enable_simplified_ranking)
}

// -------------------------------------------------------------------

// Request

// optional bool zero_query_suggestion = 1 [default = false];
inline bool Request::_internal_has_zero_query_suggestion() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Request::has_zero_query_suggestion() const {
  return _internal_has_zero_query_suggestion();
}
inline void Request::clear_zero_query_suggestion() {
  zero_query_suggestion_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Request::_internal_zero_query_suggestion() const {
  return zero_query_suggestion_;
}
inline bool Request::zero_query_suggestion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.zero_query_suggestion)
  return _internal_zero_query_suggestion();
}
inline void Request::_internal_set_zero_query_suggestion(bool value) {
  _has_bits_[0] |= 0x00000008u;
  zero_query_suggestion_ = value;
}
inline void Request::set_zero_query_suggestion(bool value) {
  _internal_set_zero_query_suggestion(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.zero_query_suggestion)
}

// optional bool mixed_conversion = 2 [default = false];
inline bool Request::_internal_has_mixed_conversion() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Request::has_mixed_conversion() const {
  return _internal_has_mixed_conversion();
}
inline void Request::clear_mixed_conversion() {
  mixed_conversion_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Request::_internal_mixed_conversion() const {
  return mixed_conversion_;
}
inline bool Request::mixed_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.mixed_conversion)
  return _internal_mixed_conversion();
}
inline void Request::_internal_set_mixed_conversion(bool value) {
  _has_bits_[0] |= 0x00000010u;
  mixed_conversion_ = value;
}
inline void Request::set_mixed_conversion(bool value) {
  _internal_set_mixed_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.mixed_conversion)
}

// optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];
inline bool Request::_internal_has_special_romanji_table() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Request::has_special_romanji_table() const {
  return _internal_has_special_romanji_table();
}
inline void Request::clear_special_romanji_table() {
  special_romanji_table_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::mozc::commands::Request_SpecialRomanjiTable Request::_internal_special_romanji_table() const {
  return static_cast< ::mozc::commands::Request_SpecialRomanjiTable >(special_romanji_table_);
}
inline ::mozc::commands::Request_SpecialRomanjiTable Request::special_romanji_table() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.special_romanji_table)
  return _internal_special_romanji_table();
}
inline void Request::_internal_set_special_romanji_table(::mozc::commands::Request_SpecialRomanjiTable value) {
  assert(::mozc::commands::Request_SpecialRomanjiTable_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  special_romanji_table_ = value;
}
inline void Request::set_special_romanji_table(::mozc::commands::Request_SpecialRomanjiTable value) {
  _internal_set_special_romanji_table(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.special_romanji_table)
}

// optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];
inline bool Request::_internal_has_space_on_alphanumeric() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Request::has_space_on_alphanumeric() const {
  return _internal_has_space_on_alphanumeric();
}
inline void Request::clear_space_on_alphanumeric() {
  space_on_alphanumeric_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::mozc::commands::Request_SpaceOnAlphanumeric Request::_internal_space_on_alphanumeric() const {
  return static_cast< ::mozc::commands::Request_SpaceOnAlphanumeric >(space_on_alphanumeric_);
}
inline ::mozc::commands::Request_SpaceOnAlphanumeric Request::space_on_alphanumeric() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.space_on_alphanumeric)
  return _internal_space_on_alphanumeric();
}
inline void Request::_internal_set_space_on_alphanumeric(::mozc::commands::Request_SpaceOnAlphanumeric value) {
  assert(::mozc::commands::Request_SpaceOnAlphanumeric_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  space_on_alphanumeric_ = value;
}
inline void Request::set_space_on_alphanumeric(::mozc::commands::Request_SpaceOnAlphanumeric value) {
  _internal_set_space_on_alphanumeric(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.space_on_alphanumeric)
}

// optional string keyboard_name = 7;
inline bool Request::_internal_has_keyboard_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Request::has_keyboard_name() const {
  return _internal_has_keyboard_name();
}
inline void Request::clear_keyboard_name() {
  keyboard_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Request::keyboard_name() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.keyboard_name)
  return _internal_keyboard_name();
}
inline void Request::set_keyboard_name(const std::string& value) {
  _internal_set_keyboard_name(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.keyboard_name)
}
inline std::string* Request::mutable_keyboard_name() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Request.keyboard_name)
  return _internal_mutable_keyboard_name();
}
inline const std::string& Request::_internal_keyboard_name() const {
  return keyboard_name_.Get();
}
inline void Request::_internal_set_keyboard_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  keyboard_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Request::set_keyboard_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  keyboard_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Request.keyboard_name)
}
inline void Request::set_keyboard_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  keyboard_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.commands.Request.keyboard_name)
}
inline void Request::set_keyboard_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  keyboard_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Request.keyboard_name)
}
inline std::string* Request::_internal_mutable_keyboard_name() {
  _has_bits_[0] |= 0x00000001u;
  return keyboard_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Request::release_keyboard_name() {
  // @@protoc_insertion_point(field_release:mozc.commands.Request.keyboard_name)
  if (!_internal_has_keyboard_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return keyboard_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Request::set_allocated_keyboard_name(std::string* keyboard_name) {
  if (keyboard_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  keyboard_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyboard_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Request.keyboard_name)
}
inline std::string* Request::unsafe_arena_release_keyboard_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.commands.Request.keyboard_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return keyboard_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Request::unsafe_arena_set_allocated_keyboard_name(
    std::string* keyboard_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (keyboard_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  keyboard_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      keyboard_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Request.keyboard_name)
}

// optional bool update_input_mode_from_surrounding_text = 8 [default = true];
inline bool Request::_internal_has_update_input_mode_from_surrounding_text() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Request::has_update_input_mode_from_surrounding_text() const {
  return _internal_has_update_input_mode_from_surrounding_text();
}
inline void Request::clear_update_input_mode_from_surrounding_text() {
  update_input_mode_from_surrounding_text_ = true;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool Request::_internal_update_input_mode_from_surrounding_text() const {
  return update_input_mode_from_surrounding_text_;
}
inline bool Request::update_input_mode_from_surrounding_text() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.update_input_mode_from_surrounding_text)
  return _internal_update_input_mode_from_surrounding_text();
}
inline void Request::_internal_set_update_input_mode_from_surrounding_text(bool value) {
  _has_bits_[0] |= 0x00000800u;
  update_input_mode_from_surrounding_text_ = value;
}
inline void Request::set_update_input_mode_from_surrounding_text(bool value) {
  _internal_set_update_input_mode_from_surrounding_text(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.update_input_mode_from_surrounding_text)
}

// optional bool kana_modifier_insensitive_conversion = 9 [default = false];
inline bool Request::_internal_has_kana_modifier_insensitive_conversion() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Request::has_kana_modifier_insensitive_conversion() const {
  return _internal_has_kana_modifier_insensitive_conversion();
}
inline void Request::clear_kana_modifier_insensitive_conversion() {
  kana_modifier_insensitive_conversion_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Request::_internal_kana_modifier_insensitive_conversion() const {
  return kana_modifier_insensitive_conversion_;
}
inline bool Request::kana_modifier_insensitive_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.kana_modifier_insensitive_conversion)
  return _internal_kana_modifier_insensitive_conversion();
}
inline void Request::_internal_set_kana_modifier_insensitive_conversion(bool value) {
  _has_bits_[0] |= 0x00000020u;
  kana_modifier_insensitive_conversion_ = value;
}
inline void Request::set_kana_modifier_insensitive_conversion(bool value) {
  _internal_set_kana_modifier_insensitive_conversion(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.kana_modifier_insensitive_conversion)
}

// optional bool auto_partial_suggestion = 10 [default = false];
inline bool Request::_internal_has_auto_partial_suggestion() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Request::has_auto_partial_suggestion() const {
  return _internal_has_auto_partial_suggestion();
}
inline void Request::clear_auto_partial_suggestion() {
  auto_partial_suggestion_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Request::_internal_auto_partial_suggestion() const {
  return auto_partial_suggestion_;
}
inline bool Request::auto_partial_suggestion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.auto_partial_suggestion)
  return _internal_auto_partial_suggestion();
}
inline void Request::_internal_set_auto_partial_suggestion(bool value) {
  _has_bits_[0] |= 0x00000040u;
  auto_partial_suggestion_ = value;
}
inline void Request::set_auto_partial_suggestion(bool value) {
  _internal_set_auto_partial_suggestion(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.auto_partial_suggestion)
}

// optional int32 available_emoji_carrier = 11 [default = 1];
inline bool Request::_internal_has_available_emoji_carrier() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Request::has_available_emoji_carrier() const {
  return _internal_has_available_emoji_carrier();
}
inline void Request::clear_available_emoji_carrier() {
  available_emoji_carrier_ = 1;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::_internal_available_emoji_carrier() const {
  return available_emoji_carrier_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::available_emoji_carrier() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.available_emoji_carrier)
  return _internal_available_emoji_carrier();
}
inline void Request::_internal_set_available_emoji_carrier(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00001000u;
  available_emoji_carrier_ = value;
}
inline void Request::set_available_emoji_carrier(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_available_emoji_carrier(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.available_emoji_carrier)
}

// optional int32 emoji_rewriter_capability = 12 [default = 1];
inline bool Request::_internal_has_emoji_rewriter_capability() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Request::has_emoji_rewriter_capability() const {
  return _internal_has_emoji_rewriter_capability();
}
inline void Request::clear_emoji_rewriter_capability() {
  emoji_rewriter_capability_ = 1;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::_internal_emoji_rewriter_capability() const {
  return emoji_rewriter_capability_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::emoji_rewriter_capability() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.emoji_rewriter_capability)
  return _internal_emoji_rewriter_capability();
}
inline void Request::_internal_set_emoji_rewriter_capability(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00002000u;
  emoji_rewriter_capability_ = value;
}
inline void Request::set_emoji_rewriter_capability(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_emoji_rewriter_capability(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.emoji_rewriter_capability)
}

// optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];
inline bool Request::_internal_has_crossing_edge_behavior() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Request::has_crossing_edge_behavior() const {
  return _internal_has_crossing_edge_behavior();
}
inline void Request::clear_crossing_edge_behavior() {
  crossing_edge_behavior_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::mozc::commands::Request_CrossingEdgeBehavior Request::_internal_crossing_edge_behavior() const {
  return static_cast< ::mozc::commands::Request_CrossingEdgeBehavior >(crossing_edge_behavior_);
}
inline ::mozc::commands::Request_CrossingEdgeBehavior Request::crossing_edge_behavior() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.crossing_edge_behavior)
  return _internal_crossing_edge_behavior();
}
inline void Request::_internal_set_crossing_edge_behavior(::mozc::commands::Request_CrossingEdgeBehavior value) {
  assert(::mozc::commands::Request_CrossingEdgeBehavior_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  crossing_edge_behavior_ = value;
}
inline void Request::set_crossing_edge_behavior(::mozc::commands::Request_CrossingEdgeBehavior value) {
  _internal_set_crossing_edge_behavior(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.crossing_edge_behavior)
}

// optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];
inline bool Request::_internal_has_language_aware_input() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Request::has_language_aware_input() const {
  return _internal_has_language_aware_input();
}
inline void Request::clear_language_aware_input() {
  language_aware_input_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::mozc::commands::Request_LanguageAwareInputBehavior Request::_internal_language_aware_input() const {
  return static_cast< ::mozc::commands::Request_LanguageAwareInputBehavior >(language_aware_input_);
}
inline ::mozc::commands::Request_LanguageAwareInputBehavior Request::language_aware_input() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.language_aware_input)
  return _internal_language_aware_input();
}
inline void Request::_internal_set_language_aware_input(::mozc::commands::Request_LanguageAwareInputBehavior value) {
  assert(::mozc::commands::Request_LanguageAwareInputBehavior_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  language_aware_input_ = value;
}
inline void Request::set_language_aware_input(::mozc::commands::Request_LanguageAwareInputBehavior value) {
  _internal_set_language_aware_input(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.language_aware_input)
}

// optional int32 candidate_page_size = 15 [default = 9];
inline bool Request::_internal_has_candidate_page_size() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Request::has_candidate_page_size() const {
  return _internal_has_candidate_page_size();
}
inline void Request::clear_candidate_page_size() {
  candidate_page_size_ = 9;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::_internal_candidate_page_size() const {
  return candidate_page_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::candidate_page_size() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.candidate_page_size)
  return _internal_candidate_page_size();
}
inline void Request::_internal_set_candidate_page_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00004000u;
  candidate_page_size_ = value;
}
inline void Request::set_candidate_page_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_candidate_page_size(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.candidate_page_size)
}

// optional int32 candidates_size_limit = 16;
inline bool Request::_internal_has_candidates_size_limit() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Request::has_candidates_size_limit() const {
  return _internal_has_candidates_size_limit();
}
inline void Request::clear_candidates_size_limit() {
  candidates_size_limit_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::_internal_candidates_size_limit() const {
  return candidates_size_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::candidates_size_limit() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.candidates_size_limit)
  return _internal_candidates_size_limit();
}
inline void Request::_internal_set_candidates_size_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  candidates_size_limit_ = value;
}
inline void Request::set_candidates_size_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_candidates_size_limit(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.candidates_size_limit)
}

// optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;
inline bool Request::_internal_has_decoder_experiment_params() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || decoder_experiment_params_ != nullptr);
  return value;
}
inline bool Request::has_decoder_experiment_params() const {
  return _internal_has_decoder_experiment_params();
}
inline void Request::clear_decoder_experiment_params() {
  if (decoder_experiment_params_ != nullptr) decoder_experiment_params_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mozc::commands::DecoderExperimentParams& Request::_internal_decoder_experiment_params() const {
  const ::mozc::commands::DecoderExperimentParams* p = decoder_experiment_params_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::DecoderExperimentParams*>(
      &::mozc::commands::_DecoderExperimentParams_default_instance_);
}
inline const ::mozc::commands::DecoderExperimentParams& Request::decoder_experiment_params() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.decoder_experiment_params)
  return _internal_decoder_experiment_params();
}
inline void Request::unsafe_arena_set_allocated_decoder_experiment_params(
    ::mozc::commands::DecoderExperimentParams* decoder_experiment_params) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(decoder_experiment_params_);
  }
  decoder_experiment_params_ = decoder_experiment_params;
  if (decoder_experiment_params) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Request.decoder_experiment_params)
}
inline ::mozc::commands::DecoderExperimentParams* Request::release_decoder_experiment_params() {
  auto temp = unsafe_arena_release_decoder_experiment_params();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::DecoderExperimentParams* Request::unsafe_arena_release_decoder_experiment_params() {
  // @@protoc_insertion_point(field_release:mozc.commands.Request.decoder_experiment_params)
  _has_bits_[0] &= ~0x00000002u;
  ::mozc::commands::DecoderExperimentParams* temp = decoder_experiment_params_;
  decoder_experiment_params_ = nullptr;
  return temp;
}
inline ::mozc::commands::DecoderExperimentParams* Request::_internal_mutable_decoder_experiment_params() {
  _has_bits_[0] |= 0x00000002u;
  if (decoder_experiment_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::DecoderExperimentParams>(GetArena());
    decoder_experiment_params_ = p;
  }
  return decoder_experiment_params_;
}
inline ::mozc::commands::DecoderExperimentParams* Request::mutable_decoder_experiment_params() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Request.decoder_experiment_params)
  return _internal_mutable_decoder_experiment_params();
}
inline void Request::set_allocated_decoder_experiment_params(::mozc::commands::DecoderExperimentParams* decoder_experiment_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete decoder_experiment_params_;
  }
  if (decoder_experiment_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(decoder_experiment_params);
    if (message_arena != submessage_arena) {
      decoder_experiment_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decoder_experiment_params, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  decoder_experiment_params_ = decoder_experiment_params;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Request.decoder_experiment_params)
}

// -------------------------------------------------------------------

// ApplicationInfo

// optional uint32 process_id = 1;
inline bool ApplicationInfo::_internal_has_process_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApplicationInfo::has_process_id() const {
  return _internal_has_process_id();
}
inline void ApplicationInfo::clear_process_id() {
  process_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ApplicationInfo::_internal_process_id() const {
  return process_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ApplicationInfo::process_id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.ApplicationInfo.process_id)
  return _internal_process_id();
}
inline void ApplicationInfo::_internal_set_process_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  process_id_ = value;
}
inline void ApplicationInfo::set_process_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_process_id(value);
  // @@protoc_insertion_point(field_set:mozc.commands.ApplicationInfo.process_id)
}

// optional uint32 thread_id = 2;
inline bool ApplicationInfo::_internal_has_thread_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ApplicationInfo::has_thread_id() const {
  return _internal_has_thread_id();
}
inline void ApplicationInfo::clear_thread_id() {
  thread_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ApplicationInfo::_internal_thread_id() const {
  return thread_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ApplicationInfo::thread_id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.ApplicationInfo.thread_id)
  return _internal_thread_id();
}
inline void ApplicationInfo::_internal_set_thread_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  thread_id_ = value;
}
inline void ApplicationInfo::set_thread_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_thread_id(value);
  // @@protoc_insertion_point(field_set:mozc.commands.ApplicationInfo.thread_id)
}

// optional int32 timezone_offset = 3;
inline bool ApplicationInfo::_internal_has_timezone_offset() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ApplicationInfo::has_timezone_offset() const {
  return _internal_has_timezone_offset();
}
inline void ApplicationInfo::clear_timezone_offset() {
  timezone_offset_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApplicationInfo::_internal_timezone_offset() const {
  return timezone_offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApplicationInfo::timezone_offset() const {
  // @@protoc_insertion_point(field_get:mozc.commands.ApplicationInfo.timezone_offset)
  return _internal_timezone_offset();
}
inline void ApplicationInfo::_internal_set_timezone_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  timezone_offset_ = value;
}
inline void ApplicationInfo::set_timezone_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_timezone_offset(value);
  // @@protoc_insertion_point(field_set:mozc.commands.ApplicationInfo.timezone_offset)
}

// -------------------------------------------------------------------

// Input_TouchPosition

// optional .mozc.commands.Input.TouchAction action = 1;
inline bool Input_TouchPosition::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Input_TouchPosition::has_action() const {
  return _internal_has_action();
}
inline void Input_TouchPosition::clear_action() {
  action_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::mozc::commands::Input_TouchAction Input_TouchPosition::_internal_action() const {
  return static_cast< ::mozc::commands::Input_TouchAction >(action_);
}
inline ::mozc::commands::Input_TouchAction Input_TouchPosition::action() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchPosition.action)
  return _internal_action();
}
inline void Input_TouchPosition::_internal_set_action(::mozc::commands::Input_TouchAction value) {
  assert(::mozc::commands::Input_TouchAction_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  action_ = value;
}
inline void Input_TouchPosition::set_action(::mozc::commands::Input_TouchAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Input.TouchPosition.action)
}

// optional float x = 2;
inline bool Input_TouchPosition::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Input_TouchPosition::has_x() const {
  return _internal_has_x();
}
inline void Input_TouchPosition::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Input_TouchPosition::_internal_x() const {
  return x_;
}
inline float Input_TouchPosition::x() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchPosition.x)
  return _internal_x();
}
inline void Input_TouchPosition::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Input_TouchPosition::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Input.TouchPosition.x)
}

// optional float y = 3;
inline bool Input_TouchPosition::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Input_TouchPosition::has_y() const {
  return _internal_has_y();
}
inline void Input_TouchPosition::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Input_TouchPosition::_internal_y() const {
  return y_;
}
inline float Input_TouchPosition::y() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchPosition.y)
  return _internal_y();
}
inline void Input_TouchPosition::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Input_TouchPosition::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Input.TouchPosition.y)
}

// optional int64 timestamp = 4;
inline bool Input_TouchPosition::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Input_TouchPosition::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Input_TouchPosition::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Input_TouchPosition::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Input_TouchPosition::timestamp() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchPosition.timestamp)
  return _internal_timestamp();
}
inline void Input_TouchPosition::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_ = value;
}
inline void Input_TouchPosition::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Input.TouchPosition.timestamp)
}

// -------------------------------------------------------------------

// Input_TouchEvent

// optional uint32 source_id = 1;
inline bool Input_TouchEvent::_internal_has_source_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Input_TouchEvent::has_source_id() const {
  return _internal_has_source_id();
}
inline void Input_TouchEvent::clear_source_id() {
  source_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Input_TouchEvent::_internal_source_id() const {
  return source_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Input_TouchEvent::source_id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchEvent.source_id)
  return _internal_source_id();
}
inline void Input_TouchEvent::_internal_set_source_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  source_id_ = value;
}
inline void Input_TouchEvent::set_source_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_source_id(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Input.TouchEvent.source_id)
}

// repeated .mozc.commands.Input.TouchPosition stroke = 2;
inline int Input_TouchEvent::_internal_stroke_size() const {
  return stroke_.size();
}
inline int Input_TouchEvent::stroke_size() const {
  return _internal_stroke_size();
}
inline void Input_TouchEvent::clear_stroke() {
  stroke_.Clear();
}
inline ::mozc::commands::Input_TouchPosition* Input_TouchEvent::mutable_stroke(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.TouchEvent.stroke)
  return stroke_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >*
Input_TouchEvent::mutable_stroke() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.Input.TouchEvent.stroke)
  return &stroke_;
}
inline const ::mozc::commands::Input_TouchPosition& Input_TouchEvent::_internal_stroke(int index) const {
  return stroke_.Get(index);
}
inline const ::mozc::commands::Input_TouchPosition& Input_TouchEvent::stroke(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchEvent.stroke)
  return _internal_stroke(index);
}
inline ::mozc::commands::Input_TouchPosition* Input_TouchEvent::_internal_add_stroke() {
  return stroke_.Add();
}
inline ::mozc::commands::Input_TouchPosition* Input_TouchEvent::add_stroke() {
  // @@protoc_insertion_point(field_add:mozc.commands.Input.TouchEvent.stroke)
  return _internal_add_stroke();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >&
Input_TouchEvent::stroke() const {
  // @@protoc_insertion_point(field_list:mozc.commands.Input.TouchEvent.stroke)
  return stroke_;
}

// -------------------------------------------------------------------

// Input

// required .mozc.commands.Input.CommandType type = 1;
inline bool Input::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Input::has_type() const {
  return _internal_has_type();
}
inline void Input::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::mozc::commands::Input_CommandType Input::_internal_type() const {
  return static_cast< ::mozc::commands::Input_CommandType >(type_);
}
inline ::mozc::commands::Input_CommandType Input::type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.type)
  return _internal_type();
}
inline void Input::_internal_set_type(::mozc::commands::Input_CommandType value) {
  assert(::mozc::commands::Input_CommandType_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  type_ = value;
}
inline void Input::set_type(::mozc::commands::Input_CommandType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Input.type)
}

// optional uint64 id = 2 [jstype = JS_STRING];
inline bool Input::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Input::has_id() const {
  return _internal_has_id();
}
inline void Input::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Input::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Input::id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.id)
  return _internal_id();
}
inline void Input::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000400u;
  id_ = value;
}
inline void Input::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Input.id)
}

// optional .mozc.commands.KeyEvent key = 3;
inline bool Input::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || key_ != nullptr);
  return value;
}
inline bool Input::has_key() const {
  return _internal_has_key();
}
inline void Input::clear_key() {
  if (key_ != nullptr) key_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mozc::commands::KeyEvent& Input::_internal_key() const {
  const ::mozc::commands::KeyEvent* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::KeyEvent*>(
      &::mozc::commands::_KeyEvent_default_instance_);
}
inline const ::mozc::commands::KeyEvent& Input::key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.key)
  return _internal_key();
}
inline void Input::unsafe_arena_set_allocated_key(
    ::mozc::commands::KeyEvent* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Input.key)
}
inline ::mozc::commands::KeyEvent* Input::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::KeyEvent* Input::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.key)
  _has_bits_[0] &= ~0x00000001u;
  ::mozc::commands::KeyEvent* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::mozc::commands::KeyEvent* Input::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::KeyEvent>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::mozc::commands::KeyEvent* Input::mutable_key() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.key)
  return _internal_mutable_key();
}
inline void Input::set_allocated_key(::mozc::commands::KeyEvent* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.key)
}

// optional .mozc.commands.SessionCommand command = 4;
inline bool Input::_internal_has_command() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || command_ != nullptr);
  return value;
}
inline bool Input::has_command() const {
  return _internal_has_command();
}
inline void Input::clear_command() {
  if (command_ != nullptr) command_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mozc::commands::SessionCommand& Input::_internal_command() const {
  const ::mozc::commands::SessionCommand* p = command_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::SessionCommand*>(
      &::mozc::commands::_SessionCommand_default_instance_);
}
inline const ::mozc::commands::SessionCommand& Input::command() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.command)
  return _internal_command();
}
inline void Input::unsafe_arena_set_allocated_command(
    ::mozc::commands::SessionCommand* command) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  command_ = command;
  if (command) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Input.command)
}
inline ::mozc::commands::SessionCommand* Input::release_command() {
  auto temp = unsafe_arena_release_command();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::SessionCommand* Input::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.command)
  _has_bits_[0] &= ~0x00000002u;
  ::mozc::commands::SessionCommand* temp = command_;
  command_ = nullptr;
  return temp;
}
inline ::mozc::commands::SessionCommand* Input::_internal_mutable_command() {
  _has_bits_[0] |= 0x00000002u;
  if (command_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::SessionCommand>(GetArena());
    command_ = p;
  }
  return command_;
}
inline ::mozc::commands::SessionCommand* Input::mutable_command() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.command)
  return _internal_mutable_command();
}
inline void Input::set_allocated_command(::mozc::commands::SessionCommand* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete command_;
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.command)
}

// optional .mozc.config.Config config = 5;
inline bool Input::_internal_has_config() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || config_ != nullptr);
  return value;
}
inline bool Input::has_config() const {
  return _internal_has_config();
}
inline const ::mozc::config::Config& Input::_internal_config() const {
  const ::mozc::config::Config* p = config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::config::Config*>(
      &::mozc::config::_Config_default_instance_);
}
inline const ::mozc::config::Config& Input::config() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.config)
  return _internal_config();
}
inline void Input::unsafe_arena_set_allocated_config(
    ::mozc::config::Config* config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Input.config)
}
inline ::mozc::config::Config* Input::release_config() {
  auto temp = unsafe_arena_release_config();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::config::Config* Input::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.config)
  _has_bits_[0] &= ~0x00000004u;
  ::mozc::config::Config* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::mozc::config::Config* Input::_internal_mutable_config() {
  _has_bits_[0] |= 0x00000004u;
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::config::Config>(GetArena());
    config_ = p;
  }
  return config_;
}
inline ::mozc::config::Config* Input::mutable_config() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.config)
  return _internal_mutable_config();
}
inline void Input::set_allocated_config(::mozc::config::Config* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config)->GetArena();
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.config)
}

// optional .mozc.commands.Context context = 6;
inline bool Input::_internal_has_context() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || context_ != nullptr);
  return value;
}
inline bool Input::has_context() const {
  return _internal_has_context();
}
inline void Input::clear_context() {
  if (context_ != nullptr) context_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mozc::commands::Context& Input::_internal_context() const {
  const ::mozc::commands::Context* p = context_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::Context*>(
      &::mozc::commands::_Context_default_instance_);
}
inline const ::mozc::commands::Context& Input::context() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.context)
  return _internal_context();
}
inline void Input::unsafe_arena_set_allocated_context(
    ::mozc::commands::Context* context) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context_);
  }
  context_ = context;
  if (context) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Input.context)
}
inline ::mozc::commands::Context* Input::release_context() {
  auto temp = unsafe_arena_release_context();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::Context* Input::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.context)
  _has_bits_[0] &= ~0x00000008u;
  ::mozc::commands::Context* temp = context_;
  context_ = nullptr;
  return temp;
}
inline ::mozc::commands::Context* Input::_internal_mutable_context() {
  _has_bits_[0] |= 0x00000008u;
  if (context_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::Context>(GetArena());
    context_ = p;
  }
  return context_;
}
inline ::mozc::commands::Context* Input::mutable_context() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.context)
  return _internal_mutable_context();
}
inline void Input::set_allocated_context(::mozc::commands::Context* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.context)
}

// optional .mozc.commands.Capability capability = 7;
inline bool Input::_internal_has_capability() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || capability_ != nullptr);
  return value;
}
inline bool Input::has_capability() const {
  return _internal_has_capability();
}
inline void Input::clear_capability() {
  if (capability_ != nullptr) capability_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mozc::commands::Capability& Input::_internal_capability() const {
  const ::mozc::commands::Capability* p = capability_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::Capability*>(
      &::mozc::commands::_Capability_default_instance_);
}
inline const ::mozc::commands::Capability& Input::capability() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.capability)
  return _internal_capability();
}
inline void Input::unsafe_arena_set_allocated_capability(
    ::mozc::commands::Capability* capability) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capability_);
  }
  capability_ = capability;
  if (capability) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Input.capability)
}
inline ::mozc::commands::Capability* Input::release_capability() {
  auto temp = unsafe_arena_release_capability();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::Capability* Input::unsafe_arena_release_capability() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.capability)
  _has_bits_[0] &= ~0x00000010u;
  ::mozc::commands::Capability* temp = capability_;
  capability_ = nullptr;
  return temp;
}
inline ::mozc::commands::Capability* Input::_internal_mutable_capability() {
  _has_bits_[0] |= 0x00000010u;
  if (capability_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::Capability>(GetArena());
    capability_ = p;
  }
  return capability_;
}
inline ::mozc::commands::Capability* Input::mutable_capability() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.capability)
  return _internal_mutable_capability();
}
inline void Input::set_allocated_capability(::mozc::commands::Capability* capability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete capability_;
  }
  if (capability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(capability);
    if (message_arena != submessage_arena) {
      capability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capability, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  capability_ = capability;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.capability)
}

// optional .mozc.commands.ApplicationInfo application_info = 8;
inline bool Input::_internal_has_application_info() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || application_info_ != nullptr);
  return value;
}
inline bool Input::has_application_info() const {
  return _internal_has_application_info();
}
inline void Input::clear_application_info() {
  if (application_info_ != nullptr) application_info_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::mozc::commands::ApplicationInfo& Input::_internal_application_info() const {
  const ::mozc::commands::ApplicationInfo* p = application_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::ApplicationInfo*>(
      &::mozc::commands::_ApplicationInfo_default_instance_);
}
inline const ::mozc::commands::ApplicationInfo& Input::application_info() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.application_info)
  return _internal_application_info();
}
inline void Input::unsafe_arena_set_allocated_application_info(
    ::mozc::commands::ApplicationInfo* application_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(application_info_);
  }
  application_info_ = application_info;
  if (application_info) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Input.application_info)
}
inline ::mozc::commands::ApplicationInfo* Input::release_application_info() {
  auto temp = unsafe_arena_release_application_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::ApplicationInfo* Input::unsafe_arena_release_application_info() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.application_info)
  _has_bits_[0] &= ~0x00000020u;
  ::mozc::commands::ApplicationInfo* temp = application_info_;
  application_info_ = nullptr;
  return temp;
}
inline ::mozc::commands::ApplicationInfo* Input::_internal_mutable_application_info() {
  _has_bits_[0] |= 0x00000020u;
  if (application_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::ApplicationInfo>(GetArena());
    application_info_ = p;
  }
  return application_info_;
}
inline ::mozc::commands::ApplicationInfo* Input::mutable_application_info() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.application_info)
  return _internal_mutable_application_info();
}
inline void Input::set_allocated_application_info(::mozc::commands::ApplicationInfo* application_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete application_info_;
  }
  if (application_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(application_info);
    if (message_arena != submessage_arena) {
      application_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, application_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  application_info_ = application_info;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.application_info)
}

// optional .mozc.commands.Request request = 9;
inline bool Input::_internal_has_request() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || request_ != nullptr);
  return value;
}
inline bool Input::has_request() const {
  return _internal_has_request();
}
inline void Input::clear_request() {
  if (request_ != nullptr) request_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::mozc::commands::Request& Input::_internal_request() const {
  const ::mozc::commands::Request* p = request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::Request*>(
      &::mozc::commands::_Request_default_instance_);
}
inline const ::mozc::commands::Request& Input::request() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.request)
  return _internal_request();
}
inline void Input::unsafe_arena_set_allocated_request(
    ::mozc::commands::Request* request) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Input.request)
}
inline ::mozc::commands::Request* Input::release_request() {
  auto temp = unsafe_arena_release_request();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::Request* Input::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.request)
  _has_bits_[0] &= ~0x00000040u;
  ::mozc::commands::Request* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::mozc::commands::Request* Input::_internal_mutable_request() {
  _has_bits_[0] |= 0x00000040u;
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::Request>(GetArena());
    request_ = p;
  }
  return request_;
}
inline ::mozc::commands::Request* Input::mutable_request() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.request)
  return _internal_mutable_request();
}
inline void Input::set_allocated_request(::mozc::commands::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.request)
}

// optional .mozc.commands.GenericStorageEntry storage_entry = 10;
inline bool Input::_internal_has_storage_entry() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || storage_entry_ != nullptr);
  return value;
}
inline bool Input::has_storage_entry() const {
  return _internal_has_storage_entry();
}
inline void Input::clear_storage_entry() {
  if (storage_entry_ != nullptr) storage_entry_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::mozc::commands::GenericStorageEntry& Input::_internal_storage_entry() const {
  const ::mozc::commands::GenericStorageEntry* p = storage_entry_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::GenericStorageEntry*>(
      &::mozc::commands::_GenericStorageEntry_default_instance_);
}
inline const ::mozc::commands::GenericStorageEntry& Input::storage_entry() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.storage_entry)
  return _internal_storage_entry();
}
inline void Input::unsafe_arena_set_allocated_storage_entry(
    ::mozc::commands::GenericStorageEntry* storage_entry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage_entry_);
  }
  storage_entry_ = storage_entry;
  if (storage_entry) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Input.storage_entry)
}
inline ::mozc::commands::GenericStorageEntry* Input::release_storage_entry() {
  auto temp = unsafe_arena_release_storage_entry();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::GenericStorageEntry* Input::unsafe_arena_release_storage_entry() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.storage_entry)
  _has_bits_[0] &= ~0x00000080u;
  ::mozc::commands::GenericStorageEntry* temp = storage_entry_;
  storage_entry_ = nullptr;
  return temp;
}
inline ::mozc::commands::GenericStorageEntry* Input::_internal_mutable_storage_entry() {
  _has_bits_[0] |= 0x00000080u;
  if (storage_entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::GenericStorageEntry>(GetArena());
    storage_entry_ = p;
  }
  return storage_entry_;
}
inline ::mozc::commands::GenericStorageEntry* Input::mutable_storage_entry() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.storage_entry)
  return _internal_mutable_storage_entry();
}
inline void Input::set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete storage_entry_;
  }
  if (storage_entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(storage_entry);
    if (message_arena != submessage_arena) {
      storage_entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage_entry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  storage_entry_ = storage_entry;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.storage_entry)
}

// repeated .mozc.commands.Input.TouchEvent touch_events = 12;
inline int Input::_internal_touch_events_size() const {
  return touch_events_.size();
}
inline int Input::touch_events_size() const {
  return _internal_touch_events_size();
}
inline void Input::clear_touch_events() {
  touch_events_.Clear();
}
inline ::mozc::commands::Input_TouchEvent* Input::mutable_touch_events(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.touch_events)
  return touch_events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >*
Input::mutable_touch_events() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.Input.touch_events)
  return &touch_events_;
}
inline const ::mozc::commands::Input_TouchEvent& Input::_internal_touch_events(int index) const {
  return touch_events_.Get(index);
}
inline const ::mozc::commands::Input_TouchEvent& Input::touch_events(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.touch_events)
  return _internal_touch_events(index);
}
inline ::mozc::commands::Input_TouchEvent* Input::_internal_add_touch_events() {
  return touch_events_.Add();
}
inline ::mozc::commands::Input_TouchEvent* Input::add_touch_events() {
  // @@protoc_insertion_point(field_add:mozc.commands.Input.touch_events)
  return _internal_add_touch_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >&
Input::touch_events() const {
  // @@protoc_insertion_point(field_list:mozc.commands.Input.touch_events)
  return touch_events_;
}

// optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;
inline bool Input::_internal_has_user_dictionary_command() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || user_dictionary_command_ != nullptr);
  return value;
}
inline bool Input::has_user_dictionary_command() const {
  return _internal_has_user_dictionary_command();
}
inline const ::mozc::user_dictionary::UserDictionaryCommand& Input::_internal_user_dictionary_command() const {
  const ::mozc::user_dictionary::UserDictionaryCommand* p = user_dictionary_command_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::user_dictionary::UserDictionaryCommand*>(
      &::mozc::user_dictionary::_UserDictionaryCommand_default_instance_);
}
inline const ::mozc::user_dictionary::UserDictionaryCommand& Input::user_dictionary_command() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.user_dictionary_command)
  return _internal_user_dictionary_command();
}
inline void Input::unsafe_arena_set_allocated_user_dictionary_command(
    ::mozc::user_dictionary::UserDictionaryCommand* user_dictionary_command) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_dictionary_command_);
  }
  user_dictionary_command_ = user_dictionary_command;
  if (user_dictionary_command) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Input.user_dictionary_command)
}
inline ::mozc::user_dictionary::UserDictionaryCommand* Input::release_user_dictionary_command() {
  auto temp = unsafe_arena_release_user_dictionary_command();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::user_dictionary::UserDictionaryCommand* Input::unsafe_arena_release_user_dictionary_command() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.user_dictionary_command)
  _has_bits_[0] &= ~0x00000100u;
  ::mozc::user_dictionary::UserDictionaryCommand* temp = user_dictionary_command_;
  user_dictionary_command_ = nullptr;
  return temp;
}
inline ::mozc::user_dictionary::UserDictionaryCommand* Input::_internal_mutable_user_dictionary_command() {
  _has_bits_[0] |= 0x00000100u;
  if (user_dictionary_command_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::user_dictionary::UserDictionaryCommand>(GetArena());
    user_dictionary_command_ = p;
  }
  return user_dictionary_command_;
}
inline ::mozc::user_dictionary::UserDictionaryCommand* Input::mutable_user_dictionary_command() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.user_dictionary_command)
  return _internal_mutable_user_dictionary_command();
}
inline void Input::set_allocated_user_dictionary_command(::mozc::user_dictionary::UserDictionaryCommand* user_dictionary_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_dictionary_command_);
  }
  if (user_dictionary_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_dictionary_command)->GetArena();
    if (message_arena != submessage_arena) {
      user_dictionary_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_dictionary_command, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  user_dictionary_command_ = user_dictionary_command;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.user_dictionary_command)
}

// optional bool request_suggestion = 14 [default = true];
inline bool Input::_internal_has_request_suggestion() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Input::has_request_suggestion() const {
  return _internal_has_request_suggestion();
}
inline void Input::clear_request_suggestion() {
  request_suggestion_ = true;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool Input::_internal_request_suggestion() const {
  return request_suggestion_;
}
inline bool Input::request_suggestion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.request_suggestion)
  return _internal_request_suggestion();
}
inline void Input::_internal_set_request_suggestion(bool value) {
  _has_bits_[0] |= 0x00001000u;
  request_suggestion_ = value;
}
inline void Input::set_request_suggestion(bool value) {
  _internal_set_request_suggestion(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Input.request_suggestion)
}

// optional .mozc.EngineReloadRequest engine_reload_request = 15;
inline bool Input::_internal_has_engine_reload_request() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || engine_reload_request_ != nullptr);
  return value;
}
inline bool Input::has_engine_reload_request() const {
  return _internal_has_engine_reload_request();
}
inline const ::mozc::EngineReloadRequest& Input::_internal_engine_reload_request() const {
  const ::mozc::EngineReloadRequest* p = engine_reload_request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::EngineReloadRequest*>(
      &::mozc::_EngineReloadRequest_default_instance_);
}
inline const ::mozc::EngineReloadRequest& Input::engine_reload_request() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.engine_reload_request)
  return _internal_engine_reload_request();
}
inline void Input::unsafe_arena_set_allocated_engine_reload_request(
    ::mozc::EngineReloadRequest* engine_reload_request) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(engine_reload_request_);
  }
  engine_reload_request_ = engine_reload_request;
  if (engine_reload_request) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Input.engine_reload_request)
}
inline ::mozc::EngineReloadRequest* Input::release_engine_reload_request() {
  auto temp = unsafe_arena_release_engine_reload_request();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::EngineReloadRequest* Input::unsafe_arena_release_engine_reload_request() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.engine_reload_request)
  _has_bits_[0] &= ~0x00000200u;
  ::mozc::EngineReloadRequest* temp = engine_reload_request_;
  engine_reload_request_ = nullptr;
  return temp;
}
inline ::mozc::EngineReloadRequest* Input::_internal_mutable_engine_reload_request() {
  _has_bits_[0] |= 0x00000200u;
  if (engine_reload_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::EngineReloadRequest>(GetArena());
    engine_reload_request_ = p;
  }
  return engine_reload_request_;
}
inline ::mozc::EngineReloadRequest* Input::mutable_engine_reload_request() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.engine_reload_request)
  return _internal_mutable_engine_reload_request();
}
inline void Input::set_allocated_engine_reload_request(::mozc::EngineReloadRequest* engine_reload_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(engine_reload_request_);
  }
  if (engine_reload_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(engine_reload_request)->GetArena();
    if (message_arena != submessage_arena) {
      engine_reload_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, engine_reload_request, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  engine_reload_request_ = engine_reload_request;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.engine_reload_request)
}

// -------------------------------------------------------------------

// Result

// required .mozc.commands.Result.ResultType type = 1;
inline bool Result::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Result::has_type() const {
  return _internal_has_type();
}
inline void Result::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::mozc::commands::Result_ResultType Result::_internal_type() const {
  return static_cast< ::mozc::commands::Result_ResultType >(type_);
}
inline ::mozc::commands::Result_ResultType Result::type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Result.type)
  return _internal_type();
}
inline void Result::_internal_set_type(::mozc::commands::Result_ResultType value) {
  assert(::mozc::commands::Result_ResultType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void Result::set_type(::mozc::commands::Result_ResultType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Result.type)
}

// required string value = 2;
inline bool Result::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Result::has_value() const {
  return _internal_has_value();
}
inline void Result::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Result::value() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Result.value)
  return _internal_value();
}
inline void Result::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Result.value)
}
inline std::string* Result::mutable_value() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Result.value)
  return _internal_mutable_value();
}
inline const std::string& Result::_internal_value() const {
  return value_.Get();
}
inline void Result::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Result::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Result.value)
}
inline void Result::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.commands.Result.value)
}
inline void Result::set_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Result.value)
}
inline std::string* Result::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Result::release_value() {
  // @@protoc_insertion_point(field_release:mozc.commands.Result.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Result.value)
}
inline std::string* Result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.commands.Result.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Result::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Result.value)
}

// optional string key = 3;
inline bool Result::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Result::has_key() const {
  return _internal_has_key();
}
inline void Result::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Result::key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Result.key)
  return _internal_key();
}
inline void Result::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Result.key)
}
inline std::string* Result::mutable_key() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Result.key)
  return _internal_mutable_key();
}
inline const std::string& Result::_internal_key() const {
  return key_.Get();
}
inline void Result::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Result::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Result.key)
}
inline void Result::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.commands.Result.key)
}
inline void Result::set_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Result.key)
}
inline std::string* Result::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000002u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Result::release_key() {
  // @@protoc_insertion_point(field_release:mozc.commands.Result.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Result::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Result.key)
}
inline std::string* Result::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.commands.Result.key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Result::unsafe_arena_set_allocated_key(
    std::string* key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Result.key)
}

// optional int32 cursor_offset = 4 [default = 0];
inline bool Result::_internal_has_cursor_offset() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Result::has_cursor_offset() const {
  return _internal_has_cursor_offset();
}
inline void Result::clear_cursor_offset() {
  cursor_offset_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Result::_internal_cursor_offset() const {
  return cursor_offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Result::cursor_offset() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Result.cursor_offset)
  return _internal_cursor_offset();
}
inline void Result::_internal_set_cursor_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  cursor_offset_ = value;
}
inline void Result::set_cursor_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cursor_offset(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Result.cursor_offset)
}

// -------------------------------------------------------------------

// Preedit_Segment

// required .mozc.commands.Preedit.Segment.Annotation annotation = 3;
inline bool Preedit_Segment::_internal_has_annotation() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Preedit_Segment::has_annotation() const {
  return _internal_has_annotation();
}
inline void Preedit_Segment::clear_annotation() {
  annotation_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::mozc::commands::Preedit_Segment_Annotation Preedit_Segment::_internal_annotation() const {
  return static_cast< ::mozc::commands::Preedit_Segment_Annotation >(annotation_);
}
inline ::mozc::commands::Preedit_Segment_Annotation Preedit_Segment::annotation() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.Segment.annotation)
  return _internal_annotation();
}
inline void Preedit_Segment::_internal_set_annotation(::mozc::commands::Preedit_Segment_Annotation value) {
  assert(::mozc::commands::Preedit_Segment_Annotation_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  annotation_ = value;
}
inline void Preedit_Segment::set_annotation(::mozc::commands::Preedit_Segment_Annotation value) {
  _internal_set_annotation(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.Segment.annotation)
}

// required string value = 4;
inline bool Preedit_Segment::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Preedit_Segment::has_value() const {
  return _internal_has_value();
}
inline void Preedit_Segment::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Preedit_Segment::value() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.Segment.value)
  return _internal_value();
}
inline void Preedit_Segment::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.Segment.value)
}
inline std::string* Preedit_Segment::mutable_value() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Preedit.Segment.value)
  return _internal_mutable_value();
}
inline const std::string& Preedit_Segment::_internal_value() const {
  return value_.Get();
}
inline void Preedit_Segment::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Preedit_Segment::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Preedit.Segment.value)
}
inline void Preedit_Segment::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.commands.Preedit.Segment.value)
}
inline void Preedit_Segment::set_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Preedit.Segment.value)
}
inline std::string* Preedit_Segment::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Preedit_Segment::release_value() {
  // @@protoc_insertion_point(field_release:mozc.commands.Preedit.Segment.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Preedit_Segment::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Preedit.Segment.value)
}
inline std::string* Preedit_Segment::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.commands.Preedit.Segment.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Preedit_Segment::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Preedit.Segment.value)
}

// required uint32 value_length = 5;
inline bool Preedit_Segment::_internal_has_value_length() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Preedit_Segment::has_value_length() const {
  return _internal_has_value_length();
}
inline void Preedit_Segment::clear_value_length() {
  value_length_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Preedit_Segment::_internal_value_length() const {
  return value_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Preedit_Segment::value_length() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.Segment.value_length)
  return _internal_value_length();
}
inline void Preedit_Segment::_internal_set_value_length(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  value_length_ = value;
}
inline void Preedit_Segment::set_value_length(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value_length(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.Segment.value_length)
}

// optional string key = 6;
inline bool Preedit_Segment::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Preedit_Segment::has_key() const {
  return _internal_has_key();
}
inline void Preedit_Segment::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Preedit_Segment::key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.Segment.key)
  return _internal_key();
}
inline void Preedit_Segment::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.Segment.key)
}
inline std::string* Preedit_Segment::mutable_key() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Preedit.Segment.key)
  return _internal_mutable_key();
}
inline const std::string& Preedit_Segment::_internal_key() const {
  return key_.Get();
}
inline void Preedit_Segment::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Preedit_Segment::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Preedit.Segment.key)
}
inline void Preedit_Segment::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.commands.Preedit.Segment.key)
}
inline void Preedit_Segment::set_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Preedit.Segment.key)
}
inline std::string* Preedit_Segment::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000002u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Preedit_Segment::release_key() {
  // @@protoc_insertion_point(field_release:mozc.commands.Preedit.Segment.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Preedit_Segment::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Preedit.Segment.key)
}
inline std::string* Preedit_Segment::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.commands.Preedit.Segment.key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Preedit_Segment::unsafe_arena_set_allocated_key(
    std::string* key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Preedit.Segment.key)
}

// -------------------------------------------------------------------

// Preedit

// required uint32 cursor = 1;
inline bool Preedit::_internal_has_cursor() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Preedit::has_cursor() const {
  return _internal_has_cursor();
}
inline void Preedit::clear_cursor() {
  cursor_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Preedit::_internal_cursor() const {
  return cursor_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Preedit::cursor() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.cursor)
  return _internal_cursor();
}
inline void Preedit::_internal_set_cursor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  cursor_ = value;
}
inline void Preedit::set_cursor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_cursor(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.cursor)
}

// repeated group Segment = 2 { ... };
inline int Preedit::_internal_segment_size() const {
  return segment_.size();
}
inline int Preedit::segment_size() const {
  return _internal_segment_size();
}
inline void Preedit::clear_segment() {
  segment_.Clear();
}
inline ::mozc::commands::Preedit_Segment* Preedit::mutable_segment(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Preedit.segment)
  return segment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Preedit_Segment >*
Preedit::mutable_segment() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.Preedit.segment)
  return &segment_;
}
inline const ::mozc::commands::Preedit_Segment& Preedit::_internal_segment(int index) const {
  return segment_.Get(index);
}
inline const ::mozc::commands::Preedit_Segment& Preedit::segment(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.segment)
  return _internal_segment(index);
}
inline ::mozc::commands::Preedit_Segment* Preedit::_internal_add_segment() {
  return segment_.Add();
}
inline ::mozc::commands::Preedit_Segment* Preedit::add_segment() {
  // @@protoc_insertion_point(field_add:mozc.commands.Preedit.segment)
  return _internal_add_segment();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Preedit_Segment >&
Preedit::segment() const {
  // @@protoc_insertion_point(field_list:mozc.commands.Preedit.segment)
  return segment_;
}

// optional uint32 highlighted_position = 3;
inline bool Preedit::_internal_has_highlighted_position() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Preedit::has_highlighted_position() const {
  return _internal_has_highlighted_position();
}
inline void Preedit::clear_highlighted_position() {
  highlighted_position_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Preedit::_internal_highlighted_position() const {
  return highlighted_position_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Preedit::highlighted_position() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.highlighted_position)
  return _internal_highlighted_position();
}
inline void Preedit::_internal_set_highlighted_position(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  highlighted_position_ = value;
}
inline void Preedit::set_highlighted_position(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_highlighted_position(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.highlighted_position)
}

// optional bool is_toggleable = 4 [default = false];
inline bool Preedit::_internal_has_is_toggleable() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Preedit::has_is_toggleable() const {
  return _internal_has_is_toggleable();
}
inline void Preedit::clear_is_toggleable() {
  is_toggleable_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Preedit::_internal_is_toggleable() const {
  return is_toggleable_;
}
inline bool Preedit::is_toggleable() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.is_toggleable)
  return _internal_is_toggleable();
}
inline void Preedit::_internal_set_is_toggleable(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_toggleable_ = value;
}
inline void Preedit::set_is_toggleable(bool value) {
  _internal_set_is_toggleable(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.is_toggleable)
}

// -------------------------------------------------------------------

// Status

// optional bool activated = 1;
inline bool Status::_internal_has_activated() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Status::has_activated() const {
  return _internal_has_activated();
}
inline void Status::clear_activated() {
  activated_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool Status::_internal_activated() const {
  return activated_;
}
inline bool Status::activated() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Status.activated)
  return _internal_activated();
}
inline void Status::_internal_set_activated(bool value) {
  _has_bits_[0] |= 0x00000001u;
  activated_ = value;
}
inline void Status::set_activated(bool value) {
  _internal_set_activated(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Status.activated)
}

// optional .mozc.commands.CompositionMode mode = 2;
inline bool Status::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Status::has_mode() const {
  return _internal_has_mode();
}
inline void Status::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::mozc::commands::CompositionMode Status::_internal_mode() const {
  return static_cast< ::mozc::commands::CompositionMode >(mode_);
}
inline ::mozc::commands::CompositionMode Status::mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Status.mode)
  return _internal_mode();
}
inline void Status::_internal_set_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  mode_ = value;
}
inline void Status::set_mode(::mozc::commands::CompositionMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Status.mode)
}

// optional .mozc.commands.CompositionMode comeback_mode = 3;
inline bool Status::_internal_has_comeback_mode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Status::has_comeback_mode() const {
  return _internal_has_comeback_mode();
}
inline void Status::clear_comeback_mode() {
  comeback_mode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::mozc::commands::CompositionMode Status::_internal_comeback_mode() const {
  return static_cast< ::mozc::commands::CompositionMode >(comeback_mode_);
}
inline ::mozc::commands::CompositionMode Status::comeback_mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Status.comeback_mode)
  return _internal_comeback_mode();
}
inline void Status::_internal_set_comeback_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  comeback_mode_ = value;
}
inline void Status::set_comeback_mode(::mozc::commands::CompositionMode value) {
  _internal_set_comeback_mode(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Status.comeback_mode)
}

// -------------------------------------------------------------------

// DeletionRange

// optional int32 offset = 1;
inline bool DeletionRange::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeletionRange::has_offset() const {
  return _internal_has_offset();
}
inline void DeletionRange::clear_offset() {
  offset_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeletionRange::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeletionRange::offset() const {
  // @@protoc_insertion_point(field_get:mozc.commands.DeletionRange.offset)
  return _internal_offset();
}
inline void DeletionRange::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  offset_ = value;
}
inline void DeletionRange::set_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:mozc.commands.DeletionRange.offset)
}

// optional int32 length = 2;
inline bool DeletionRange::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeletionRange::has_length() const {
  return _internal_has_length();
}
inline void DeletionRange::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeletionRange::_internal_length() const {
  return length_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeletionRange::length() const {
  // @@protoc_insertion_point(field_get:mozc.commands.DeletionRange.length)
  return _internal_length();
}
inline void DeletionRange::_internal_set_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  length_ = value;
}
inline void DeletionRange::set_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:mozc.commands.DeletionRange.length)
}

// -------------------------------------------------------------------

// Output_Callback

// optional .mozc.commands.SessionCommand session_command = 1;
inline bool Output_Callback::_internal_has_session_command() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || session_command_ != nullptr);
  return value;
}
inline bool Output_Callback::has_session_command() const {
  return _internal_has_session_command();
}
inline void Output_Callback::clear_session_command() {
  if (session_command_ != nullptr) session_command_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mozc::commands::SessionCommand& Output_Callback::_internal_session_command() const {
  const ::mozc::commands::SessionCommand* p = session_command_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::SessionCommand*>(
      &::mozc::commands::_SessionCommand_default_instance_);
}
inline const ::mozc::commands::SessionCommand& Output_Callback::session_command() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.Callback.session_command)
  return _internal_session_command();
}
inline void Output_Callback::unsafe_arena_set_allocated_session_command(
    ::mozc::commands::SessionCommand* session_command) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_command_);
  }
  session_command_ = session_command;
  if (session_command) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.Callback.session_command)
}
inline ::mozc::commands::SessionCommand* Output_Callback::release_session_command() {
  auto temp = unsafe_arena_release_session_command();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::SessionCommand* Output_Callback::unsafe_arena_release_session_command() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.Callback.session_command)
  _has_bits_[0] &= ~0x00000001u;
  ::mozc::commands::SessionCommand* temp = session_command_;
  session_command_ = nullptr;
  return temp;
}
inline ::mozc::commands::SessionCommand* Output_Callback::_internal_mutable_session_command() {
  _has_bits_[0] |= 0x00000001u;
  if (session_command_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::SessionCommand>(GetArena());
    session_command_ = p;
  }
  return session_command_;
}
inline ::mozc::commands::SessionCommand* Output_Callback::mutable_session_command() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.Callback.session_command)
  return _internal_mutable_session_command();
}
inline void Output_Callback::set_allocated_session_command(::mozc::commands::SessionCommand* session_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete session_command_;
  }
  if (session_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(session_command);
    if (message_arena != submessage_arena) {
      session_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_command, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_command_ = session_command;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.Callback.session_command)
}

// optional uint32 delay_millisec = 2;
inline bool Output_Callback::_internal_has_delay_millisec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Output_Callback::has_delay_millisec() const {
  return _internal_has_delay_millisec();
}
inline void Output_Callback::clear_delay_millisec() {
  delay_millisec_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Output_Callback::_internal_delay_millisec() const {
  return delay_millisec_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Output_Callback::delay_millisec() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.Callback.delay_millisec)
  return _internal_delay_millisec();
}
inline void Output_Callback::_internal_set_delay_millisec(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  delay_millisec_ = value;
}
inline void Output_Callback::set_delay_millisec(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_delay_millisec(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Output.Callback.delay_millisec)
}

// -------------------------------------------------------------------

// Output

// optional uint64 id = 1 [jstype = JS_STRING];
inline bool Output::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Output::has_id() const {
  return _internal_has_id();
}
inline void Output::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Output::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Output::id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.id)
  return _internal_id();
}
inline void Output::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00002000u;
  id_ = value;
}
inline void Output::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Output.id)
}

// optional .mozc.commands.CompositionMode mode = 2;
inline bool Output::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Output::has_mode() const {
  return _internal_has_mode();
}
inline void Output::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::mozc::commands::CompositionMode Output::_internal_mode() const {
  return static_cast< ::mozc::commands::CompositionMode >(mode_);
}
inline ::mozc::commands::CompositionMode Output::mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.mode)
  return _internal_mode();
}
inline void Output::_internal_set_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  _has_bits_[0] |= 0x00004000u;
  mode_ = value;
}
inline void Output::set_mode(::mozc::commands::CompositionMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Output.mode)
}

// optional bool consumed = 3;
inline bool Output::_internal_has_consumed() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Output::has_consumed() const {
  return _internal_has_consumed();
}
inline void Output::clear_consumed() {
  consumed_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool Output::_internal_consumed() const {
  return consumed_;
}
inline bool Output::consumed() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.consumed)
  return _internal_consumed();
}
inline void Output::_internal_set_consumed(bool value) {
  _has_bits_[0] |= 0x00008000u;
  consumed_ = value;
}
inline void Output::set_consumed(bool value) {
  _internal_set_consumed(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Output.consumed)
}

// optional .mozc.commands.Result result = 4;
inline bool Output::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || result_ != nullptr);
  return value;
}
inline bool Output::has_result() const {
  return _internal_has_result();
}
inline void Output::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mozc::commands::Result& Output::_internal_result() const {
  const ::mozc::commands::Result* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::Result*>(
      &::mozc::commands::_Result_default_instance_);
}
inline const ::mozc::commands::Result& Output::result() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.result)
  return _internal_result();
}
inline void Output::unsafe_arena_set_allocated_result(
    ::mozc::commands::Result* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.result)
}
inline ::mozc::commands::Result* Output::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::Result* Output::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.result)
  _has_bits_[0] &= ~0x00000002u;
  ::mozc::commands::Result* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::mozc::commands::Result* Output::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000002u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::Result>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::mozc::commands::Result* Output::mutable_result() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.result)
  return _internal_mutable_result();
}
inline void Output::set_allocated_result(::mozc::commands::Result* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.result)
}

// optional .mozc.commands.Preedit preedit = 5;
inline bool Output::_internal_has_preedit() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || preedit_ != nullptr);
  return value;
}
inline bool Output::has_preedit() const {
  return _internal_has_preedit();
}
inline void Output::clear_preedit() {
  if (preedit_ != nullptr) preedit_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mozc::commands::Preedit& Output::_internal_preedit() const {
  const ::mozc::commands::Preedit* p = preedit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::Preedit*>(
      &::mozc::commands::_Preedit_default_instance_);
}
inline const ::mozc::commands::Preedit& Output::preedit() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.preedit)
  return _internal_preedit();
}
inline void Output::unsafe_arena_set_allocated_preedit(
    ::mozc::commands::Preedit* preedit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(preedit_);
  }
  preedit_ = preedit;
  if (preedit) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.preedit)
}
inline ::mozc::commands::Preedit* Output::release_preedit() {
  auto temp = unsafe_arena_release_preedit();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::Preedit* Output::unsafe_arena_release_preedit() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.preedit)
  _has_bits_[0] &= ~0x00000004u;
  ::mozc::commands::Preedit* temp = preedit_;
  preedit_ = nullptr;
  return temp;
}
inline ::mozc::commands::Preedit* Output::_internal_mutable_preedit() {
  _has_bits_[0] |= 0x00000004u;
  if (preedit_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::Preedit>(GetArena());
    preedit_ = p;
  }
  return preedit_;
}
inline ::mozc::commands::Preedit* Output::mutable_preedit() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.preedit)
  return _internal_mutable_preedit();
}
inline void Output::set_allocated_preedit(::mozc::commands::Preedit* preedit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete preedit_;
  }
  if (preedit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(preedit);
    if (message_arena != submessage_arena) {
      preedit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, preedit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  preedit_ = preedit;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.preedit)
}

// optional .mozc.commands.Candidates candidates = 6;
inline bool Output::_internal_has_candidates() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || candidates_ != nullptr);
  return value;
}
inline bool Output::has_candidates() const {
  return _internal_has_candidates();
}
inline const ::mozc::commands::Candidates& Output::_internal_candidates() const {
  const ::mozc::commands::Candidates* p = candidates_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::Candidates*>(
      &::mozc::commands::_Candidates_default_instance_);
}
inline const ::mozc::commands::Candidates& Output::candidates() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.candidates)
  return _internal_candidates();
}
inline void Output::unsafe_arena_set_allocated_candidates(
    ::mozc::commands::Candidates* candidates) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(candidates_);
  }
  candidates_ = candidates;
  if (candidates) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.candidates)
}
inline ::mozc::commands::Candidates* Output::release_candidates() {
  auto temp = unsafe_arena_release_candidates();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::Candidates* Output::unsafe_arena_release_candidates() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.candidates)
  _has_bits_[0] &= ~0x00000008u;
  ::mozc::commands::Candidates* temp = candidates_;
  candidates_ = nullptr;
  return temp;
}
inline ::mozc::commands::Candidates* Output::_internal_mutable_candidates() {
  _has_bits_[0] |= 0x00000008u;
  if (candidates_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::Candidates>(GetArena());
    candidates_ = p;
  }
  return candidates_;
}
inline ::mozc::commands::Candidates* Output::mutable_candidates() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.candidates)
  return _internal_mutable_candidates();
}
inline void Output::set_allocated_candidates(::mozc::commands::Candidates* candidates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(candidates_);
  }
  if (candidates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(candidates)->GetArena();
    if (message_arena != submessage_arena) {
      candidates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, candidates, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  candidates_ = candidates;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.candidates)
}

// optional .mozc.commands.KeyEvent key = 7;
inline bool Output::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || key_ != nullptr);
  return value;
}
inline bool Output::has_key() const {
  return _internal_has_key();
}
inline void Output::clear_key() {
  if (key_ != nullptr) key_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mozc::commands::KeyEvent& Output::_internal_key() const {
  const ::mozc::commands::KeyEvent* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::KeyEvent*>(
      &::mozc::commands::_KeyEvent_default_instance_);
}
inline const ::mozc::commands::KeyEvent& Output::key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.key)
  return _internal_key();
}
inline void Output::unsafe_arena_set_allocated_key(
    ::mozc::commands::KeyEvent* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.key)
}
inline ::mozc::commands::KeyEvent* Output::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::KeyEvent* Output::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.key)
  _has_bits_[0] &= ~0x00000010u;
  ::mozc::commands::KeyEvent* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::mozc::commands::KeyEvent* Output::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000010u;
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::KeyEvent>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::mozc::commands::KeyEvent* Output::mutable_key() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.key)
  return _internal_mutable_key();
}
inline void Output::set_allocated_key(::mozc::commands::KeyEvent* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.key)
}

// optional string url = 8;
inline bool Output::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Output::has_url() const {
  return _internal_has_url();
}
inline void Output::clear_url() {
  url_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Output::url() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.url)
  return _internal_url();
}
inline void Output::set_url(const std::string& value) {
  _internal_set_url(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Output.url)
}
inline std::string* Output::mutable_url() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.url)
  return _internal_mutable_url();
}
inline const std::string& Output::_internal_url() const {
  return url_.Get();
}
inline void Output::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Output::set_url(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Output.url)
}
inline void Output::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mozc.commands.Output.url)
}
inline void Output::set_url(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Output.url)
}
inline std::string* Output::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Output::release_url() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Output::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.url)
}
inline std::string* Output::unsafe_arena_release_url() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mozc.commands.Output.url)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return url_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Output::unsafe_arena_set_allocated_url(
    std::string* url) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      url, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.url)
}

// optional .mozc.config.Config config = 9;
inline bool Output::_internal_has_config() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || config_ != nullptr);
  return value;
}
inline bool Output::has_config() const {
  return _internal_has_config();
}
inline const ::mozc::config::Config& Output::_internal_config() const {
  const ::mozc::config::Config* p = config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::config::Config*>(
      &::mozc::config::_Config_default_instance_);
}
inline const ::mozc::config::Config& Output::config() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.config)
  return _internal_config();
}
inline void Output::unsafe_arena_set_allocated_config(
    ::mozc::config::Config* config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.config)
}
inline ::mozc::config::Config* Output::release_config() {
  auto temp = unsafe_arena_release_config();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::config::Config* Output::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.config)
  _has_bits_[0] &= ~0x00000020u;
  ::mozc::config::Config* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::mozc::config::Config* Output::_internal_mutable_config() {
  _has_bits_[0] |= 0x00000020u;
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::config::Config>(GetArena());
    config_ = p;
  }
  return config_;
}
inline ::mozc::config::Config* Output::mutable_config() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.config)
  return _internal_mutable_config();
}
inline void Output::set_allocated_config(::mozc::config::Config* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config)->GetArena();
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.config)
}

// optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];
inline bool Output::_internal_has_preedit_method() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Output::has_preedit_method() const {
  return _internal_has_preedit_method();
}
inline void Output::clear_preedit_method() {
  preedit_method_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::mozc::commands::Output_PreeditMethod Output::_internal_preedit_method() const {
  return static_cast< ::mozc::commands::Output_PreeditMethod >(preedit_method_);
}
inline ::mozc::commands::Output_PreeditMethod Output::preedit_method() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.preedit_method)
  return _internal_preedit_method();
}
inline void Output::_internal_set_preedit_method(::mozc::commands::Output_PreeditMethod value) {
  assert(::mozc::commands::Output_PreeditMethod_IsValid(value));
  _has_bits_[0] |= 0x00010000u;
  preedit_method_ = value;
}
inline void Output::set_preedit_method(::mozc::commands::Output_PreeditMethod value) {
  _internal_set_preedit_method(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Output.preedit_method)
}

// optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];
inline bool Output::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Output::has_error_code() const {
  return _internal_has_error_code();
}
inline void Output::clear_error_code() {
  error_code_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::mozc::commands::Output_ErrorCode Output::_internal_error_code() const {
  return static_cast< ::mozc::commands::Output_ErrorCode >(error_code_);
}
inline ::mozc::commands::Output_ErrorCode Output::error_code() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.error_code)
  return _internal_error_code();
}
inline void Output::_internal_set_error_code(::mozc::commands::Output_ErrorCode value) {
  assert(::mozc::commands::Output_ErrorCode_IsValid(value));
  _has_bits_[0] |= 0x00020000u;
  error_code_ = value;
}
inline void Output::set_error_code(::mozc::commands::Output_ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Output.error_code)
}

// optional .mozc.commands.Status status = 13;
inline bool Output::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool Output::has_status() const {
  return _internal_has_status();
}
inline void Output::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::mozc::commands::Status& Output::_internal_status() const {
  const ::mozc::commands::Status* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::Status*>(
      &::mozc::commands::_Status_default_instance_);
}
inline const ::mozc::commands::Status& Output::status() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.status)
  return _internal_status();
}
inline void Output::unsafe_arena_set_allocated_status(
    ::mozc::commands::Status* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.status)
}
inline ::mozc::commands::Status* Output::release_status() {
  auto temp = unsafe_arena_release_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::Status* Output::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.status)
  _has_bits_[0] &= ~0x00000040u;
  ::mozc::commands::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::mozc::commands::Status* Output::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000040u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::Status>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::mozc::commands::Status* Output::mutable_status() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.status)
  return _internal_mutable_status();
}
inline void Output::set_allocated_status(::mozc::commands::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.status)
}

// optional .mozc.commands.CandidateList all_candidate_words = 14;
inline bool Output::_internal_has_all_candidate_words() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || all_candidate_words_ != nullptr);
  return value;
}
inline bool Output::has_all_candidate_words() const {
  return _internal_has_all_candidate_words();
}
inline const ::mozc::commands::CandidateList& Output::_internal_all_candidate_words() const {
  const ::mozc::commands::CandidateList* p = all_candidate_words_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::CandidateList*>(
      &::mozc::commands::_CandidateList_default_instance_);
}
inline const ::mozc::commands::CandidateList& Output::all_candidate_words() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.all_candidate_words)
  return _internal_all_candidate_words();
}
inline void Output::unsafe_arena_set_allocated_all_candidate_words(
    ::mozc::commands::CandidateList* all_candidate_words) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(all_candidate_words_);
  }
  all_candidate_words_ = all_candidate_words;
  if (all_candidate_words) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.all_candidate_words)
}
inline ::mozc::commands::CandidateList* Output::release_all_candidate_words() {
  auto temp = unsafe_arena_release_all_candidate_words();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::CandidateList* Output::unsafe_arena_release_all_candidate_words() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.all_candidate_words)
  _has_bits_[0] &= ~0x00000080u;
  ::mozc::commands::CandidateList* temp = all_candidate_words_;
  all_candidate_words_ = nullptr;
  return temp;
}
inline ::mozc::commands::CandidateList* Output::_internal_mutable_all_candidate_words() {
  _has_bits_[0] |= 0x00000080u;
  if (all_candidate_words_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::CandidateList>(GetArena());
    all_candidate_words_ = p;
  }
  return all_candidate_words_;
}
inline ::mozc::commands::CandidateList* Output::mutable_all_candidate_words() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.all_candidate_words)
  return _internal_mutable_all_candidate_words();
}
inline void Output::set_allocated_all_candidate_words(::mozc::commands::CandidateList* all_candidate_words) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(all_candidate_words_);
  }
  if (all_candidate_words) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(all_candidate_words)->GetArena();
    if (message_arena != submessage_arena) {
      all_candidate_words = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, all_candidate_words, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  all_candidate_words_ = all_candidate_words;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.all_candidate_words)
}

// optional .mozc.commands.DeletionRange deletion_range = 16;
inline bool Output::_internal_has_deletion_range() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || deletion_range_ != nullptr);
  return value;
}
inline bool Output::has_deletion_range() const {
  return _internal_has_deletion_range();
}
inline void Output::clear_deletion_range() {
  if (deletion_range_ != nullptr) deletion_range_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::mozc::commands::DeletionRange& Output::_internal_deletion_range() const {
  const ::mozc::commands::DeletionRange* p = deletion_range_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::DeletionRange*>(
      &::mozc::commands::_DeletionRange_default_instance_);
}
inline const ::mozc::commands::DeletionRange& Output::deletion_range() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.deletion_range)
  return _internal_deletion_range();
}
inline void Output::unsafe_arena_set_allocated_deletion_range(
    ::mozc::commands::DeletionRange* deletion_range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deletion_range_);
  }
  deletion_range_ = deletion_range;
  if (deletion_range) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.deletion_range)
}
inline ::mozc::commands::DeletionRange* Output::release_deletion_range() {
  auto temp = unsafe_arena_release_deletion_range();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::DeletionRange* Output::unsafe_arena_release_deletion_range() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.deletion_range)
  _has_bits_[0] &= ~0x00000100u;
  ::mozc::commands::DeletionRange* temp = deletion_range_;
  deletion_range_ = nullptr;
  return temp;
}
inline ::mozc::commands::DeletionRange* Output::_internal_mutable_deletion_range() {
  _has_bits_[0] |= 0x00000100u;
  if (deletion_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::DeletionRange>(GetArena());
    deletion_range_ = p;
  }
  return deletion_range_;
}
inline ::mozc::commands::DeletionRange* Output::mutable_deletion_range() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.deletion_range)
  return _internal_mutable_deletion_range();
}
inline void Output::set_allocated_deletion_range(::mozc::commands::DeletionRange* deletion_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete deletion_range_;
  }
  if (deletion_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(deletion_range);
    if (message_arena != submessage_arena) {
      deletion_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deletion_range, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  deletion_range_ = deletion_range;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.deletion_range)
}

// optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];
inline bool Output::_internal_has_launch_tool_mode() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Output::has_launch_tool_mode() const {
  return _internal_has_launch_tool_mode();
}
inline void Output::clear_launch_tool_mode() {
  launch_tool_mode_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::mozc::commands::Output_ToolMode Output::_internal_launch_tool_mode() const {
  return static_cast< ::mozc::commands::Output_ToolMode >(launch_tool_mode_);
}
inline ::mozc::commands::Output_ToolMode Output::launch_tool_mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.launch_tool_mode)
  return _internal_launch_tool_mode();
}
inline void Output::_internal_set_launch_tool_mode(::mozc::commands::Output_ToolMode value) {
  assert(::mozc::commands::Output_ToolMode_IsValid(value));
  _has_bits_[0] |= 0x00040000u;
  launch_tool_mode_ = value;
}
inline void Output::set_launch_tool_mode(::mozc::commands::Output_ToolMode value) {
  _internal_set_launch_tool_mode(value);
  // @@protoc_insertion_point(field_set:mozc.commands.Output.launch_tool_mode)
}

// optional .mozc.commands.Output.Callback callback = 18;
inline bool Output::_internal_has_callback() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || callback_ != nullptr);
  return value;
}
inline bool Output::has_callback() const {
  return _internal_has_callback();
}
inline void Output::clear_callback() {
  if (callback_ != nullptr) callback_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::mozc::commands::Output_Callback& Output::_internal_callback() const {
  const ::mozc::commands::Output_Callback* p = callback_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::Output_Callback*>(
      &::mozc::commands::_Output_Callback_default_instance_);
}
inline const ::mozc::commands::Output_Callback& Output::callback() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.callback)
  return _internal_callback();
}
inline void Output::unsafe_arena_set_allocated_callback(
    ::mozc::commands::Output_Callback* callback) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(callback_);
  }
  callback_ = callback;
  if (callback) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.callback)
}
inline ::mozc::commands::Output_Callback* Output::release_callback() {
  auto temp = unsafe_arena_release_callback();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::Output_Callback* Output::unsafe_arena_release_callback() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.callback)
  _has_bits_[0] &= ~0x00000200u;
  ::mozc::commands::Output_Callback* temp = callback_;
  callback_ = nullptr;
  return temp;
}
inline ::mozc::commands::Output_Callback* Output::_internal_mutable_callback() {
  _has_bits_[0] |= 0x00000200u;
  if (callback_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::Output_Callback>(GetArena());
    callback_ = p;
  }
  return callback_;
}
inline ::mozc::commands::Output_Callback* Output::mutable_callback() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.callback)
  return _internal_mutable_callback();
}
inline void Output::set_allocated_callback(::mozc::commands::Output_Callback* callback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete callback_;
  }
  if (callback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(callback);
    if (message_arena != submessage_arena) {
      callback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, callback, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  callback_ = callback;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.callback)
}

// optional .mozc.commands.GenericStorageEntry storage_entry = 19;
inline bool Output::_internal_has_storage_entry() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || storage_entry_ != nullptr);
  return value;
}
inline bool Output::has_storage_entry() const {
  return _internal_has_storage_entry();
}
inline void Output::clear_storage_entry() {
  if (storage_entry_ != nullptr) storage_entry_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::mozc::commands::GenericStorageEntry& Output::_internal_storage_entry() const {
  const ::mozc::commands::GenericStorageEntry* p = storage_entry_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::GenericStorageEntry*>(
      &::mozc::commands::_GenericStorageEntry_default_instance_);
}
inline const ::mozc::commands::GenericStorageEntry& Output::storage_entry() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.storage_entry)
  return _internal_storage_entry();
}
inline void Output::unsafe_arena_set_allocated_storage_entry(
    ::mozc::commands::GenericStorageEntry* storage_entry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage_entry_);
  }
  storage_entry_ = storage_entry;
  if (storage_entry) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.storage_entry)
}
inline ::mozc::commands::GenericStorageEntry* Output::release_storage_entry() {
  auto temp = unsafe_arena_release_storage_entry();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::GenericStorageEntry* Output::unsafe_arena_release_storage_entry() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.storage_entry)
  _has_bits_[0] &= ~0x00000400u;
  ::mozc::commands::GenericStorageEntry* temp = storage_entry_;
  storage_entry_ = nullptr;
  return temp;
}
inline ::mozc::commands::GenericStorageEntry* Output::_internal_mutable_storage_entry() {
  _has_bits_[0] |= 0x00000400u;
  if (storage_entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::GenericStorageEntry>(GetArena());
    storage_entry_ = p;
  }
  return storage_entry_;
}
inline ::mozc::commands::GenericStorageEntry* Output::mutable_storage_entry() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.storage_entry)
  return _internal_mutable_storage_entry();
}
inline void Output::set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete storage_entry_;
  }
  if (storage_entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(storage_entry);
    if (message_arena != submessage_arena) {
      storage_entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage_entry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  storage_entry_ = storage_entry;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.storage_entry)
}

// optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;
inline bool Output::_internal_has_user_dictionary_command_status() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || user_dictionary_command_status_ != nullptr);
  return value;
}
inline bool Output::has_user_dictionary_command_status() const {
  return _internal_has_user_dictionary_command_status();
}
inline const ::mozc::user_dictionary::UserDictionaryCommandStatus& Output::_internal_user_dictionary_command_status() const {
  const ::mozc::user_dictionary::UserDictionaryCommandStatus* p = user_dictionary_command_status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::user_dictionary::UserDictionaryCommandStatus*>(
      &::mozc::user_dictionary::_UserDictionaryCommandStatus_default_instance_);
}
inline const ::mozc::user_dictionary::UserDictionaryCommandStatus& Output::user_dictionary_command_status() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.user_dictionary_command_status)
  return _internal_user_dictionary_command_status();
}
inline void Output::unsafe_arena_set_allocated_user_dictionary_command_status(
    ::mozc::user_dictionary::UserDictionaryCommandStatus* user_dictionary_command_status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_dictionary_command_status_);
  }
  user_dictionary_command_status_ = user_dictionary_command_status;
  if (user_dictionary_command_status) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.user_dictionary_command_status)
}
inline ::mozc::user_dictionary::UserDictionaryCommandStatus* Output::release_user_dictionary_command_status() {
  auto temp = unsafe_arena_release_user_dictionary_command_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::user_dictionary::UserDictionaryCommandStatus* Output::unsafe_arena_release_user_dictionary_command_status() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.user_dictionary_command_status)
  _has_bits_[0] &= ~0x00000800u;
  ::mozc::user_dictionary::UserDictionaryCommandStatus* temp = user_dictionary_command_status_;
  user_dictionary_command_status_ = nullptr;
  return temp;
}
inline ::mozc::user_dictionary::UserDictionaryCommandStatus* Output::_internal_mutable_user_dictionary_command_status() {
  _has_bits_[0] |= 0x00000800u;
  if (user_dictionary_command_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::user_dictionary::UserDictionaryCommandStatus>(GetArena());
    user_dictionary_command_status_ = p;
  }
  return user_dictionary_command_status_;
}
inline ::mozc::user_dictionary::UserDictionaryCommandStatus* Output::mutable_user_dictionary_command_status() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.user_dictionary_command_status)
  return _internal_mutable_user_dictionary_command_status();
}
inline void Output::set_allocated_user_dictionary_command_status(::mozc::user_dictionary::UserDictionaryCommandStatus* user_dictionary_command_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_dictionary_command_status_);
  }
  if (user_dictionary_command_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_dictionary_command_status)->GetArena();
    if (message_arena != submessage_arena) {
      user_dictionary_command_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_dictionary_command_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  user_dictionary_command_status_ = user_dictionary_command_status;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.user_dictionary_command_status)
}

// optional .mozc.EngineReloadResponse engine_reload_response = 22;
inline bool Output::_internal_has_engine_reload_response() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || engine_reload_response_ != nullptr);
  return value;
}
inline bool Output::has_engine_reload_response() const {
  return _internal_has_engine_reload_response();
}
inline const ::mozc::EngineReloadResponse& Output::_internal_engine_reload_response() const {
  const ::mozc::EngineReloadResponse* p = engine_reload_response_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::EngineReloadResponse*>(
      &::mozc::_EngineReloadResponse_default_instance_);
}
inline const ::mozc::EngineReloadResponse& Output::engine_reload_response() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.engine_reload_response)
  return _internal_engine_reload_response();
}
inline void Output::unsafe_arena_set_allocated_engine_reload_response(
    ::mozc::EngineReloadResponse* engine_reload_response) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(engine_reload_response_);
  }
  engine_reload_response_ = engine_reload_response;
  if (engine_reload_response) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Output.engine_reload_response)
}
inline ::mozc::EngineReloadResponse* Output::release_engine_reload_response() {
  auto temp = unsafe_arena_release_engine_reload_response();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::EngineReloadResponse* Output::unsafe_arena_release_engine_reload_response() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.engine_reload_response)
  _has_bits_[0] &= ~0x00001000u;
  ::mozc::EngineReloadResponse* temp = engine_reload_response_;
  engine_reload_response_ = nullptr;
  return temp;
}
inline ::mozc::EngineReloadResponse* Output::_internal_mutable_engine_reload_response() {
  _has_bits_[0] |= 0x00001000u;
  if (engine_reload_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::EngineReloadResponse>(GetArena());
    engine_reload_response_ = p;
  }
  return engine_reload_response_;
}
inline ::mozc::EngineReloadResponse* Output::mutable_engine_reload_response() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.engine_reload_response)
  return _internal_mutable_engine_reload_response();
}
inline void Output::set_allocated_engine_reload_response(::mozc::EngineReloadResponse* engine_reload_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(engine_reload_response_);
  }
  if (engine_reload_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(engine_reload_response)->GetArena();
    if (message_arena != submessage_arena) {
      engine_reload_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, engine_reload_response, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  engine_reload_response_ = engine_reload_response;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.engine_reload_response)
}

// -------------------------------------------------------------------

// Command

// required .mozc.commands.Input input = 1;
inline bool Command::_internal_has_input() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || input_ != nullptr);
  return value;
}
inline bool Command::has_input() const {
  return _internal_has_input();
}
inline void Command::clear_input() {
  if (input_ != nullptr) input_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mozc::commands::Input& Command::_internal_input() const {
  const ::mozc::commands::Input* p = input_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::Input*>(
      &::mozc::commands::_Input_default_instance_);
}
inline const ::mozc::commands::Input& Command::input() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Command.input)
  return _internal_input();
}
inline void Command::unsafe_arena_set_allocated_input(
    ::mozc::commands::Input* input) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(input_);
  }
  input_ = input;
  if (input) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Command.input)
}
inline ::mozc::commands::Input* Command::release_input() {
  auto temp = unsafe_arena_release_input();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::Input* Command::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:mozc.commands.Command.input)
  _has_bits_[0] &= ~0x00000001u;
  ::mozc::commands::Input* temp = input_;
  input_ = nullptr;
  return temp;
}
inline ::mozc::commands::Input* Command::_internal_mutable_input() {
  _has_bits_[0] |= 0x00000001u;
  if (input_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::Input>(GetArena());
    input_ = p;
  }
  return input_;
}
inline ::mozc::commands::Input* Command::mutable_input() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Command.input)
  return _internal_mutable_input();
}
inline void Command::set_allocated_input(::mozc::commands::Input* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Command.input)
}

// required .mozc.commands.Output output = 2;
inline bool Command::_internal_has_output() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || output_ != nullptr);
  return value;
}
inline bool Command::has_output() const {
  return _internal_has_output();
}
inline void Command::clear_output() {
  if (output_ != nullptr) output_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mozc::commands::Output& Command::_internal_output() const {
  const ::mozc::commands::Output* p = output_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mozc::commands::Output*>(
      &::mozc::commands::_Output_default_instance_);
}
inline const ::mozc::commands::Output& Command::output() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Command.output)
  return _internal_output();
}
inline void Command::unsafe_arena_set_allocated_output(
    ::mozc::commands::Output* output) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_);
  }
  output_ = output;
  if (output) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mozc.commands.Command.output)
}
inline ::mozc::commands::Output* Command::release_output() {
  auto temp = unsafe_arena_release_output();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mozc::commands::Output* Command::unsafe_arena_release_output() {
  // @@protoc_insertion_point(field_release:mozc.commands.Command.output)
  _has_bits_[0] &= ~0x00000002u;
  ::mozc::commands::Output* temp = output_;
  output_ = nullptr;
  return temp;
}
inline ::mozc::commands::Output* Command::_internal_mutable_output() {
  _has_bits_[0] |= 0x00000002u;
  if (output_ == nullptr) {
    auto* p = CreateMaybeMessage<::mozc::commands::Output>(GetArena());
    output_ = p;
  }
  return output_;
}
inline ::mozc::commands::Output* Command::mutable_output() {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Command.output)
  return _internal_mutable_output();
}
inline void Command::set_allocated_output(::mozc::commands::Output* output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete output_;
  }
  if (output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(output);
    if (message_arena != submessage_arena) {
      output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  output_ = output;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Command.output)
}

// -------------------------------------------------------------------

// CommandList

// repeated .mozc.commands.Command commands = 1;
inline int CommandList::_internal_commands_size() const {
  return commands_.size();
}
inline int CommandList::commands_size() const {
  return _internal_commands_size();
}
inline void CommandList::clear_commands() {
  commands_.Clear();
}
inline ::mozc::commands::Command* CommandList::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.CommandList.commands)
  return commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Command >*
CommandList::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.CommandList.commands)
  return &commands_;
}
inline const ::mozc::commands::Command& CommandList::_internal_commands(int index) const {
  return commands_.Get(index);
}
inline const ::mozc::commands::Command& CommandList::commands(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.CommandList.commands)
  return _internal_commands(index);
}
inline ::mozc::commands::Command* CommandList::_internal_add_commands() {
  return commands_.Add();
}
inline ::mozc::commands::Command* CommandList::add_commands() {
  // @@protoc_insertion_point(field_add:mozc.commands.CommandList.commands)
  return _internal_add_commands();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mozc::commands::Command >&
CommandList::commands() const {
  // @@protoc_insertion_point(field_list:mozc.commands.CommandList.commands)
  return commands_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace commands
}  // namespace mozc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mozc::commands::KeyEvent_SpecialKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::KeyEvent_SpecialKey>() {
  return ::mozc::commands::KeyEvent_SpecialKey_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::KeyEvent_ModifierKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::KeyEvent_ModifierKey>() {
  return ::mozc::commands::KeyEvent_ModifierKey_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::KeyEvent_InputStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::KeyEvent_InputStyle>() {
  return ::mozc::commands::KeyEvent_InputStyle_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::GenericStorageEntry_StorageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::GenericStorageEntry_StorageType>() {
  return ::mozc::commands::GenericStorageEntry_StorageType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::SessionCommand_CommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::SessionCommand_CommandType>() {
  return ::mozc::commands::SessionCommand_CommandType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::SessionCommand_UsageStatsEvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::SessionCommand_UsageStatsEvent>() {
  return ::mozc::commands::SessionCommand_UsageStatsEvent_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Context_InputFieldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Context_InputFieldType>() {
  return ::mozc::commands::Context_InputFieldType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Capability_TextDeletionCapabilityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Capability_TextDeletionCapabilityType>() {
  return ::mozc::commands::Capability_TextDeletionCapabilityType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_SpecialRomanjiTable> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_SpecialRomanjiTable>() {
  return ::mozc::commands::Request_SpecialRomanjiTable_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_SpaceOnAlphanumeric> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_SpaceOnAlphanumeric>() {
  return ::mozc::commands::Request_SpaceOnAlphanumeric_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_EmojiCarrierType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_EmojiCarrierType>() {
  return ::mozc::commands::Request_EmojiCarrierType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_RewriterCapability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_RewriterCapability>() {
  return ::mozc::commands::Request_RewriterCapability_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_CrossingEdgeBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_CrossingEdgeBehavior>() {
  return ::mozc::commands::Request_CrossingEdgeBehavior_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_LanguageAwareInputBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_LanguageAwareInputBehavior>() {
  return ::mozc::commands::Request_LanguageAwareInputBehavior_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Input_CommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Input_CommandType>() {
  return ::mozc::commands::Input_CommandType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Input_TouchAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Input_TouchAction>() {
  return ::mozc::commands::Input_TouchAction_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Result_ResultType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Result_ResultType>() {
  return ::mozc::commands::Result_ResultType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Preedit_Segment_Annotation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Preedit_Segment_Annotation>() {
  return ::mozc::commands::Preedit_Segment_Annotation_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Output_PreeditMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Output_PreeditMethod>() {
  return ::mozc::commands::Output_PreeditMethod_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Output_ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Output_ErrorCode>() {
  return ::mozc::commands::Output_ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Output_ToolMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Output_ToolMode>() {
  return ::mozc::commands::Output_ToolMode_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::CompositionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::CompositionMode>() {
  return ::mozc::commands::CompositionMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protocol_2fcommands_2eproto
